<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://vicyor.gitee.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="并发编程是Java语言的重要特性之一,在Java平台上提供了许多基本的并发功能来辅助开发多线程应用程序">
<meta property="og:type" content="article">
<meta property="og:title" content="java-concurrency-in-practice">
<meta property="og:url" content="http://vicyor.gitee.io/2019/12/19/java-concurrency-in-practice/index.html">
<meta property="og:site_name" content="Vicyor">
<meta property="og:description" content="并发编程是Java语言的重要特性之一,在Java平台上提供了许多基本的并发功能来辅助开发多线程应用程序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://vicyor.gitee.io/2019/12/19/java-concurrency-in-practice/Data-Request.png">
<meta property="og:image" content="http://vicyor.gitee.io/2019/12/19/java-concurrency-in-practice/Request-Data.png">
<meta property="og:image" content="http://vicyor.gitee.io/2019/12/19/java-concurrency-in-practice/jdk7hashmap-problem.jpg">
<meta property="article:published_time" content="2019-12-19T11:40:00.000Z">
<meta property="article:modified_time" content="2020-07-11T01:00:42.772Z">
<meta property="article:author" content="vicyor">
<meta property="article:tag" content="java">
<meta property="article:tag" content="juc">
<meta property="article:tag" content="concurrent">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://vicyor.gitee.io/2019/12/19/java-concurrency-in-practice/Data-Request.png">

<link rel="canonical" href="http://vicyor.gitee.io/2019/12/19/java-concurrency-in-practice/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>java-concurrency-in-practice | Vicyor</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vicyor</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">49</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">55</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vicyor.gitee.io/2019/12/19/java-concurrency-in-practice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="vicyor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vicyor">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java-concurrency-in-practice
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-19 19:40:00" itemprop="dateCreated datePublished" datetime="2019-12-19T19:40:00+08:00">2019-12-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-11 09:00:42" itemprop="dateModified" datetime="2020-07-11T09:00:42+08:00">2020-07-11</time>
              </span>

          
            <span id="/2019/12/19/java-concurrency-in-practice/" class="post-meta-item leancloud_visitors" data-flag-title="java-concurrency-in-practice" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/19/java-concurrency-in-practice/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/19/java-concurrency-in-practice/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>91k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:23</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>并发编程是Java语言的重要特性之一,在Java平台上提供了许多基本的并发功能来辅助开发多线程应用程序</p>
<a id="more"></a>
<h3 id="并发简史"><a href="#并发简史" class="headerlink" title="并发简史"></a>并发简史</h3><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.套接字(socket).</span><br><span class="line">2.信号量(semaphore).</span><br><span class="line">3.共享内存(shared memory).</span><br><span class="line">4.管道(pipe).</span><br><span class="line">5.文件(file).</span><br></pre></td></tr></table></figure>
<h4 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.守护线程(daemon thread):守护线程,指的是程序运行时在后台提供的一种通用服务的线程.</span><br><span class="line">2.JVM会在所有的用户线程(User Thread)terminated后退出.</span><br></pre></td></tr></table></figure>
<h4 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.并发(concurrency):</span><br><span class="line">   在一个时间段,多个线程同时执行.</span><br><span class="line">   ps:对于gc,并发意味着垃圾回收线程可以和其它线程同时执行.</span><br><span class="line">2.并行(parallellism):</span><br><span class="line">   在一个时间点,多个线程同时执行.</span><br><span class="line">   ps:对于gc,并行意味着只有多个垃圾回收线程同时执行.</span><br></pre></td></tr></table></figure>
<h4 id="吞吐率和吞吐量"><a href="#吞吐率和吞吐量" class="headerlink" title="吞吐率和吞吐量"></a>吞吐率和吞吐量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">吞吐率: </span><br><span class="line">   一个业务系统在单位时间内提供的参量.</span><br><span class="line">   在计算机或数据通信系统,指的是单位时间内通过某通信通道(a communication channel)或某个节点成功交互数据的平均速率,</span><br><span class="line">   通常以bps-bits per second 为单位.</span><br><span class="line">   ps: 每秒  成功的数据速率</span><br><span class="line">吞吐量: </span><br><span class="line">   网络,设备,端口,虚电路或其它设施,单位时间内成功的传送数据的数量.</span><br></pre></td></tr></table></figure>
<h4 id="请求的处理-bio-nio-aio"><a href="#请求的处理-bio-nio-aio" class="headerlink" title="请求的处理(bio,nio,aio)"></a>请求的处理(bio,nio,aio)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.Bio(Blocked io).</span><br><span class="line">  1.BIO的阻塞操作</span><br><span class="line">    inputStream.read();</span><br><span class="line">    serverSocket.accept();</span><br><span class="line">  2.BIO阻塞时候,当cpu时间片使用结束,Thread Status由Running ---&gt;Runnable</span><br><span class="line">2.Nio(non-blocking io)</span><br><span class="line">  1.JDK 1.4引入了java.nio包,提供了Channel,Selector,Buffer.</span><br><span class="line">  2.Reactor设计模式,同步非阻塞,多路复用.</span><br><span class="line">3.Aio(Asynchronous io).</span><br><span class="line">  1.AIO基于操作系统提供的I&#x2F;O去完成事件回调.</span><br><span class="line">  2.回调有2种方式.</span><br><span class="line">    Future方式,CompletionHandler方式.</span><br></pre></td></tr></table></figure>
<p>BIO示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">多文件上传</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> Socket socket=<span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        socket=<span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>,<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span>(!socket.isConnected());</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] intToByteArray(<span class="keyword">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">return</span>  &#123;(<span class="keyword">byte</span>)(a&gt;&gt;<span class="number">24</span>&amp;&amp;<span class="number">0xff</span>),(<span class="keyword">byte</span>)(a&gt;&gt;<span class="number">16</span>&amp;&amp;<span class="number">0xff</span>),(<span class="keyword">byte</span>)(a&gt;&gt;<span class="number">8</span>&amp;&amp;<span class="number">0xff</span>),(<span class="keyword">byte</span>)(a&amp;&amp;<span class="number">0xff</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//socket 输入流</span></span><br><span class="line">        BufferedReader sr=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//文件输入流</span></span><br><span class="line">        BufferedInputStream bis=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//socket 输出流</span></span><br><span class="line">        BufferedOutputStream bos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[]buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sr=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</span><br><span class="line">            bos=<span class="keyword">new</span> BufferedOutputStream(socket.getOutputStream());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">                String fn=String.format(<span class="string">"d:/tmp/s%d.rar"</span>,i);</span><br><span class="line">                bis=<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fn)));</span><br><span class="line">                <span class="keyword">int</span> t =bis.available();</span><br><span class="line">                <span class="comment">//写长度</span></span><br><span class="line">                bos.write(intToByteArray(t));</span><br><span class="line">                <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>((r=bis.read(buf))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    bos.write(buf,<span class="number">0</span>,r);</span><br><span class="line">                    bos.flush(); <span class="comment">//刷新缓存</span></span><br><span class="line">                    t-=r;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//获取服务器响应</span></span><br><span class="line">                String s=sr.readLine();</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"ok"</span>.equalsIgnoreCase(s))&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">             &#125;   </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            StreamUtil.close(bis);</span><br><span class="line">            socket.shutdownInput();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Processor</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket=socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">byteArrayToInt</span><span class="params">(<span class="keyword">byte</span> []b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">byte</span>[<span class="number">0</span>]&amp;<span class="number">0xff</span>)&lt;&lt;<span class="number">24</span>| (<span class="keyword">byte</span>[<span class="number">1</span>]&amp;<span class="number">0xff</span>)&lt;&lt;<span class="number">16</span>|(<span class="keyword">byte</span>[<span class="number">2</span>]&amp;<span class="number">0xff</span>)&lt;&lt;<span class="number">8</span>|(<span class="keyword">byte</span>[<span class="number">0</span>]&amp;<span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//socket 输入流</span></span><br><span class="line">        BufferedInputStream bis=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//文件 输出流</span></span><br><span class="line">        BufferedOutpuStream bos=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//socket 输出流</span></span><br><span class="line">        PrintWriter pw=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[]buf=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10240</span>];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//length</span></span><br><span class="line">        <span class="keyword">byte</span>[]h=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            bis=<span class="keyword">new</span> BufferedInputStream(socket.getInputStream());</span><br><span class="line">            pw=<span class="keyword">new</span> PrintWriter(socket.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!socket.isInputShutdown()&amp;&amp;(bis.read(h))==<span class="number">4</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> t=byteArrayToInt(h);</span><br><span class="line">                <span class="keyword">int</span> total=t;</span><br><span class="line">                <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">                bos=<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(fn)));</span><br><span class="line">                String fn=<span class="string">""</span></span><br><span class="line">                <span class="keyword">while</span>(r&lt;t&amp;&amp;(r=bis.read(buf))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    t-=r;</span><br><span class="line">                    bos.write(buf,<span class="number">0</span>,r);</span><br><span class="line">                    bos.flush();</span><br><span class="line">                &#125;</span><br><span class="line">                pw.println(<span class="string">"ok"</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * server</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServerSocket ss=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> live=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService pool=Executors.newCachedThreadPool();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(live)&#123;</span><br><span class="line">             Socket socket=ss.accept();</span><br><span class="line">             pool.execute(<span class="keyword">new</span> Processor(socket));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">         ss=<span class="keyword">new</span> ServerSocket(<span class="string">'127.0.0.1'</span>,<span class="number">9000</span>);</span><br><span class="line">         live=<span class="keyword">true</span>;</span><br><span class="line">         thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;</span><br><span class="line">         live=<span class="keyword">false</span>;</span><br><span class="line">         pool.shutdown();</span><br><span class="line">         ss.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NIO示例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line">聊天室的例子,相当于qq中的群聊.</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端代码: Client.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log=LoggerFactory.getLogger(Client<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset charset=Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//用于读取的Buffer</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer=ByteBuffer.allocat(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//待发送的消息列表</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt;queue=<span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;();</span><br><span class="line">    <span class="comment">//存活,可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> live=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        selector=Selector.open();</span><br><span class="line">        socketChannel=SocketChannel.open();</span><br><span class="line">        <span class="comment">//配置通道非阻塞</span></span><br><span class="line">        socketChannel.configBlocking(<span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">9000</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(socketChannel.finishConnect())&#123;</span><br><span class="line">           socketChannel.register(selector,SelectionKey.OP_READ|SelectionKey.OP_WRITE);</span><br><span class="line">           thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(live&amp;&amp;!Thread.interrupted())&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(<span class="number">1000</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Set&lt;SelectionKey&gt;set=selector.selectorKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt;it=set.iterator();</span><br><span class="line">                <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                    SelectionKey key=it.next();</span><br><span class="line">                    it.remove(); <span class="comment">//迭代器移除,不会出现ConcurrentModifyException</span></span><br><span class="line">                    SocketChannel sc=<span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(key.isValid()&amp;&amp;key.isReadable())&#123;</span><br><span class="line">                        sc=(SocketChannel)key.channel();</span><br><span class="line">                        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">                        buffer.clear();</span><br><span class="line">                        String s=<span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">while</span>((r=sc.read(buffer))&gt;<span class="number">0</span>)&#123;<span class="comment">//position=message.length-1</span></span><br><span class="line">                           buffer.flip(); <span class="comment">// limit=position,position=0 </span></span><br><span class="line">                           sb.append(charset.decode(buffer));<span class="comment">//position=limit=message.length-1</span></span><br><span class="line">                           buffer.clear(); <span class="comment">//limit=capacity,position=0</span></span><br><span class="line">                           s=sb.toString();</span><br><span class="line">                           <span class="keyword">if</span>(s.endswith(<span class="string">"\n"</span>))&#123;</span><br><span class="line">                                 <span class="keyword">break</span>;</span><br><span class="line">                           &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//收到的消息可能发生粘包(Tcp存在缓存)</span></span><br><span class="line">                        String[]sa=s.split(<span class="string">"\n"</span>);</span><br><span class="line">                        <span class="keyword">for</span>(String a:sa)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(!StringUtil.isEmpty(a))&#123;</span><br><span class="line">                               System.out.println(a);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isValid&amp;&amp;key.isWritable()&amp;&amp;!queue.isEmpty())&#123;</span><br><span class="line">                            s=queue.poll();</span><br><span class="line">                            sc=(SocketChannel)key.channel();</span><br><span class="line">                            <span class="comment">//这个方法不设置limit</span></span><br><span class="line">                            ByteBuffer buf=ByteBuffer.wrap(s.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                            <span class="comment">//手动设置limit</span></span><br><span class="line">                            buf.limit(s.length());</span><br><span class="line">                            <span class="keyword">while</span>(buf.hasRemaining()&amp;&amp;(r=sc.write(buf)&gt;<span class="number">0</span>))&#123;</span><br><span class="line">                                log.debug(<span class="string">"write&#123;&#125;bytes to server"</span>,r);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"Error on socket I/O"</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            StreamUtil.close(selector);</span><br><span class="line">            StreamUtil.close(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        live=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">             thread.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">             log.error(<span class="string">"Be interrupted on join"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        StreamUtil.close(selector);</span><br><span class="line">        StreamUtil.close(socketChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> thread.isAlive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String s)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        queue.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">        Client client=<span class="keyword">new</span> Client();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            client.start();</span><br><span class="line">            String cmd=<span class="keyword">null</span>;</span><br><span class="line">            br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            System.out.println(<span class="string">"Say 'bye' to exit"</span>);</span><br><span class="line">            <span class="keyword">while</span>((cmd=br.readLine())!=<span class="keyword">null</span>&amp;&amp;client.isAlive())&#123;</span><br><span class="line">                client.send(cmd+<span class="string">"\n"</span>);</span><br><span class="line">                <span class="keyword">if</span>(cmd.equals(<span class="string">"bye"</span>))&#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            log.error(<span class="string">"Error: &#123;&#125;  on start server"</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            StreamUtil.close(br);</span><br><span class="line">            <span class="comment">//优雅退出</span></span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"bye"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log=LoggerFactory.getLogger(Server<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset charset=Charset.forName(<span class="string">"Utf-8"</span>);</span><br><span class="line">    <span class="keyword">private</span> Selector selector=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel ssc=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//客户端发来的消息</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;String&gt;queue=<span class="keyword">new</span> ConcurrentLinkedQueue&lt;String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> live=<span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> <span class="title">IOException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        selector=Selector.open();</span><br><span class="line">        ssc=ServerSocketChannel.open();</span><br><span class="line">        ssc.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9000</span>));</span><br><span class="line">        ssc.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onAcceptable</span><span class="params">(SelectionKey key)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        ServerSocketChannel ssc=(ServerSocketChannel)key.channel();</span><br><span class="line">        SocketChannel sc=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sc=ssc.accept();</span><br><span class="line">            <span class="keyword">if</span>(sc!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                log.info(<span class="string">"Client &#123;&#125; connected"</span>,sc.getRemoteAddress());</span><br><span class="line">                sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">//读时 buffer复用,避免空间浪费</span></span><br><span class="line">                sc.register(selector,SelectionKey.OP_READ|SelectionKey.OP_WRITE,ByteBuffer.allocate(<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">           log.error(<span class="string">"Error:&#123;&#125; on accept connection"</span>,e);</span><br><span class="line">           StreamUtil.close(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onReadable</span><span class="params">(SelectionKey key)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        SocketChannel sc=(SocketChannel)key.channel();</span><br><span class="line">        ByteBuffer buf=(ByteBuffer)key.attachment();</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String rs=<span class="keyword">null</span>;</span><br><span class="line">        String remote=<span class="keyword">null</span>;</span><br><span class="line">        buf.clear();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            remote=sc.getRemoteAddress().toString();</span><br><span class="line">            <span class="keyword">while</span>((r=sc.read(buf)&gt;<span class="number">0</span>))&#123;</span><br><span class="line">                buf.flip();</span><br><span class="line">                sb.append(charset.decode(buf));</span><br><span class="line">                buf.clear();</span><br><span class="line">                <span class="keyword">if</span>(rs.endWith(<span class="string">"\n"</span>))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            StreamUtil.close(sc);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rs=sb.toString();</span><br><span class="line">        <span class="keyword">if</span>(Util.strIsNotEmpty(rs))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!StringUtil.isEmpty(rs))&#123;</span><br><span class="line">                String []sa=rs.split(<span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">for</span>(String s:sa)&#123;</span><br><span class="line">                    queue.add(String.format(<span class="string">"%s:%s\n"</span>,remote,s));</span><br><span class="line">                    <span class="keyword">if</span>(<span class="string">"bye"</span>.equals(s))&#123;</span><br><span class="line">                        StreamUtil.close(sc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(SocketChannel sc,ByteBuffer buffer)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        buf.flip();</span><br><span class="line">        <span class="keyword">int</span> r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            whiel(buf.hasRemaining()&amp;&amp;(r=sc.write(buffer))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                log.debuf(<span class="string">"write back &#123;&#125; bytes to &#123;&#125;"</span>,r,sc.getRemoteAddress())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            sc.close();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(live&amp;&amp;!Thread.interrupted())&#123;</span><br><span class="line">                <span class="keyword">if</span>(selector.select(<span class="number">1000</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>(); <span class="comment">//阻塞 --&gt;自旋</span></span><br><span class="line">                &#125;</span><br><span class="line">                ByteBuffer outBuf=<span class="keyword">null</span>;</span><br><span class="line">                String outMsg=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(!StringUtil.isEmpty(outMsg))&#123;</span><br><span class="line">                    outBuf=ByteBuffer.wrap(outMsg.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">                    outBuf.limit(outMsg.length());</span><br><span class="line">                &#125;</span><br><span class="line">                Set&lt;SelectionKey&gt;set=selector.selectedKeys();</span><br><span class="line">                Iterator&lt;SelectionKey&gt;it=set.iterator();</span><br><span class="line">                <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">                    SelectionKey key=it.next();</span><br><span class="line">                    it.remove();</span><br><span class="line">                    <span class="keyword">if</span>(key.isValid()&amp;&amp;key.isAcceptable())&#123;</span><br><span class="line">                        <span class="keyword">this</span>.onAcceptable(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isValid()&amp;&amp;key.isReadable())&#123;</span><br><span class="line">                        <span class="keyword">this</span>.onReadable(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(key.isValid()&amp;&amp;key.isWritable()&amp;&amp;outBuf!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                        SocketChannel sc=(SocketChannel)key.channel();</span><br><span class="line">                        <span class="keyword">this</span>.write(sc,outBuf);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"Error on socket I/O"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        live=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            thread.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"Be Interrupted on join Error:&#123;&#125;"</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            StreamUtil.close(selector);</span><br><span class="line">            StreamUtil.close(ssc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">        Server server=<span class="keyword">new</span> Server();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            server.start();</span><br><span class="line">            String cmd=<span class="keyword">null</span>;</span><br><span class="line">            System.out.println(<span class="string">"Enter 'exit' to exit"</span>);</span><br><span class="line">            br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="keyword">while</span>((cmd=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"exit"</span>.equalsIgnoreCase(cmd))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"Error:&#123;&#125; on run server"</span>,e);</span><br><span class="line">        &#125;finnaly&#123;</span><br><span class="line">            StreamUtil.close(br);</span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"bye"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AIO实例代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line">客户端批量文件上传.</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * client </span></span><br><span class="line"><span class="comment"> * ps:虽然是异步,但逻辑还是串行,有点像CompletionHandler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger log=LoggerFactory.getLogger(Client<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel asc;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">    <span class="comment">//文件输入流</span></span><br><span class="line">    <span class="keyword">private</span> FileInputStream fis;</span><br><span class="line">    <span class="keyword">private</span> FileChannel fc;</span><br><span class="line">    <span class="comment">//文件数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxFileNo=<span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Integer i)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//关闭上一个文件</span></span><br><span class="line">        StreamUtil.close(fc);</span><br><span class="line">        StreamUtil.close(fis);</span><br><span class="line">        String fn=String.format(<span class="string">"d:/temp/s%d.rar"</span>,i);</span><br><span class="line">        fis=<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(fn));</span><br><span class="line">        fc=fis.getChannel();</span><br><span class="line">        buffer.clear();</span><br><span class="line">        buffer.putLong(fc.size()+<span class="number">8</span>);<span class="comment">//long --&gt;文件长度,文件长度由文件的长度+文件长度的长度</span></span><br><span class="line">        fc.read(buffer);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        asc.write(buffer,i,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//客户端写事件回调函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer r,Integer attachment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            log.info(<span class="string">"No written data now.Quit"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"Written &#123;&#125; bytes"</span>,r);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(buffer.hasRemaing())&#123;<span class="comment">//上一次write操作可能没将buffer写完.</span></span><br><span class="line">                asc.write(buffer,attachment,<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">if</span>(fc.read(buffer)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                asc.write(buffer,attachment,<span class="keyword">this</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;    <span class="comment">//文件发送完毕</span></span><br><span class="line">                <span class="comment">//等待服务器响应</span></span><br><span class="line">                r=asc.read(buffer).get();</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">long</span> total=buffer.getLong();</span><br><span class="line">                <span class="keyword">long</span> received=buffer.getLong();</span><br><span class="line">                System.out.println(String.format(<span class="string">"%d/%d"</span>,total,received));</span><br><span class="line">                <span class="keyword">if</span>(attachment&lt;maxFile)&#123;</span><br><span class="line">                    <span class="comment">//send会更新fileChannel</span></span><br><span class="line">                    <span class="keyword">this</span>.send(attachment+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//所有文件都发送完毕</span></span><br><span class="line">                    asc.shutdownOutput();</span><br><span class="line">                    synchronied(<span class="keyword">this</span>)&#123;</span><br><span class="line">                        <span class="keyword">this</span>.notify();<span class="comment">//唤醒主线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catche(Exception e)&#123;</span><br><span class="line">            <span class="keyword">this</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException,InterruptedException,ExecutionException</span>&#123;</span><br><span class="line">        asc=AsynchronousSocketChannel.open();</span><br><span class="line">        Future&lt;Void&gt;ft=asc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">9000</span>));</span><br><span class="line">        ft.get();<span class="comment">//阻塞</span></span><br><span class="line">        <span class="keyword">this</span>.send(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StreamUtil.close(asc);</span><br><span class="line">        StreamUtil.close(fis);</span><br><span class="line">        StreamUtil.close(fc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc,Integer attachment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.close();</span><br><span class="line">        SocketAddress sa=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sa=asc.getRemoteAddress();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"&#123;&#125; on &#123;&#125;"</span>,e,sa);</span><br><span class="line">        &#125;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">        Client client=<span class="keyword">new</span> Client();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            client.start();</span><br><span class="line">            <span class="keyword">synchronized</span>(client)&#123;</span><br><span class="line">                client.await();<span class="comment">//发送完才会释放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"Error on run client"</span>,e);    </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            StreamUtil.close(br);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"bye"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Server.java</span></span><br><span class="line"><span class="comment"> * 服务端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">AsynchronousSocketChannel</span>,<span class="title">Object</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log=LoggerFactory.getLogger(Server<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel assc=<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        assc=AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>,<span class="number">9000</span>));</span><br><span class="line">        assc.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel asc,Object attachment)</span></span>&#123;</span><br><span class="line">        assc.accept(<span class="keyword">null</span>,attachment);<span class="comment">//再注册,attachment---&gt;this---&gt;accept的CompletionHandler</span></span><br><span class="line">        ReadCH reader=<span class="keyword">new</span> ReaderCH(asc);</span><br><span class="line">        asc.read(reader.getBuffer(),<span class="number">0</span>,reader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable e,Object attachment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.close();</span><br><span class="line">        log.error(<span class="string">"Error on accept connection"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StreamUtil.close(assc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">        Server server=<span class="keyword">new</span> Server();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            server.start();</span><br><span class="line">            String cmd=<span class="keyword">null</span>;</span><br><span class="line">            System.out.println(<span class="string">"Enter 'exit' to exit"</span>);</span><br><span class="line">            br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">            <span class="keyword">while</span>((cmd=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"exit"</span>.equalsIgnoreCase(cmd))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"Error on run server"</span>,e);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            StreamUtil.close(br);</span><br><span class="line">            server.close();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"bye"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * server 的 read的CompletionHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadCH</span> <span class="keyword">implements</span> <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> fianl Logger log=LoggerFactoy.getLogger(ReadCh<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> ByteBuffer buffer=ByteBuffer.allocate(<span class="number">10240</span>);</span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel asc;</span><br><span class="line">    <span class="keyword">private</span> FileOutputStream fos;</span><br><span class="line">    <span class="keyword">private</span> FileChannel fc;</span><br><span class="line">    <span class="comment">//当前这笔数据的总字节数 前8个字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;</span><br><span class="line">    <span class="comment">//当前这笔数据的以接收字节数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> received;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadCh</span><span class="params">(AsychronousSocketChannel asc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.asc=asc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Buffer <span class="title">getBuffer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer r,Integer attachment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            log.info(<span class="string">"No more incoming data now. Quit"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        received+=r;</span><br><span class="line">        log.info(<span class="string">"Read &#123;&#125;/&#123;&#125;/&#123;&#125;bytes"</span>,r,received,total);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//读的异步事件响应时,buffer是填充好的</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">if</span>(fc==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//新文件</span></span><br><span class="line">                total=buffer.getLong();</span><br><span class="line">                InetSocketAddress isa=(InetSocketAddress)asc.getRemoteAddress();</span><br><span class="line">                fos=<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(String.format(<span class="string">"d:/temp/%d_%d.rar"</span>,isa.getPort(),attachment)));</span><br><span class="line">                fc=fos.getChannel();</span><br><span class="line">            &#125;</span><br><span class="line">            fc.write(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">if</span>(receive&lt;total)&#123;</span><br><span class="line">                asc.read(buffer,attachment,<span class="keyword">this</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//文件读完响应客户端</span></span><br><span class="line">                buffer.putLong(total);</span><br><span class="line">                buffer.putLong(received);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                Future future=asc.write(buffer)</span><br><span class="line">                future.get();</span><br><span class="line">                StreamUtil.close(fos);</span><br><span class="line">                fos=<span class="keyword">null</span>;</span><br><span class="line">                StreamUtil.close(fc);</span><br><span class="line">                fc=<span class="keyword">null</span>;<span class="comment">//channel =null</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">                total=<span class="number">0</span>;</span><br><span class="line">                received=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">this</span>.asc.read(buffer,attachment+<span class="number">1</span>,<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"Error on receive file"</span>,e);</span><br><span class="line">            <span class="keyword">this</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StreamUtil.close(asc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc,Integer attachment)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.close();</span><br><span class="line">        SocketAddress sa=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            sa=asc.getRemoteAddress();</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            log.error(<span class="string">"Error on read from getRemoteAddress"</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        log.error(<span class="string">"Error on read from &#123;&#125;"</span>,sa,exc);</span><br><span class="line">        <span class="keyword">this</span>.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="安全性和活跃性"><a href="#安全性和活跃性" class="headerlink" title="安全性和活跃性"></a>安全性和活跃性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">安全性: 永远不要发生糟糕的事情.</span><br><span class="line">活跃性: 某件正确的事最终会发生.</span><br></pre></td></tr></table></figure>
<h4 id="死锁-活锁-饥饿"><a href="#死锁-活锁-饥饿" class="headerlink" title="死锁,活锁,饥饿"></a>死锁,活锁,饥饿</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">死锁: 死锁是指两个或两个以上的进程在执行过程中,由于竞争资源,造成相互阻塞的情况.</span><br><span class="line">饥饿: 线程由于优先级或其它原因,一直无法得到cpu的资源调度.</span><br><span class="line">活锁: 错误的唤醒,某些条件没有满足,一直重复尝试-失败-尝试-失败的过程.</span><br><span class="line">1.死锁产生的原因.</span><br><span class="line">  1.互斥.</span><br><span class="line">  2.不可剥夺.</span><br><span class="line">  3.循环等待.</span><br><span class="line">  4.请求和保持.</span><br><span class="line">2.死锁的经典例子.</span><br><span class="line"> 锁顺序死锁</span><br><span class="line"> public class LeftRightDeadLock&#123;</span><br><span class="line">     private final Object left&#x3D;new Object();</span><br><span class="line">     private final Object right&#x3D;new Object();</span><br><span class="line">     public void leftRight()&#123;</span><br><span class="line">         synchronized(left)&#123;</span><br><span class="line">             synchronized(right)&#123;</span><br><span class="line">                 doSomething();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     public void rightLeft()&#123;</span><br><span class="line">         synchronized(right)&#123;</span><br><span class="line">             synchronized(left)&#123;</span><br><span class="line">                 doSomething();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">3.死锁的避免.</span><br><span class="line">  1.加锁顺序(解决循环问题).</span><br><span class="line">  2.使用定时锁获取资源.给定时间内获取失败则不加锁.</span><br><span class="line">  3.JVM 工具线程转储(Thread Dump)识别死锁.</span><br><span class="line">  4.锁粒度的降低.(例如分段锁)</span><br></pre></td></tr></table></figure>
<h4 id="多线程的缺点-线程特别的多"><a href="#多线程的缺点-线程特别的多" class="headerlink" title="多线程的缺点(线程特别的多)"></a>多线程的缺点(线程特别的多)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.对于计算密集型的任务.在某个阈值后,提升线程的数量,对性能并没有较大的提升.</span><br><span class="line">2.线程间切换的消耗.</span><br><span class="line">3.创建线程的消耗.</span><br><span class="line">4.栈空间的OOM异常.</span><br></pre></td></tr></table></figure>
<h4 id="多线程的优点"><a href="#多线程的优点" class="headerlink" title="多线程的优点"></a>多线程的优点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.提高应用程序的响应性.</span><br><span class="line">2.I&#x2F;O密集型任务,阻塞操作特别多的任务.</span><br><span class="line">3.充分利用操作系统cpu的资源.</span><br><span class="line">4.多线程可以设置优先级优化性能.</span><br></pre></td></tr></table></figure>
<h3 id="线程安全的相关概念"><a href="#线程安全的相关概念" class="headerlink" title="线程安全的相关概念"></a>线程安全的相关概念</h3><h4 id="线程安全的定义"><a href="#线程安全的定义" class="headerlink" title="线程安全的定义"></a>线程安全的定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当多个线程访问某个类时,这个类始终表现出正确的行为,则称这个类是线程安全的.(ps:线程安全是对类而言的).</span><br></pre></td></tr></table></figure>
<h4 id="线程安全的几种实现方式"><a href="#线程安全的几种实现方式" class="headerlink" title="线程安全的几种实现方式"></a>线程安全的几种实现方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.同步机制(ps:lock).</span><br><span class="line">2.原子操作(ps:原语,atomic).</span><br><span class="line">3.线程本地分配(ps:ThreadLocal).</span><br><span class="line">4.常量,不可变(ps:final).</span><br><span class="line">5.栈分配(on stack allocation).</span><br></pre></td></tr></table></figure>
<h3 id="对象的共享"><a href="#对象的共享" class="headerlink" title="对象的共享"></a>对象的共享</h3><h4 id="非原子的64位操作"><a href="#非原子的64位操作" class="headerlink" title="非原子的64位操作"></a>非原子的64位操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.JMM-Java内存模型要求,变量的读取和写入必须是原子操作,</span><br><span class="line">2.对于volatile类型的long和double变量,JVM允许将64位的读操作和写操作分解成两个32位的读操作和写操作.</span><br><span class="line">  ps:虽然JVM允许64位的double和long读写不是原子的,</span><br><span class="line">        但是对hot-spot这些主流虚拟机而言,64位的读和写已经实现为原语操作.</span><br></pre></td></tr></table></figure>
<h4 id="发布和逸出"><a href="#发布和逸出" class="headerlink" title="发布和逸出"></a>发布和逸出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.发布(publish):   使对象能够在当前作用域之外的代码使用.</span><br><span class="line">2.逸出(escape):    当某个不该被发布的对象发布时候,这种情况称为逸出.</span><br></pre></td></tr></table></figure>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.内部类是java的一种语法糖.</span><br><span class="line">2.内部类的字段表会自动添加外部类的对象.</span><br><span class="line">3.外部类的私有字段能被内部类访问(溢出).</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object obj=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">public</span> Object obj2=<span class="keyword">new</span> Object();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">        Class clazz=InnerClass<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Arrays.stream(clazz.getDeclaredFields())</span><br><span class="line">                .forEach(field -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"**"</span>+field+<span class="string">"**"</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">                Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        Field field = fields[<span class="number">0</span>];</span><br><span class="line">        OuterClass outer=<span class="keyword">new</span> OuterClass();</span><br><span class="line">        InnerClass innerClass = outer.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        Object o = field.get(innerClass);</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出,这个字段类型是外部类,名字优点怪</span></span><br><span class="line">**<span class="keyword">final</span> com.vicyor.blog.apps.OuterClass com.vicyor.blog.apps.OuterClass$InnerClass.<span class="keyword">this</span>$<span class="number">0</span>**</span><br><span class="line"><span class="comment">//字段表确实存了外部类的对象.</span></span><br><span class="line">com.vicyor.blog.apps.OuterClass@<span class="number">53e25</span>b76</span><br><span class="line">这因该是外部类的引用吧</span><br></pre></td></tr></table></figure>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.ThreadLocal实现线程封闭,能使线程中的某个值与保存的对象关联起来.</span><br><span class="line">2.源码分析.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal#set</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取线程保存的对象 threadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">ThreadLocal$ThreadLocalMap</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * hash冲突----&gt; 开地址法 ----&gt; 顺序探测法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          *        解决Hash冲突的方式: </span></span><br><span class="line"><span class="comment">          *        开地址法:顺序探测法</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];e != <span class="keyword">null</span>;e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * entry !=null </span></span><br><span class="line"><span class="comment">                 * key ==null</span></span><br><span class="line"><span class="comment">                 * 说明key被回收了,entry没回收</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 新来的</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line">ThreadLocal$ThreadLocalMap$Entry</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k); ----&gt;<span class="keyword">super</span>.referent=k;</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">ThreadLocal$ThreadLocalMap$getEntryAfterMiss</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * hash冲突时候的get方式</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">3.ThreadLocalMap的内存泄露.</span><br><span class="line">  内存泄露(Memory Leak):内存泄露是指程序中已动态分配的堆内存由于某种原因(可达性分析一直可达)程序无法释放,</span><br><span class="line">                                             造成系统内存的浪费,导致程序运行速度减慢甚至系统奔溃等严重后果.</span><br><span class="line">    1.ThreadLocal的使用.一个Thread&#39;s threadLocalMap可以存在多个ThreadLocal.</span><br><span class="line">      static ThreadLocal&lt;Integer&gt; moneyTL&#x3D;new ThreadLocal&lt;Integer&gt;();</span><br><span class="line">        static ThreadLocal&lt;Authentication&gt;authentication&#x3D;new ThreadLocal&lt;Authentication&gt;();</span><br><span class="line">        .....</span><br><span class="line">    2.ThreadLocalMap内存泄露的原因.</span><br><span class="line">     1.在线程池的情况下,多任务复用thread,上一个任务设置到Thread的ThreadLocal变量不会被回收.</span><br><span class="line">        解决方式:</span><br><span class="line">          1.Entry的key(ThreadLocal)是WeakReference,</span><br><span class="line">              当ThreadLocal不存在外部Strong Reference时候,</span><br><span class="line">                Entry的key会在gc时候被回收,也就是会出现了Entry的key为null的情况.</span><br><span class="line">            2.ThreadLocalMap提供了expungeStaleEntries来去除key为null的ThreadLocal.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          Entry[] tab = table;</span><br><span class="line">          <span class="keyword">int</span> len = tab.length;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">              Entry e = tab[j];</span><br><span class="line">              <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">                  expungeStaleEntry(j);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器与ConcurrentModificationException"><a href="#迭代器与ConcurrentModificationException" class="headerlink" title="迭代器与ConcurrentModificationException"></a>迭代器与ConcurrentModificationException</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">1.fail-fast: </span><br><span class="line">    java集合中一种及时失败机制,</span><br><span class="line">    在迭代集合的过程中,若集合结构发生改变,会发生fail-fast.</span><br><span class="line">2.fail-fast的实现:</span><br><span class="line">  以ArrayList为例子:</span><br><span class="line">    ArrayList:</span><br><span class="line">            &#x2F;&#x2F;记录list结构修改的次数</span><br><span class="line">            protected transient int modCount &#x3D; 0;</span><br><span class="line">    ArrayList$Iterator</span><br><span class="line">            int expectedModCount&#x3D;modCount;</span><br><span class="line">    通过迭代器迭代时候,会通过checkForComodification()方法检测 modeCount &#x3D;&#x3D; exceptedModCount,</span><br><span class="line">    若不相等,则会抛出ConcurrentModificationException.</span><br><span class="line">3.几种特殊的不会出现ConcurrentmodificationException的情况.</span><br><span class="line">  1.情形一:在遍历到到数第二个元素时候,通过list.remove(index)删除集合的任意元素.</span><br><span class="line">      源码:</span><br><span class="line">        ArrayList$Iterator#hasNext</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 1. cursor &#x3D; size-2时,list.remove(anyIndex)删除一个元素,size&#x3D;size-1;</span><br><span class="line">         * 2. cursor++;</span><br><span class="line">         * 3. cursor&#x3D;&#x3D;size; 迭代结束.</span><br><span class="line">         *  </span><br><span class="line">         *&#x2F;</span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">           return cursor !&#x3D; size;</span><br><span class="line">    &#125;</span><br><span class="line">    2.使用Iterator.remove方法会重置modCount.</span><br><span class="line">        ArrayList$Iterator#remove</span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ArrayList.this.remove(lastRet);</span><br><span class="line">                cursor &#x3D; lastRet;</span><br><span class="line">                lastRet &#x3D; -1;</span><br><span class="line">                &#x2F;&#x2F;重置modCount</span><br><span class="line">                expectedModCount &#x3D; modCount;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">4.容器类的某些隐藏迭代器的方法.</span><br><span class="line">  例如ArrayList.</span><br><span class="line">      toString();</span><br><span class="line">        hashCode();</span><br><span class="line">        equals();</span><br><span class="line">        containsAll();</span><br><span class="line">        removeAll();</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
<h3 id="线程的阻塞与中断"><a href="#线程的阻塞与中断" class="headerlink" title="线程的阻塞与中断"></a>线程的阻塞与中断</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.线程阻塞的几种情况.</span><br><span class="line">  1.I&#x2F;O的读操作.</span><br><span class="line">  2.尝试获取锁. Running ---&gt; Blocked</span><br><span class="line">  3.Thread.sleep       ---&gt; TIMED_WAITING</span><br><span class="line">  4.wait               ---&gt; waiting</span><br><span class="line">2.线程的中断.</span><br><span class="line">  Java线程的中断方式是主动式中断而不是抢占式中断.</span><br><span class="line">3.线程中断位丢失的几种情况</span><br><span class="line">  1.catch InterruptException</span><br><span class="line">    解决方式: </span><br><span class="line">        1.throw InterruptException</span><br><span class="line">        2.恢复中断位.</span><br><span class="line">          Thread.currentThread().interrupt().</span><br><span class="line">4.编写响应线程的中断函数.</span><br><span class="line">  主要逻辑: 在线程刚恢复运行时候,查看一下中断位,若被中断,直接抛出中断异常.</span><br><span class="line">  例如:</span><br><span class="line">   public void processInterruptibly() throws InterruptedException&#123;</span><br><span class="line">      LockSupport.park(thread);  &#x2F;&#x2F;doSomething block</span><br><span class="line">      if(Thread.interrupted())&#123;</span><br><span class="line">          throw new InterruptedException();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.ConcurrentLinkedQueue是在高并发情况下的无阻塞队列.</span><br><span class="line">2.ConcurrentLinkedQueue基于Michael和Scott算法实现.</span><br><span class="line">3.插入元素的代码</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            / / p is last node</span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">分析(非并发情况下):</span><br><span class="line">        p为当前链表的最后一个节点</span><br><span class="line">    奇数次插入(不修改tail):         </span><br><span class="line">            cas(p.next,<span class="keyword">null</span>,newNode);</span><br><span class="line">        偶数次插入(修改tail为最新):</span><br><span class="line">                cas(p.next,<span class="keyword">null</span>,newNode);</span><br><span class="line">                cas(tail,tail,newNode);</span><br><span class="line">                ps:<span class="number">2</span>次cas组合在一起就不是原子的了,但是有算法会弥补组合的非原子. </span><br><span class="line">            算法:<span class="number">1</span>.cas next 失败后,会迭代将p指向list的最后一个节点.</span><br><span class="line">                <span class="number">2</span>.cas tail成功,说明他是尾巴,失败说明有更新的尾巴.</span><br><span class="line">```    </span><br><span class="line">```java</span><br><span class="line"><span class="number">4</span>.弹出元素的代码</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        restartFromHead:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">                E item = p.item;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                    <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                    <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                        updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                    <span class="keyword">return</span> item;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    updateHead(h, p);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                    <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">1</span>.先是取出head的item.</span><br><span class="line">  若 cas(head,item,<span class="keyword">null</span>) 成功,则直接返回.</span><br><span class="line">  若 失败,则说明head已经变更了.</span><br><span class="line">    p=p.next;迭代.</span><br><span class="line">    cas(p,item,<span class="keyword">null</span>)成功,返回.</span><br><span class="line">    p.next为<span class="keyword">null</span>时候, cas(head,head,p); retur <span class="keyword">null</span>;</span><br><span class="line">    当p.next==p时候,成环了.</span><br></pre></td></tr></table></figure>
<h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.优先级队列.</span><br><span class="line">2.源码分析(基于最小堆的优先级队列).</span><br><span class="line">    PriortyQueue</span><br><span class="line">        --&gt;transient Object[]queue;</span><br><span class="line">        插入向上调整.</span><br><span class="line">        删除向下调整.</span><br><span class="line">3.添加元素的源代码.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最小堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123; <span class="comment">//k==0 是终止条件</span></span><br><span class="line">        <span class="comment">//第一个非叶子节点</span></span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//queue[son]=queue[parent]</span></span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>.获取最大优先级的代码(最小堆).</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        modCount++;</span><br><span class="line">                <span class="comment">//返回堆顶.</span></span><br><span class="line">                <span class="comment">//将最后一个元素移到堆顶,重新调整堆(逻辑上).</span></span><br><span class="line">        E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">        E x = (E) queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>, x);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">            siftDownUsingComparator(k, x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownComparable(k, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//k=0,x相当于堆顶</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">        <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf   第一个非叶子节点.</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">            Object c = queue[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = queue[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            queue[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[k] = key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">jdk <span class="number">1.6</span> 添加的.</span><br><span class="line"><span class="number">1</span>.阻塞队列对阻塞的操作提供了四种形式的解决方案.</span><br><span class="line">  <span class="number">1</span>.<span class="keyword">throws</span> an exception.</span><br><span class="line">    put</span><br><span class="line">  <span class="number">2</span>.<span class="function">returns a special <span class="title">value</span><span class="params">(<span class="keyword">null</span> or <span class="keyword">false</span>)</span>.</span></span><br><span class="line"><span class="function">    add/offer</span></span><br><span class="line"><span class="function">  3.block the current thread.</span></span><br><span class="line"><span class="function">    take</span></span><br><span class="line"><span class="function">  4.give a max time limit. <span class="keyword">if</span> time out ,give up.         </span></span><br><span class="line"><span class="function">    <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">2.经典的生产消费者模型.</span></span><br><span class="line"><span class="function">class Producer implements Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</span><br><span class="line">    Producer(BlockingQueue queue)&#123;</span><br><span class="line">        queue=queue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                queue.put(produce());</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException ex)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Object <span class="title">produce</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</span><br><span class="line">    Consumer(BlockingQueue q)&#123;queue=q&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;consume(queue.take());&#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException ex)&#123;... handle ...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(Object x)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>.BlockingQueue有</span><br><span class="line">    ArrayBlockingQueue</span><br><span class="line">    DelayQueue        PriorityQueue + ReentrantLock,Condition(控制安全)+element(Delayed). ps:Delayed ----&gt; 返回该对象的剩余生命.</span><br><span class="line">    LinkedBlockingQueue</span><br><span class="line">    PriorityBlockingQueue</span><br><span class="line"><span class="number">4</span>.ArrayBlockingQueue源码.</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ArrayBlockingQueue</span></span>&#123;</span><br><span class="line">      Object[]items;</span><br><span class="line">      ReentrantLock lock;</span><br><span class="line">      Condition notEmpty;</span><br><span class="line">      Condition notFull;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            enqueue(e);            <span class="comment">//notEmpty.single()</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> dequeue();    <span class="comment">//notFull.single()</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.同步队列(匹配)逻辑上没有任何容量,甚至没有一个容量,插入操作必须等待另一个线程的删除操作.</span><br><span class="line">2.插入元素到队列的线程被阻塞,直到另一个线程从队列中获取插入的元素.</span><br><span class="line">3.若队列为空,则获取元素操作亦会阻塞.</span><br><span class="line">4.但是实现还是由链表实现的,即链表还是有多个节点的.</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/19/java-concurrency-in-practice/Data-Request.png" alt="先放后取"><br>先取后放的poll方法必须传入超时时间,默认方法是先取直接取null<br><img src="/2019/12/19/java-concurrency-in-practice/Request-Data.png" alt="先取后放"><br>匹配时候(REQUEST&lt;-&gt;DATA)会导致各自的自旋结束,match属性是自旋的条件.tryMatch解除相匹配的线程.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">TransferStack#transfer</span><br><span class="line">E transfer(E e, boolean timed, long nanos) &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 模式:未满足的消费者 REQUEST,未满足的生产者 DATA,节点正在执行另一个未完成的数据或请求 FULFILLING.</span><br><span class="line">     * 基础算法,循环尝试下面三种操作中一个:</span><br><span class="line">     * 1. 如果头节点为空或者已经包含了相同模式,则尝试将该节点增加到栈中并且等待分配,如果被取消则返回null.</span><br><span class="line">     * 2. 如果头节点是一个模式不同的节点,尝试将一个fulfilling结点加入到栈中,匹配相应的等待节点,随后从栈中弹出,并且返回匹配的元素.</span><br><span class="line">          匹配和弹出可能无法进行,由于其它线程正在执行操作3.</span><br><span class="line">       3.如果栈顶已经有一个fulfilling结点，帮助他们完成匹配和弹出操纵，然后继续.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SNode s &#x3D; null; &#x2F;&#x2F; constructed&#x2F;reused as needed</span><br><span class="line">    int mode &#x3D; (e &#x3D;&#x3D; null) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        SNode h &#x3D; head;</span><br><span class="line">        &#x2F;&#x2F;same-mode 入队列</span><br><span class="line">        if (h &#x3D;&#x3D; null || h.mode &#x3D;&#x3D; mode) &#123;  &#x2F;&#x2F; empty or same-mode</span><br><span class="line">            if (timed &amp;&amp; nanos &lt;&#x3D; 0) &#123;      &#x2F;&#x2F; can&#39;t wait</span><br><span class="line">                if (h !&#x3D; null &amp;&amp; h.isCancelled())</span><br><span class="line">                    casHead(h, h.next);     &#x2F;&#x2F; pop cancelled node</span><br><span class="line">                else</span><br><span class="line">                    return null;</span><br><span class="line">            &#125; else if (casHead(h, s &#x3D; snode(s, e, h, mode))) &#123;&#x2F;&#x2F;前插</span><br><span class="line">                &#x2F;&#x2F;自旋第二次时候就阻塞了,当匹配时就不阻塞</span><br><span class="line">                SNode m &#x3D; awaitFulfill(s, timed, nanos);</span><br><span class="line">                if (m &#x3D;&#x3D; s) &#123;               &#x2F;&#x2F; wait was cancelled</span><br><span class="line">                    clean(s);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((h &#x3D; head) !&#x3D; null &amp;&amp; h.next &#x3D;&#x3D; s)</span><br><span class="line">                    casHead(h, s.next);     &#x2F;&#x2F; help s&#39;s fulfiller</span><br><span class="line">                return (E) ((mode &#x3D;&#x3D; REQUEST) ? m.item : s.item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (!isFulfilling(h.mode)) &#123; &#x2F;&#x2F;mode是否时FULFILL</span><br><span class="line">            if (h.isCancelled())            &#x2F;&#x2F; already cancelled</span><br><span class="line">                casHead(h, h.next);         &#x2F;&#x2F; pop and retry</span><br><span class="line">            else if (casHead(h, s&#x3D;snode(s, e, h, FULFILLING|mode))) &#123;&#x2F;&#x2F;前插 </span><br><span class="line">                for (;;) &#123; &#x2F;&#x2F; loop until matched or waiters disappear</span><br><span class="line">                    SNode m &#x3D; s.next;       &#x2F;&#x2F; m 是match</span><br><span class="line">                    if (m &#x3D;&#x3D; null) &#123;        &#x2F;&#x2F; all waiters are gone</span><br><span class="line">                        casHead(s, null);   &#x2F;&#x2F; pop fulfill node</span><br><span class="line">                        s &#x3D; null;           &#x2F;&#x2F; use new node next time</span><br><span class="line">                        break;              &#x2F;&#x2F; restart main loop</span><br><span class="line">                    &#125;</span><br><span class="line">                    SNode mn &#x3D; m.next;</span><br><span class="line">                    if (m.tryMatch(s)) &#123;    &#x2F;&#x2F;匹配成功</span><br><span class="line">                        casHead(s, mn);     &#x2F;&#x2F; 一次删除2个节点,REQUEST和DATA或DAT和REQUEST,更新头部</span><br><span class="line">                        return (E) ((mode &#x3D;&#x3D; REQUEST) ? m.item : s.item); &#x2F;&#x2F; s -&gt; m -&gt; mn , s或m有一个是REQUEST,有一个是DATA</span><br><span class="line">                    &#125; else                  &#x2F;&#x2F; lost match</span><br><span class="line">                        s.casNext(m, mn);   &#x2F;&#x2F; help unlink</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;                            &#x2F;&#x2F; help a fulfiller</span><br><span class="line">            SNode m &#x3D; h.next;               &#x2F;&#x2F; m is h&#39;s match</span><br><span class="line">            if (m &#x3D;&#x3D; null)                  &#x2F;&#x2F; waiter is gone</span><br><span class="line">                casHead(h, null);           &#x2F;&#x2F; pop fulfilling node</span><br><span class="line">            else &#123;</span><br><span class="line">                SNode mn &#x3D; m.next;</span><br><span class="line">                if (m.tryMatch(h))          &#x2F;&#x2F; help match</span><br><span class="line">                    casHead(h, mn);         &#x2F;&#x2F; pop both h and m</span><br><span class="line">                else                        &#x2F;&#x2F; lost match</span><br><span class="line">                    h.casNext(m, mn);       &#x2F;&#x2F; help unlink</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SynchronousQueue#put</span><br><span class="line"> public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    if (e &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    if (transferer.transfer(e, false, 0) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;transferer不匹配会阻塞直到匹配的</span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SynchronousQueue#poll</span><br><span class="line">public E poll() &#123;</span><br><span class="line">    return transferer.transfer(null, true, 0); &#x2F;&#x2F;transferer不匹配会阻塞直到匹配的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.jdk <span class="number">1.6</span>添加了Deque.</span><br><span class="line">  Deque是一个双端队列,实现在队列头和队列尾的高效插入和移除.</span><br><span class="line"><span class="number">2</span>.双端队列适用于工作密取(Work Stealing).</span><br><span class="line">  Work Stealing:</span><br><span class="line">    在工作密取设计中,每个消费者都有各自的双端队列.</span><br><span class="line">    如果一个消费者完成自己双端队列的全部工作,那么它可以从其它消费者双端队列末尾秘密的获取工作.</span><br><span class="line">    消费者从其它的双端队列上获取工作,是从队列尾获取工作,避免了和生产者线程竞争.</span><br><span class="line"><span class="number">3</span>.Deque的工作密取.</span><br><span class="line">  <span class="number">1</span>.使用LinkedBlockingDeque实现工作密取算法.</span><br><span class="line">  <span class="number">2</span>.JDK1<span class="number">.7</span>引入的Fork/Join框架基于工作密取算法(Queue是其自定义的).</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">scan</span><span class="params">(ForkJoinWorkerThread w, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// scanGuard是32位的整数，用于worker线程数组的索引</span></span><br><span class="line">            <span class="comment">// 第16位称为SG_UNIT，为1表示锁住</span></span><br><span class="line">            <span class="comment">// 0到15位是mask</span></span><br><span class="line">            <span class="keyword">int</span> g = scanGuard;</span><br><span class="line">            <span class="comment">// parallelism表示并发数，一般指CPU可以同时运行的线程数</span></span><br><span class="line">            <span class="comment">// 默认值是Runtime类的availableProcessors方法返回值，表示</span></span><br><span class="line">            <span class="comment">// 处理器的数量</span></span><br><span class="line">            <span class="comment">// a是活跃的Worker线程的数量，parallelism是大于0的，因此</span></span><br><span class="line">            <span class="comment">// 条件parallelism == 1 - a满足意味着parallelism为1而a为0</span></span><br><span class="line">            <span class="comment">// 而加上blockedCount为0（意味着没有线程因为join被阻塞），</span></span><br><span class="line">            <span class="comment">// 两个条件同时满足也就意味既没有任何线程在运行，那么也就</span></span><br><span class="line">            <span class="comment">// 意味着没有任务存在于worker线程，所以m=0也就是没法偷任务</span></span><br><span class="line">            <span class="comment">// SMASK=0xffff，g &amp; SMASK返回的值scanGuard的0到15位的数值</span></span><br><span class="line">            <span class="keyword">int</span> m = (parallelism == <span class="number">1</span> - a &amp;&amp; blockedCount == <span class="number">0</span>) ? <span class="number">0</span> : g &amp; SMASK;</span><br><span class="line">            ForkJoinWorkerThread[] ws = workers;</span><br><span class="line">            <span class="keyword">if</span> (ws == <span class="keyword">null</span> || ws.length &lt;= m) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = w.seed, k = r, j = -(m + m); j &lt;= m + m; ++j) &#123;</span><br><span class="line">                ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> b, i;</span><br><span class="line">                <span class="comment">// 从线程队列中随机获取一个worker线程</span></span><br><span class="line">                ForkJoinWorkerThread v = ws[k &amp; m];</span><br><span class="line">                <span class="comment">// 判断Worker线程是否存在以及该线程的任务队列是否有任务</span></span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; (b = v.queueBase) != v.queueTop &amp;&amp;</span><br><span class="line">                    (q = v.queue) != <span class="keyword">null</span> &amp;&amp; (i = (q.length - <span class="number">1</span>) &amp; b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 从队列中偷走一个任务</span></span><br><span class="line">                    <span class="keyword">long</span> u = (i &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = q[i]) != <span class="keyword">null</span> &amp;&amp; v.queueBase == b &amp;&amp;</span><br><span class="line">                        UNSAFE.compareAndSwapObject(q, u, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        <span class="keyword">int</span> d = (v.queueBase = b + <span class="number">1</span>) - v.queueTop;</span><br><span class="line">                        v.stealHint = w.poolIndex;</span><br><span class="line">                        <span class="comment">// d是偷走一个任务后任务队列的长度</span></span><br><span class="line">                        <span class="keyword">if</span> (d != <span class="number">0</span>)</span><br><span class="line">                            signalWork();</span><br><span class="line">                        w.execTask(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; w.seed = r ^ (r &lt;&lt; <span class="number">5</span>);</span><br><span class="line">                    <span class="comment">// false表示扫描到了任务</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;                     <span class="comment">// 异或移位，更新k</span></span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; k = r ^= r &lt;&lt; <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ++k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果扫描不到任务，但是scanGuard被更新了，说明有任务的变化</span></span><br><span class="line">            <span class="keyword">if</span> (scanGuard != g)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 从线程池的任务队列中取出任务来执行</span></span><br><span class="line">                ForkJoinTask&lt;?&gt; t; ForkJoinTask&lt;?&gt;[] q; <span class="keyword">int</span> b, i;</span><br><span class="line">                <span class="keyword">if</span> ((b = queueBase) != queueTop &amp;&amp;</span><br><span class="line">                    (q = submissionQueue) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (i = (q.length - <span class="number">1</span>) &amp; b) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> u = (i &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = q[i]) != <span class="keyword">null</span> &amp;&amp; queueBase == b &amp;&amp;</span><br><span class="line">                        UNSAFE.compareAndSwapObject(q, u, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                        queueBase = b + <span class="number">1</span>;</span><br><span class="line">                        w.execTask(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConcurrentMap"><a href="#ConcurrentMap" class="headerlink" title="ConcurrentMap"></a>ConcurrentMap</h3><h4 id="ConcurrentMap-1"><a href="#ConcurrentMap-1" class="headerlink" title="ConcurrentMap"></a>ConcurrentMap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.putIfAbsent ---&gt; </span><br><span class="line">    ConcurrentHashMap的实现确保了安全性.</span><br></pre></td></tr></table></figure>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.hashmap jdk <span class="number">1.7</span> 与  <span class="number">1.8</span>区别.</span><br><span class="line">  <span class="number">1</span>.hash冲突时节点的插入方式.</span><br><span class="line">    jdk <span class="number">1.7</span>hash冲突时候是头插法.</span><br><span class="line">    jdk <span class="number">1.8</span>hash冲突时候是尾插法.</span><br><span class="line">   jdk <span class="number">1.7</span>头插法的逆序且环形链表死循环问题.</span><br><span class="line">   =resize时候.</span><br><span class="line">    <span class="number">1</span>.遍历entry list 是从前往后遍历的.</span><br><span class="line">    <span class="number">2</span>.将entry插入到新的table中是头插法.</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">                <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">                    <span class="comment">//e为空时循环结束</span></span><br><span class="line">                    <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">                        Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                            e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                        <span class="comment">// 成环的代码主要是在这三行代码</span></span><br><span class="line">                        <span class="comment">// 首先插入是从头开始插入的</span></span><br><span class="line">                        e.next = newTable[i];</span><br><span class="line">                        newTable[i] = e;</span><br><span class="line">                        e = next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    并发情况下,由于newTable是局部变量,每个线程都不一样,所以对newTable无法实现同步操作.</span><br><span class="line">    当向newTable中插入元素时,oldTable中的链表顺序可能就会改变.</span><br><span class="line">    例如: thread one :   <span class="function">old <span class="title">table</span>   <span class="params">(a-&gt;b)</span>   ----&gt; new <span class="title">table</span> <span class="params">(b-&gt;a-&gt;<span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function">                        old table  b-&gt;a</span></span><br><span class="line"><span class="function">     此时 thread two已在<span class="title">while</span><span class="params">(<span class="keyword">null</span>!=e)</span>里  :   </span></span><br><span class="line"><span class="function">            e  is a</span></span><br><span class="line"><span class="function">            next is b</span></span><br><span class="line"><span class="function">            这时候 因为thread one a-&gt;b关系变成b-&gt;a</span></span><br><span class="line"><span class="function">            a.next is <span class="title">newTable</span><span class="params">(<span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function">            newTable is a</span></span><br><span class="line"><span class="function">            </span></span><br><span class="line"><span class="function">            e is b</span></span><br><span class="line"><span class="function">            next is a</span></span><br><span class="line"><span class="function">            b.next is a</span></span><br><span class="line"><span class="function">            newtable is b</span></span><br><span class="line"><span class="function">            </span></span><br><span class="line"><span class="function">            e is a</span></span><br><span class="line"><span class="function">            next is <span class="keyword">null</span></span></span><br><span class="line"><span class="function">            a.next is <span class="title">newTable</span><span class="params">(b)</span>   a-&gt;b 成环了    </span></span><br><span class="line"><span class="function">    2.数据结构不同.</span></span><br><span class="line"><span class="function">      JDK1.7使用的是数组+单链表的数据结构.</span></span><br><span class="line"><span class="function">      JDK1.8使用的是数组+链表/红黑树的数据结构.</span></span><br><span class="line"><span class="function">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD </span>= <span class="number">8</span>;(泊松分布)</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">       树化有间隔是为了解决频繁切换的问题.</span><br><span class="line">    <span class="number">3</span>.锁粒度的不同.</span><br><span class="line">       jdk1<span class="number">.7</span>的锁粒度是基于整个Segment(整个链).</span><br><span class="line">       jdk1<span class="number">.8</span>的锁粒度是基于HashEntry(链表的首节点).</span><br><span class="line"><span class="number">3</span>.jdk <span class="number">1.8</span> HashMap源码分析.</span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        先插入,后扩容.</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)        </span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/19/java-concurrency-in-practice/jdk7hashmap-problem.jpg" alt></p>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">1.ConcurrentHashMap的主要目的是保持并发的可读性(读不加锁).</span><br><span class="line">2.ConcurrentHashMap源码分析</span><br><span class="line">  loadFactor ---&gt; 0.75</span><br><span class="line">  threshold  ---&gt; 阈值</span><br><span class="line">  initialCapacity    ----&gt;初始大小</span><br><span class="line">  1.ConcurrentHashMap#get,读不加锁。</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</span><br><span class="line">        int h &#x3D; spread(key.hashCode());</span><br><span class="line">        if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (e &#x3D; tabAt(tab, (n - 1) &amp; h)) !&#x3D; null) &#123;</span><br><span class="line">            if ((eh &#x3D; e.hash) &#x3D;&#x3D; h) &#123;</span><br><span class="line">                if ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek)))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">           &#x2F;**</span><br><span class="line">            * hash 的 值 为负值表示正在扩容</span><br><span class="line">            * -1   MOVED</span><br><span class="line">            * -2   树节点</span><br><span class="line">            *&#x2F;</span><br><span class="line">            else if (eh &lt; 0)</span><br><span class="line">                return (p &#x3D; e.find(h, key)) !&#x3D; null ? p.val : null;</span><br><span class="line">            while ((e &#x3D; e.next) !&#x3D; null) &#123;</span><br><span class="line">                if (e.hash &#x3D;&#x3D; h &amp;&amp;</span><br><span class="line">                    ((ek &#x3D; e.key) &#x3D;&#x3D; key || (ek !&#x3D; null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    return e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">3.ConcurrentHashMap读不加锁的原因.</span><br><span class="line">    1.新节点的插入是尾插法.且Node的next访问标志有ACC-VOLATILE</span><br><span class="line">      当前位置后续的修改由于volatile的可见性是立刻可见的.</span><br><span class="line">      ConcurrentHashMap$Node</span><br><span class="line">        volatile V val;</span><br><span class="line">        volatile Node&lt;K,V&gt; next;      </span><br><span class="line">      ConcurrentHashMap</span><br><span class="line">        transient volatile Node&lt;K,V&gt;[] table;</span><br><span class="line">        对于volatile修饰数组,</span><br><span class="line">        可以用Unsafe.getObjectVolatile(table,address)来获取对象;</span><br><span class="line">        ConcurrentHashMap#tabAt方法用Unsafe的getObjectVolatile获取table数组的元素.</span><br><span class="line">4.ConcurrentHashMap#putVal</span><br><span class="line">    &#x2F;** Implementation for put and putIfAbsent *&#x2F;</span><br><span class="line">    final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</span><br><span class="line">        if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">        int hash &#x3D; spread(key.hashCode());</span><br><span class="line">        int binCount &#x3D; 0;</span><br><span class="line">        for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; int n, i, fh;</span><br><span class="line">            if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)</span><br><span class="line">                tab &#x3D; initTable();</span><br><span class="line">            else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                头节点为空,直接插入节点.</span><br><span class="line">                if (casTabAt(tab, i, null,</span><br><span class="line">                             new Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                    break;                   &#x2F;&#x2F; no lock when adding to empty bin</span><br><span class="line">            &#125;</span><br><span class="line">            正在扩容</span><br><span class="line">            else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)</span><br><span class="line">                tab &#x3D; helpTransfer(tab, f);</span><br><span class="line">            else &#123;</span><br><span class="line">                V oldVal &#x3D; null;</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 以头节点为锁,尾插法插入.</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                    if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;        &#x2F;&#x2F;表头没变</span><br><span class="line">                        if (fh &gt;&#x3D; 0) &#123;                &#x2F;&#x2F;list结构</span><br><span class="line">                            binCount &#x3D; 1;</span><br><span class="line">                            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                if (e.hash &#x3D;&#x3D; hash &amp;&amp;</span><br><span class="line">                                    ((ek &#x3D; e.key) &#x3D;&#x3D; key ||</span><br><span class="line">                                     (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal &#x3D; e.val;            &#x2F;&#x2F;保存返回值</span><br><span class="line">                                    if (!onlyIfAbsent)</span><br><span class="line">                                        e.val &#x3D; value;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred &#x3D; e;</span><br><span class="line">                                if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                                    pred.next &#x3D; new Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, null);</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (f instanceof TreeBin) &#123; &#x2F;&#x2F;树结构</span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            binCount &#x3D; 2;</span><br><span class="line">                            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) !&#x3D; null) &#123;</span><br><span class="line">                                oldVal &#x3D; p.val;</span><br><span class="line">                                if (!onlyIfAbsent)</span><br><span class="line">                                    p.val &#x3D; value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (binCount !&#x3D; 0) &#123;  &#x2F;&#x2F; 列表转红黑树</span><br><span class="line">                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)</span><br><span class="line">                        treeifyBin(tab, i);  </span><br><span class="line">                    if (oldVal !&#x3D; null)</span><br><span class="line">                        return oldVal;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        计数若数量&gt;capacity*load factor,会引发扩容.</span><br><span class="line">        addCount(1L, binCount);  </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.读是快照读,写会复制.</span><br><span class="line">2.CopyOnWirteArrayList#add</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 向队列尾部添加元素</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            <span class="comment">//写时复制</span></span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">3.CopyOnWriteArrayList#get</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 读不加锁</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 快照读</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (E) a[index];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h3><h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.AQS ---&gt; <span class="function">Abstract Queue <span class="title">Synchronizer</span><span class="params">(抽象队列同步器)</span>.</span></span><br><span class="line"><span class="function">  实现方式:</span></span><br><span class="line"><span class="function">    1.一个先进先出的双向队列<span class="params">(双端)</span>作为锁池.</span></span><br><span class="line"><span class="function">     排他锁逻辑:</span></span><br><span class="line"><span class="function">      新线程acqurie时,tryAccquire获取锁,获取不到锁<span class="params">(自旋<span class="number">2</span>次)</span>,后入队列,线程被park住.</span></span><br><span class="line"><span class="function">      当线程release时,会unpark head.next线程<span class="params">(ps:head是当前节点,head.next是阻塞的第一个节点)</span>.next线程被唤醒后会将next线程节点设置为新<span class="title">head</span><span class="params">(移除上一个节点)</span>.</span></span><br><span class="line"><span class="function">     共享锁逻辑:</span></span><br><span class="line"><span class="function">      线程acquireShared时,会tryAccquireShared,</span></span><br><span class="line"><span class="function">        tryAccquireShared  --&gt;  成功<span class="params">(&gt;<span class="number">0</span>)</span>,直接进入临界区.</span></span><br><span class="line"><span class="function">                           --&gt;  失败<span class="params">(&lt;<span class="number">0</span>)</span>,创建一个共享类型节点并放入FIFO等待队列,线程被park住.</span></span><br><span class="line"><span class="function">      线程releaseShared时,会unpark <span class="title">head</span><span class="params">(ps:共享锁是从head节点及后面多个节点阻塞的)</span>.</span></span><br><span class="line"><span class="function">          head线程唤醒后会调用<span class="keyword">int</span> r</span>=tryAcquireShared方法获取共享锁,然后调用setHeadAndPropagate(node,r)方法进行共享锁事件传播(ps:可能会一次唤醒多个线程).</span><br><span class="line">    <span class="number">2</span>.原子的Integer(status)表示抽象队列同步器的状态.</span><br><span class="line">    <span class="number">3</span>.AQS有Shared 模式 和  exclusive 模式.</span><br><span class="line"><span class="number">2</span>.AQS的Node节点.</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** 节点是共享节点下的标记 mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** 节点是排他节点下的标记 mode*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**线程已经被取消*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**线程需要被唤醒*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">/**线程在condition的wait队列中*/</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下一个共享线程必须无条件传播</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Status field, taking on only the values:</span></span><br><span class="line"><span class="comment">         *   SIGNAL:     The successor of this node is (or will soon be)</span></span><br><span class="line"><span class="comment">         *               blocked (via park), so the current node must</span></span><br><span class="line"><span class="comment">         *               unpark its successor when it releases or</span></span><br><span class="line"><span class="comment">         *               cancels. To avoid races, acquire methods must</span></span><br><span class="line"><span class="comment">         *               first indicate they need a signal,</span></span><br><span class="line"><span class="comment">         *               then retry the atomic acquire, and then,</span></span><br><span class="line"><span class="comment">         *               on failure, block.</span></span><br><span class="line"><span class="comment">         *   CANCELLED:  This node is cancelled due to timeout or interrupt.</span></span><br><span class="line"><span class="comment">         *               Nodes never leave this state. In particular,</span></span><br><span class="line"><span class="comment">         *               a thread with cancelled node never again blocks.</span></span><br><span class="line"><span class="comment">         *   CONDITION:  This node is currently on a condition queue.</span></span><br><span class="line"><span class="comment">         *               It will not be used as a sync queue node</span></span><br><span class="line"><span class="comment">         *               until transferred, at which time the status</span></span><br><span class="line"><span class="comment">         *               will be set to 0. (Use of this value here has</span></span><br><span class="line"><span class="comment">         *               nothing to do with the other uses of the</span></span><br><span class="line"><span class="comment">         *               field, but simplifies mechanics.)</span></span><br><span class="line"><span class="comment">         *   PROPAGATE:  A releaseShared should be propagated to other</span></span><br><span class="line"><span class="comment">         *               nodes. This is set (for head node only) in</span></span><br><span class="line"><span class="comment">         *               doReleaseShared to ensure propagation</span></span><br><span class="line"><span class="comment">         *               continues, even if other operations have</span></span><br><span class="line"><span class="comment">         *               since intervened.</span></span><br><span class="line"><span class="comment">         *   0:          None of the above</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The values are arranged numerically to simplify use.</span></span><br><span class="line"><span class="comment">         * Non-negative values mean that a node doesn't need to</span></span><br><span class="line"><span class="comment">         * signal. So, most code doesn't need to check for particular</span></span><br><span class="line"><span class="comment">         * values, just for sign.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The field is initialized to 0 for normal sync nodes, and</span></span><br><span class="line"><span class="comment">         * CONDITION for condition nodes.  It is modified using CAS</span></span><br><span class="line"><span class="comment">         * (or when possible, unconditional volatile writes).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 上一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 下一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点的value ----&gt;Thread</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * condition的waiting队列,指向当前节点的下一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node nextWaiter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns true if node is waiting in shared mode.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 返回上一个节点</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">            Node p = prev;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">            <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">            <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.AQS提供的模板方法之排他锁.</span><br><span class="line">  加锁</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * acquires int exclusive mode. </span></span><br><span class="line"><span class="comment">     * 这个方法不支持中断,有支持中断的,就不说了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!tryAcquire(arg))&#123;</span><br><span class="line">            <span class="comment">//获取锁失败</span></span><br><span class="line">            <span class="keyword">if</span>(acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&#123;</span><br><span class="line">                selfInterrupt();    ---&gt;Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 将当前线程加入锁池中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);        <span class="comment">//casTail(pred,node)失败了,这里会再次尝试</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.自旋(2次).</span></span><br><span class="line"><span class="comment">     *   如果前一个节点pre是head节点(表示队列上没真正节点),并且抢到锁(tryAcquire).</span></span><br><span class="line"><span class="comment">     * 2.阻塞 LockSupport.park() </span></span><br><span class="line"><span class="comment">     *   如果前一个节点pre的waitStatus是singal,则阻塞.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();    </span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; </span><br><span class="line">                    <span class="comment">//线程被唤醒后的逻辑</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有上一个节点的waitStatus是signal,才park当前线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   <span class="comment">//ws---&gt;0,PROPAGATE</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL); <span class="comment">//修改上一个节点位SIGNAL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  解锁:</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 解锁-&gt;</span></span><br><span class="line"><span class="comment">    *       Lock.unlock</span></span><br><span class="line"><span class="comment">    *         -&gt;AbstractQueuedSynchronizer#release</span></span><br><span class="line"><span class="comment">    *           -&gt;AbstractQueuedSynchronizer#tryRelease</span></span><br><span class="line"><span class="comment">    *           -&gt;unparkSuccessor(h)</span></span><br><span class="line"><span class="comment">    *             -&gt; LockSupport.unpark(next)</span></span><br><span class="line"><span class="comment">    *  next被唤醒时候,会将head设置为next,线程队列的head-&gt;next,getQueueLength()--.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;    <span class="comment">//尝试释放,头节点应该变更了.</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);        <span class="comment">//唤醒next节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 唤醒next节点线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.AQS提供的模板方法之共享锁.</span><br><span class="line">  加锁</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//tryAcquireShared是自定义方法</span></span><br><span class="line">        <span class="comment">//结果小于0表示获取失败</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)        </span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 头节点自旋去获取共享锁</span></span><br><span class="line"><span class="comment">     * 头节点获取共享锁后会传播共享锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向队列中添加共享节点</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predece /线程被唤醒</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    *  当线程被唤醒后</span></span><br><span class="line"><span class="comment">                    *  若r&gt;=0会传播事件.</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 其它节点阻塞.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  解共享锁:</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放共享锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 事件的传播</span></span><br><span class="line"><span class="comment">     * 若propagate&gt;0,doReleaseShared()继续释放节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">         *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                <span class="comment">//传播</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">5</span>.可中断的锁.</span><br><span class="line"> AbstractQueuedSynchronizer#acquireInterruptibly</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))        </span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 获取失败</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125; </span><br><span class="line">AbstractQueuedSynchronizer#doAcquireInterruptibly</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和acquire函数的区别在于 parkAndCheckInterrupte--&gt;ture 抛出中断异常(而acquire是设置中断标志)</span></span><br><span class="line"><span class="comment"> * parkAndCheckInterrupt的checkInterrupt是在唤醒时候检查中断位的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">6</span>.计时锁.</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">//获取不到锁,进入doAcquireNanos方法</span></span><br><span class="line">        <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">            doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  1.线程节点进队列.</span></span><br><span class="line"><span class="comment">     *  2.若超时直接返回false.</span></span><br><span class="line"><span class="comment">     *  其它的逻辑和acquireQuied相同.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">                <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">7</span>.一个简单的例子</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Our internal helper class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Reports whether in locked state</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">        Thread current=Thread.currentThread();</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">          setExclusiveOwnerThread(current);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(getExclusiveOwnerThread()==current)&#123;</span><br><span class="line">            setState(state+acquires);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">        <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(--state);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Provides a Condition</span></span><br><span class="line">      <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// Deserializes properly</span></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.ReentrantLock(可重入锁).</span><br><span class="line"><span class="number">2</span>.非公平锁.</span><br><span class="line">  额外操作:线程刚进来时候不会判断锁池队列,而会直接去尝试一次获取锁,获取失败还是会加入锁池.获取成功直接获取锁.</span><br><span class="line">  ReentrantLocal#lock</span><br><span class="line">        ---&gt;NonfairSync#lock     </span><br><span class="line">        ---&gt;AbstractQueuedSynchronizer#acquire(arg)</span><br><span class="line">        ---&gt;NonfairSync#tryAcquire</span><br><span class="line">        ---&gt;ReentrantLock#nonfairTryAcquire(acquires)</span><br><span class="line">  ReentrantLock#lock</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//先是直接获取</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  ReentrantLock#nonfairTryAcquire</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">//直接抢占</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">3</span>.公平锁.</span><br><span class="line">  公平锁: 先来先服务.</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 锁池有元素的话,就不会获取尝试获取锁</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.Condition队列对应于Object Monitor Mutex-lock.wait队列.</span><br><span class="line"><span class="number">2</span>.Condition的经典例子(生产者-消费者模型).</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">final</span> Condition notFull=lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condtion  notEmpty=lock.newConfition();</span><br><span class="line">    <span class="keyword">final</span> Object[]items=<span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr,takeptr,count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(isFull())</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[putptr]=x;</span><br><span class="line">            putptr=++putptr%<span class="number">100</span>;</span><br><span class="line">            count++;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Object result=<span class="keyword">null</span>;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(isEmpty())</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            result=items[takeptr];</span><br><span class="line">            takeptr=++takeptr%<span class="number">100</span>;</span><br><span class="line">            count--;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> count==<span class="number">100</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> count==<span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>.源码分析</span><br><span class="line">AbstractQueuedSynchronizer$ConditionObject</span><br><span class="line">        <span class="comment">/** First node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">        <span class="comment">/** Last node of condition queue. */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">AbstractQueuedSynchronizer$ConditionObject#await</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter();</span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line">AbstractQueuedSynchronizer$ConditionObject#signal</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * condition list ----&gt; 总是signal first</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">AbstractQueuedSynchronizer$ConditionObject#doSignal</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 从condition队列中移除节点,并加入AQS队列(AQS锁池)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;<span class="comment">//help first GC</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">AbstractQueuedSynchronizer$transferForSignal</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 将节点加入aqs锁池</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">         * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node p = enq(node);</span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="闭锁"><a href="#闭锁" class="headerlink" title="闭锁"></a>闭锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.闭锁相当于一扇门,在闭锁到达结束状态之前,这扇门一直是关闭的,并且没有任何线程能通过.</span><br><span class="line"><span class="number">2</span>.CountDownLatch.</span><br><span class="line">  CountDownLatch允许一个或多个线程等待,直到其它线程的一组操作完成.</span><br><span class="line"><span class="number">3</span>.使用场景.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        CountDownLatch startSignal=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        CountDownLatch doneSignal =<span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                startSignal.await();</span><br><span class="line">                doWork();</span><br><span class="line">                doneSignal.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        doSomethingElse();</span><br><span class="line">        startSignal.countDown();</span><br><span class="line">        doSomthingElse();</span><br><span class="line">        doneSignal.await();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>.CountDownLatch源码分析.</span><br><span class="line">CountDownLatch$Sync</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * state为0,线程获取共享锁成功,不为0线程获取共享锁失败.</span></span><br><span class="line"><span class="comment">        * countdown到0时候才能获取锁.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">CountDownLatch$countDown</span><br><span class="line">ps:基于AQS的源码,releaseShared会调用tryReleaseShared方法,将state-<span class="number">1</span>,</span><br><span class="line">   tryReleaseShared方法返回<span class="keyword">true</span>,会unpark第一个线程.</span><br><span class="line">   随后根据state值传播共享锁释放事件.</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">CountDownLatch$await</span><br><span class="line">ps:基于AQS源码,acquireSharedInterruptibly会调用tryAcquireShared方法.</span><br><span class="line">   若state为<span class="number">0</span>,则获取共享锁,否则进队列阻塞.</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.信号量可以起到流量控制的作用.</span><br><span class="line">  信号量维持着一个集合的permit.</span><br><span class="line">  acquire将会阻塞直到一个permit可获得.</span><br><span class="line">  release将会释放一个blocking acquirer.</span><br><span class="line"><span class="number">2</span>.例子</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  Semaphore available=<span class="keyword">new</span> Semaphore(MAX_AVAILABLE,<span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        available.acquire();</span><br><span class="line">        <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用完放回去</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(markAsUnused(x))&#123;</span><br><span class="line">          available.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Object[]items=......;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span>[]used=<span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_AVAILAblE;++i)&#123;</span><br><span class="line">          <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">              used[i]=<span class="keyword">true</span>;</span><br><span class="line">              <span class="keyword">return</span> items[i];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_AVAILABLE;++i)&#123;</span><br><span class="line">           <span class="keyword">if</span>(item == items[i])&#123;</span><br><span class="line">               <span class="keyword">if</span>(used[i])&#123;</span><br><span class="line">                  used[i]=<span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>.源码分析.</span><br><span class="line">Semaphore$Sync</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line">        <span class="comment">//permit ==&gt; 许可</span></span><br><span class="line">        Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">            setState(permits);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * permit 还有 获取成功</span></span><br><span class="line"><span class="comment">         * 否则则park住(AQSacquireSHared逻辑)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 修改state</span></span><br><span class="line"><span class="comment">         * AQS会unpark head,并根据state的值进行传播.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">                <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//放掉所有的许可</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.栅栏与闭锁区别:</span><br><span class="line">  <span class="number">1</span>.栅栏是所有线程必须到达栅栏位置,才能继续执行.</span><br><span class="line">  <span class="number">2</span>.栅栏是用于等待线程,闭锁是用于等待事件(countDown).</span><br><span class="line"><span class="number">2</span>.举个例子.</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CellularAutomata</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Board mainBoard;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> Workder[]workers;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">CellularAutomata</span><span class="params">(Board mainBoard)</span></span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.mainBoard=mainBoard;</span><br><span class="line">         <span class="keyword">int</span> count = Runtime.getRuntime().availableProcessors();</span><br><span class="line">         <span class="keyword">this</span>.barrier= <span class="keyword">new</span> CyclicBarrier(</span><br><span class="line">            count,</span><br><span class="line">            ()-&gt;&#123;</span><br><span class="line">                mainBoard.commitNewValues();</span><br><span class="line">            &#125;</span><br><span class="line">         );</span><br><span class="line">         <span class="keyword">this</span>.workers=<span class="keyword">new</span> Worker[count];</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">             workers[i]=<span class="keyword">new</span> Worker(mainBoard.getSubBoard(count,i));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;workers.length;i++)&#123;</span><br><span class="line">             <span class="keyword">new</span> Thread(workers[i]).start();</span><br><span class="line">         &#125;</span><br><span class="line">         mainBoard.waitForConvergence();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">final</span> Board board;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(Board board)</span></span>&#123;<span class="keyword">this</span>.board=board;&#125;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">while</span>(!board.hasConverged())&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;board.getMaxX();x++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;board.getMaxY();y++)&#123;</span><br><span class="line">                        board.setNewValue(x,y,computeValue(x,y));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(InterruptedException ex)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(BrokenBarrierException ex)&#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="number">3</span>.源码分析.</span><br><span class="line">CyclicBarrier#dowait.</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">               TimeoutException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = --count;</span><br><span class="line">            <span class="comment">//index==0 ===&gt; tripped 旅游结束了</span></span><br><span class="line">            <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">                <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                    <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                        command.run();</span><br><span class="line">                    ranAction = <span class="keyword">true</span>;</span><br><span class="line">                    nextGeneration();</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//自旋直到tripped</span></span><br><span class="line">            <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!timed)</span><br><span class="line">                        <span class="comment">//trip ----&gt; lock.newCondition  </span></span><br><span class="line">                        trip.await();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                        nanos = trip.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                        breakBarrier();</span><br><span class="line">                        <span class="keyword">throw</span> ie;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                        <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                        <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g.broken)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (g != generation)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">CyclicBarrier#nextGeneration</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// signal completion of last generation</span></span><br><span class="line">        trip.signalAll();</span><br><span class="line">        <span class="comment">// set up next generation</span></span><br><span class="line">        count = parties;</span><br><span class="line">        generation = <span class="keyword">new</span> Generation();</span><br><span class="line">    &#125;    </span><br><span class="line">CyclicBarrier$Generation</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义缓存"><a href="#自定义缓存" class="headerlink" title="自定义缓存"></a>自定义缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memoizer</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Computable</span>&lt;<span class="title">A</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap &lt;A,Future&lt;V&gt;&gt; cache=<span class="keyword">new</span> ConcurrentHashMap&lt;A,Future&lt;V&gt;&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Computable&lt;A,V&gt;c;</span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="title">Memoizer</span><span class="params">(Computable&lt;A,V&gt;c)</span></span>&#123;<span class="keyword">this</span>.c=c;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(<span class="keyword">final</span> A arg)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">          Future f=cache.get(arg);</span><br><span class="line">          <span class="keyword">if</span>(f==<span class="keyword">null</span>)&#123;</span><br><span class="line">             Callable&lt;V&gt; eval=<span class="keyword">new</span> Callable&lt;V&gt;()&#123;</span><br><span class="line">                 <span class="function"><span class="keyword">public</span> V  <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> c.compute(arg);  </span><br><span class="line">                 &#125;      </span><br><span class="line">             &#125;;</span><br><span class="line">           FutureTask&lt;V&gt;ft=<span class="keyword">new</span> FutureTask&lt;V&gt;(eval);</span><br><span class="line">           f=cache.putIfAbsent(arg,ft);<span class="comment">//cas(keyAddress,null,key)</span></span><br><span class="line">           <span class="keyword">if</span>(f==<span class="keyword">null</span>)&#123;f=ft;ft.run();&#125; <span class="comment">//只会第一个线程会run</span></span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> f.get(); <span class="comment">//若未compulated,则阻塞</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(CancellationException e)&#123;</span><br><span class="line">           cache.remove(arg,f);<span class="comment">//解决缓存污染</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">           <span class="keyword">throw</span> launderThrowable(e.getCause());  </span><br><span class="line">         &#125;</span><br><span class="line">       &#125;    </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h3><h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.FutureTask可以查询task是否完成,取消task,阻塞直到task的结果.</span><br><span class="line"><span class="number">2</span>.future的state的几种状态.</span><br><span class="line">  NEW,COMPLETIND,NORMAL,EXCEPTIONAL,CANCELED,INTERRUPTING,INTERRUPTED</span><br><span class="line">  可能出现的几种状态变化.</span><br><span class="line">  NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line">  NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line">  NEW -&gt; CANCELED</span><br><span class="line">  NEW -&gt; INTERRUPTING-&gt;INTERRUPTED</span><br><span class="line"><span class="number">3</span>.FutureTask的WaitNode.</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 用一个list去记录Waiting Threads.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    FutureTask$WaitNode</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        <span class="keyword">volatile</span> WaitNode next;</span><br><span class="line">        WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FutureTask#waiters</span><br><span class="line">    <span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"><span class="number">4</span>.FutureTask异步获取任务执行结果的过程.</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">            s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        <span class="keyword">return</span> report(s);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 等待完成方法</span></span><br><span class="line"><span class="comment">    * 自旋</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">           <span class="comment">//任务已经完成(完成或抛出异常) 正常退出</span></span><br><span class="line">            <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                    q.thread = <span class="keyword">null</span>; <span class="comment">//help wait node gc</span></span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//任务正在执行,让出cpu</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">                q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">           <span class="comment">//头插法</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">                queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                     q.next = waiters, q);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;    </span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 计时锁</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="comment">//超时的话</span></span><br><span class="line">                    removeWaiter(q);</span><br><span class="line">                    <span class="keyword">return</span> state;</span><br><span class="line">                &#125;</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回操作的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        Object x = outcome;</span><br><span class="line">        <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">            <span class="keyword">return</span> (V)x;</span><br><span class="line">       <span class="comment">//任务取消</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">        <span class="comment">//超时或其它异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">    &#125;      </span><br><span class="line"><span class="number">5</span>.FutureTask执行任务过程.</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">            !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                         <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Callable&lt;V&gt; c = callable;</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">                V result;</span><br><span class="line">                <span class="keyword">boolean</span> ran;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result = c.call();</span><br><span class="line">                    ran = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    result = <span class="keyword">null</span>;</span><br><span class="line">                    ran = <span class="keyword">false</span>;</span><br><span class="line">                    setException(ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ran)</span><br><span class="line">                    set(result);<span class="comment">//更新state  cas(this,stateoffset,NEW,COMPLETING)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">            <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">            runner = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">            <span class="comment">// leaked interrupts</span></span><br><span class="line">            <span class="keyword">int</span> s = state;</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">                handlePossibleCancellationInterrupt(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.4</span>个静态方法用于创建异步操作.</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span></span><br><span class="line"><span class="function">2.计算完成时的回调方法.</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> Throwable&gt; action, Executor executor)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable,? extends T&gt; fn)</span>  </span></span><br><span class="line"><span class="function">3.thenApply 有返回值</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span></span><br><span class="line"><span class="function">4.handle  有返回值加可能出现的异常</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> &lt;U&gt; CompletionStage&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn,Executor executor)</span></span>;</span><br><span class="line"><span class="number">5</span>.thenAccept 无返回值消费</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span></span>;</span><br><span class="line"><span class="number">6</span>.thenRun</span><br><span class="line"><span class="number">7</span>.thenCombine 合并任务</span><br><span class="line">    <span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn,Executor executor)</span></span>;</span><br><span class="line">  eg:</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCombine</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;String&gt; future1 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        CompletableFuture&lt;String&gt; result = future1.thenCombine(future2, <span class="keyword">new</span> BiFunction&lt;String, String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String t, String u)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> t+<span class="string">" "</span>+u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line"><span class="number">8</span>.thenAcceptBoth  同thenCombine,不会生产结果</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action,     Executor executor)</span></span>;</span><br><span class="line"><span class="number">10</span>.applyToEither  取返回快的结果 有点像invokeAny</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn,Executor executor)</span></span>;</span><br><span class="line"><span class="number">11</span>.acceptEither   取返回快的结果,不产生结果</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span></span>;</span><br><span class="line"><span class="number">12</span>.runAfterEither  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br><span class="line"><span class="number">13</span>.runAfterBoth  invokeAll</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br><span class="line"><span class="number">14</span>.thenCompose 流水线</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span> </span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor)</span> </span>;</span><br><span class="line">    <span class="comment">//例子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thenCompose</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CompletableFuture&lt;Integer&gt; f = CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> t = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">"t1="</span>+t);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).thenCompose(<span class="keyword">new</span> Function&lt;Integer, CompletionStage&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> CompletionStage&lt;Integer&gt; <span class="title">apply</span><span class="params">(Integer t)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.supplyAsync(<span class="keyword">new</span> Supplier&lt;Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">int</span> nT = t *<span class="number">2</span>;</span><br><span class="line">                        System.out.println(<span class="string">"t2="</span>+nT);</span><br><span class="line">                        <span class="keyword">return</span> nT;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"thenCompose result : "</span>+f.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.Executor是灵活且强大的异步执行框架.支持不同类型的任务执行策略.</span><br><span class="line"><span class="number">2</span>.Executor基于生产者-消费者模式,提交任务的线程相当于生产者,执行任务的线程相当于消费者.</span><br><span class="line"><span class="number">3</span>.Executor源码.</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>.线程池与工作队列.</span><br><span class="line">  线程池与工作队列(Work Queue)密切相关的,在工作者队列中保存了所有等待执行的任务.</span><br><span class="line">  工作者线程(Work Thread)的任务很简单,从工作者队列中获取一个任务,执行任务,返回线程池并等待下一个任务.</span><br><span class="line"><span class="number">5</span>.线程池(一个线程执行多个任务的好处):</span><br><span class="line">  <span class="number">1</span>.线程的创建和销毁过程中产生巨大的开销.</span><br><span class="line">  <span class="number">2</span>.充分利用CPU资源,使处理器处于忙碌状态.</span><br><span class="line">  <span class="number">3</span>.线程数量固定,避免太多的线程相互竞争资源而使应用程序内存耗尽(stack oom).</span><br><span class="line">  <span class="number">4</span>.协调多个线程,实现主次线程隔离(隔离线程环境),定时执行,周期执行任务.</span><br></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.线程池的七个参数.</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span>;</span><br><span class="line">    corePoolSize    ----&gt;     核心池大小</span><br><span class="line">    maximumPoolSize ----&gt;     最大池大小</span><br><span class="line">    keepAliveTime   ----&gt;     存活时间</span><br><span class="line">    unit            ----&gt;     存活时间单位</span><br><span class="line">    workQueue       ----&gt;     工作任务队列</span><br><span class="line">    threadFactory   ----&gt;     线程工厂</span><br><span class="line">    rejectedExecutionHandler-&gt;拒绝策略</span><br><span class="line"><span class="number">2</span>.Java类库提供的线程池.</span><br><span class="line">   java.util.concurrent.Executors</span><br><span class="line">   SingleThreadExecutor  ---&gt;      <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   CachedThreadExecutor  ---&gt;   <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   FixedThreadExecutor   ---&gt;   <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   ScheduledExecutorService -&gt;  <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line"><span class="number">3</span>.饱和策略.</span><br><span class="line">    <span class="number">1</span>.AbortPolicy   默认的的饱和策略,该策略会抛出unchecked RejectedExecutionException.</span><br><span class="line">    <span class="number">2</span>.DiscardPolicy  该策略会抛弃拒绝的任务.</span><br><span class="line">    <span class="number">3</span>.DiscardOldestPolicy 这种策略不会抛弃拒绝的任务,而是会抛弃队列中最老的任务(head).</span><br><span class="line">    <span class="number">4</span>.CallerRunsPolicy    让调用者的线程去执行被拒绝的任务.</span><br><span class="line"><span class="number">4</span>.线程池的各种适应场景.</span><br><span class="line">  <span class="number">1</span>.高并发,任务执行时间短.</span><br><span class="line">    FixedThreadExecutor,池大小设置为CPU核数+<span class="number">1</span>,大小为CPU核数是因为任务时间短，线程上下文切换少,所以不需要过多的线程,导致线程切换. <span class="number">1</span>是为了某个线程挂掉.</span><br><span class="line">  <span class="number">2</span>.I/O密集型的长任务(线程尽量多).</span><br><span class="line">    CachedThreadExecutor,因为I/O密集型会阻塞导致切换,如果是设置CPU核数的poolSize,有可能cpu核上的线程都在I/O操作阻塞.</span><br><span class="line">  <span class="number">3</span>.计算密集型的长任务.</span><br><span class="line">    FixedThreadExecutor. 池大小设置为CPU+<span class="number">1</span>,对于计算密集型任务因该尽量避免上下文切换.</span><br><span class="line"><span class="number">5</span>.线程池的生命周期.</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *等待正在执行的任务执行结束,不会执行新提交的任务.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停正在执行的任务,返回未执行的任务(不包含正在执行的任务)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if all tasks have completed following shut down.</span></span><br><span class="line"><span class="comment">     * Note that &#123;<span class="doctag">@code</span> isTerminated&#125; is never &#123;<span class="doctag">@code</span> true&#125; unless</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> shutdown&#125; or &#123;<span class="doctag">@code</span> shutdownNow&#125; was called first.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if all tasks have completed following shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *等待所有任务在timeout内完成</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有提交任务的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取一个提交任务的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="number">1</span>.如果在线程池关闭后提交任务,那么任务会被拒绝.用拒绝策略处理那些被拒绝的任务.</span><br><span class="line">  <span class="number">2</span>.支持关闭操作的Web服务器.</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 通过关闭线程池关闭服务器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec=...</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">            ServerSocket socket=<span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">            <span class="keyword">while</span>(!exec.isShutdown())&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">final</span> Socket conn=socket.accept();</span><br><span class="line">                    exec.execute(()-&gt;&#123;handleRequest(conn);&#125;);</span><br><span class="line">                &#125;<span class="keyword">catch</span>(RejectedException e)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(!exec.isShutdown())&#123;</span><br><span class="line">                        log(<span class="string">"task submission rejected"</span>;e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>&#123;exec.shutdown();&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span></span>&#123;</span><br><span class="line">            Request rq=readRequest(connection);</span><br><span class="line">            <span class="comment">//关闭请求</span></span><br><span class="line">            <span class="keyword">if</span>(isShutdownRequest(rq))&#123;</span><br><span class="line">                stop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dispatchRequest(rq);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">6</span>.携带结果的任务Callable与Future</span><br><span class="line">ThreadPoolExecutor#submit</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">FutureTask#run</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">FutureTask#set(result)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">FutureTask#get</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line">FutureTask#report  根据结果反馈</span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">7</span>.线程池大小分析.</span><br><span class="line">  <span class="number">1</span>.根据硬件分配(Runtime.availableProcessors).</span><br><span class="line">  <span class="number">2</span>.根据任务是否是I/O密集型,I/O任务经常阻塞,所有线程越多越好.</span><br><span class="line">  <span class="number">3</span>.根据资源数量配置.如内存,文件句柄,套接字句柄,数据库连接池.</span><br><span class="line"><span class="number">8</span>.线程池源码分析.</span><br><span class="line"> ThreadPoolExecutor$Worker extends AbstractQueuedSynchronizer implements Runnable</span><br><span class="line">   <span class="keyword">final</span>  Thread thread;</span><br><span class="line">   Runnable firstTask;</span><br><span class="line">   <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line">   <span class="comment">//state的特殊封装</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"> Worker#Worker</span><br><span class="line">     <span class="comment">//一个Worker对应一个线程</span></span><br><span class="line">     Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">Worker#runWorker</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock(); <span class="comment">//worker 属于worker数组,可能被并发访问</span></span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Worker#getTask</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">                decrementWorkerCount();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">            <span class="comment">//几种错误情况 1.worker数量大于最大池 2. 超时 3.工作队列为空</span></span><br><span class="line">            <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">                &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">ThreadPoolExecutor#execute</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">         * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">         * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">         * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">         * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">         * 如果线程数量小于核心池大小,那么会新创建一个Worker(addWorker).</span></span><br><span class="line"><span class="comment">         * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">         * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">         * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">         * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">         * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">         * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">         *如果能将任务加入到workQueue中,就将任务加入到worker队列中.</span></span><br><span class="line"><span class="comment">         * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">         * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">         * and so reject the task.</span></span><br><span class="line"><span class="comment">         * 上面都失败了,若poolSize&lt;max poolSize, 新建一个临时的Worker(会销毁)</span></span><br><span class="line"><span class="comment">         * 若poolSize&gt;=max poolSize,则采取饱和策略处理任务.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125; </span><br><span class="line"><span class="number">9</span>.场景应用 </span><br><span class="line">搬箱子之类的谜题抽象类</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Puzzle</span>&lt;<span class="title">P</span>,<span class="title">M</span>&gt;</span>&#123; <span class="comment">//p --&gt;Position   M --&gt; Move</span></span><br><span class="line">      <span class="function">P <span class="title">initialPosition</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">isGoal</span><span class="params">(P position)</span></span>;</span><br><span class="line">      <span class="function">Set&lt;M&gt; <span class="title">legalMoves</span><span class="params">(P position)</span></span>;</span><br><span class="line">      <span class="function">P <span class="title">move</span><span class="params">(P postion,M move)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">用于谜题解决框架的链表节点</span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">P</span>,<span class="title">M</span>&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">final</span> P post;</span><br><span class="line">      <span class="keyword">final</span> M move;</span><br><span class="line">      <span class="keyword">final</span> Node&lt;P,M&gt;prev; <span class="comment">//fatcher</span></span><br><span class="line">      Node(P post,M move,Node&lt;P,M&gt;prev)&#123;</span><br><span class="line">          <span class="keyword">this</span>.post=post;</span><br><span class="line">          <span class="keyword">this</span>.move=move;</span><br><span class="line">          <span class="keyword">this</span>.prev=prev;</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;M&gt;asMoveList()&#123;</span><br><span class="line">          List&lt;M&gt;solution=<span class="keyword">new</span> LinkedList&lt;M&gt;();</span><br><span class="line">          Node p=<span class="keyword">this</span>;</span><br><span class="line">          <span class="keyword">while</span>(p.move!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              solution.add(<span class="number">0</span>,p.move);</span><br><span class="line">              p=p.prev;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> solution;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">串行的谜题解答器</span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">SequentialPuzzleSolver</span>&lt;<span class="title">P</span>,<span class="title">M</span>&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Puzzle&lt;P,M&gt; puzzle;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;P&gt; seen=<span class="keyword">new</span> HashSet&lt;P&gt;();</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="title">SequentialPuzzleSolver</span><span class="params">(Puzzle&lt;P,M&gt;puzzle)</span></span>&#123;</span><br><span class="line">           <span class="keyword">this</span>.puzzle=puzzle;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> List&lt;M&gt; <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">           P pos=puzzle.initialPosition();</span><br><span class="line">           <span class="keyword">return</span> search(<span class="keyword">new</span> Node&lt;P,M&gt;(post,<span class="keyword">null</span>,<span class="keyword">null</span>));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> List&lt;M&gt; <span class="title">search</span><span class="params">(Node&lt;P,M&gt;node)</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(!seen.contains(node.pos))&#123;</span><br><span class="line">              seen.add(node.pos);</span><br><span class="line">              <span class="keyword">if</span>(puzzle.isGoal(node.pos))&#123;</span><br><span class="line">                  <span class="comment">//最终出口</span></span><br><span class="line">                  <span class="keyword">return</span> node.asMoveList();</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">for</span>(M move:puzzle.legalMoves(node.pose))&#123;</span><br><span class="line">                  P pos=puzzle.move(node.pos,move);</span><br><span class="line">                  Node&lt;P,M&gt;child=<span class="keyword">new</span> Node&lt;P,M&gt;(pos,move,node);</span><br><span class="line">                  List&lt;M&gt;result=search(child);</span><br><span class="line">                  <span class="keyword">if</span>(result!=<span class="keyword">null</span>)</span><br><span class="line">                     <span class="keyword">return</span> result;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">并行的谜题解答器</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueLatch</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line">    <span class="keyword">private</span> T value=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch done=<span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (done.getCount()==<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isSet())&#123;</span><br><span class="line">            value=newValue;</span><br><span class="line">            done.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        done.await();</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentPuzzleSolver</span>&lt;<span class="title">P</span>,<span class="title">M</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Puzzle&lt;P,M&gt; puzzle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;P,Boolean&gt;seen;</span><br><span class="line">    <span class="keyword">final</span> ValueLatch&lt;Node&lt;P,M&gt;&gt;solution=nwe ValueLatch&lt;Node&lt;P,M&gt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;M&gt; <span class="title">solve</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            P p=puzzle.initailPosition();</span><br><span class="line">            exec.execute(newTask(p,<span class="keyword">null</span>,<span class="keyword">null</span>));</span><br><span class="line">            Node&lt;P,M&gt;solnNode=solution.getValue();</span><br><span class="line">            <span class="keyword">return</span> (solnNode==<span class="keyword">null</span>)?<span class="keyword">null</span>:solnNode.asMoveList();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            exec.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Runnable <span class="title">newTask</span><span class="params">(P p,M m,Node&lt;P,M&gt; n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SolverTask(p,m,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger taskCount=<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SolverTask</span> <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">P</span>,<span class="title">M</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            taskCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span>(solution.isSet()||seen.putIfAbsent(pos,<span class="keyword">true</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(puzzle.isGoal(pos))</span><br><span class="line">               solution.setValue(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">for</span>(M m: puzzle.legalMoves(pos))&#123;</span><br><span class="line">                   exec.execute(newTask(puzzle.move(pos,m),m,<span class="keyword">this</span>));</span><br><span class="line">               &#125;</span><br><span class="line">            <span class="keyword">int</span> res=taskCount.decrementAndGet();</span><br><span class="line">            <span class="keyword">if</span>(res==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//没有解</span></span><br><span class="line">                solution.setValue(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor可以用多线程的方式执行延迟任务与周期任务.</span><br><span class="line">DelayedWorkQueue + ScheduledFutureTask(装饰task)</span><br><span class="line">ScheduledThreadPoolExecutor$DelayedWorkQueue</span><br><span class="line"> &#x2F;&#x2F;堆结构</span><br><span class="line"> private RunnableScheduledFuture&lt;?&gt;[] queue &#x3D; new ScheduledFutureTask&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class="line">DelayedWorkQueue#poll</span><br><span class="line">    public RunnableScheduledFuture&lt;?&gt; poll() &#123;</span><br><span class="line">        final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first &#x3D; queue[0];</span><br><span class="line">            &#x2F;&#x2F;看delay是否到</span><br><span class="line">            if (first &#x3D;&#x3D; null || first.getDelay(NANOSECONDS) &gt; 0)</span><br><span class="line">                return null;</span><br><span class="line">            else</span><br><span class="line">                return finishPoll(first);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">ScheduleFutureTask#run</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        boolean periodic &#x3D; isPeriodic();</span><br><span class="line">        if (!canRunInCurrentRunState(periodic))</span><br><span class="line">            cancel(false);</span><br><span class="line">        else if (!periodic)</span><br><span class="line">            ScheduledFutureTask.super.run();</span><br><span class="line">        else if (ScheduledFutureTask.super.runAndReset()) &#123;</span><br><span class="line">            &#x2F;&#x2F;设置延迟时间</span><br><span class="line">            setNextRunTime();</span><br><span class="line">            &#x2F;&#x2F;重新入队列</span><br><span class="line">            reExecutePeriodic(outerTask);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1.ForkJoinPool适合于分治任务的处理,Jdk1.8的CompeleteFuture,并发流都是基于ForkJoinPool实现的.</span><br><span class="line">2.求和例子.</span><br><span class="line">  public class SumTask extends RecursiveTask&lt;Integer&gt;&#123;</span><br><span class="line">      private Integer start&#x3D;0;</span><br><span class="line">      private Integer end&#x3D;0;</span><br><span class="line">      public SumTask(int start,int end)&#123;</span><br><span class="line">          this.start&#x3D;start;</span><br><span class="line">          this.end&#x3D;end;</span><br><span class="line">      &#125;</span><br><span class="line">      @Override</span><br><span class="line">      protected Integer compute()&#123;</span><br><span class="line">          if(end -start &lt; 10)&#123;</span><br><span class="line">              int sum&#x3D;0;</span><br><span class="line">              for(int i&#x3D;start;i&lt;&#x3D;end;i++)&#123;</span><br><span class="line">                  sum+&#x3D;i;</span><br><span class="line">              &#125;</span><br><span class="line">              return sum;</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">              int middle&#x3D;(start+end)&#x2F;2;</span><br><span class="line">              SumTask leftTask&#x3D;new SumTask(start,middle);</span><br><span class="line">              SumTask rightTask&#x3D;new SumTask(middle+1,end);</span><br><span class="line">              leftTask.fork(); </span><br><span class="line">              rightTask.fork();</span><br><span class="line">              return leftTask.join()+rightTask.join();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">3.ForkJoinTask#fork</span><br><span class="line">    public final ForkJoinTask&lt;V&gt; fork() &#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        if ((t &#x3D; Thread.currentThread()) instanceof ForkJoinWorkerThread)</span><br><span class="line">            ((ForkJoinWorkerThread)t).workQueue.push(this); &#x2F;&#x2F;从线程的workQueue中获取</span><br><span class="line">        else</span><br><span class="line">            ForkJoinPool.common.externalPush(this);</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">4.ForkJoinPool中task的运行逻辑.</span><br><span class="line">  1.线程以LIFO从本地队列中获取任务并执行,直到线程的队列为空.</span><br><span class="line">  2.查看其它ForkJoinworkerThread是否有未执行的task,并通过工作密取的方式获取其它线程队列的任务.</span><br><span class="line">    工作密取的是方式是FIFO,减少与拥有者线程的冲突.</span><br><span class="line">5.ForkJoinPool局限性</span><br><span class="line">  ForkJoinPool的corePoolSize是CPU核数,</span><br><span class="line">  固定大小的线程池不利于执行I&#x2F;O密集型任务,因为若所有线程都阻塞,就出现STW的情况.</span><br></pre></td></tr></table></figure>
<h4 id="CompletionService"><a href="#CompletionService" class="headerlink" title="CompletionService"></a>CompletionService</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1.CompletionService将Executor与BlockingQueue的功能融合在一起.</span><br><span class="line">  通俗的来讲就是将任务执行的结果放入队列里了.</span><br><span class="line">2.源码分析.</span><br><span class="line">ExecutorCompletionService$QueueingFuture</span><br><span class="line">private class QueueingFuture extends FutureTask&lt;Void&gt; &#123;</span><br><span class="line">    QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;</span><br><span class="line">        super(task, null);</span><br><span class="line">        this.task &#x3D; task;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;内部类的字段表存在外部类的引用</span><br><span class="line">    @Override</span><br><span class="line">    protected void done() &#123;</span><br><span class="line">        &#x2F;&#x2F;将结果加入到completionQueue中</span><br><span class="line">        completionQueue.add(task);</span><br><span class="line">    &#125;</span><br><span class="line">    private final Future&lt;V&gt; task;</span><br><span class="line">&#125;</span><br><span class="line">3.使用示例.</span><br><span class="line">public class Renderer&#123;</span><br><span class="line">    private final ExecutorService executor;</span><br><span class="line">    Renderer(ExecutorService executor)&#123;</span><br><span class="line">        this.executor&#x3D;executor;</span><br><span class="line">    &#125;</span><br><span class="line">    void renderPage(CharSequence source)&#123;</span><br><span class="line">        List&lt;ImageInfo&gt;info&#x3D;scanForImageInfo(source);</span><br><span class="line">        CompletionService&lt;ImageData&gt;completionService&#x3D;new ExecutorCompletionService&lt;ImageData&gt;(executor);</span><br><span class="line">        for(final ImageInfo imageInfo:info)&#123;</span><br><span class="line">            completionService.submit(new Callable&lt;ImageData&gt;()&#123;</span><br><span class="line">               public ImageData call()&#123;</span><br><span class="line">                   return imageInfo.downloadImage();</span><br><span class="line">               &#125; </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        renderText(source);</span><br><span class="line">        try&#123;</span><br><span class="line">            for(int t&#x3D;0,n&#x3D;info.size();t&lt;n;t++)&#123;</span><br><span class="line">                Future&lt;ImageData&gt;f&#x3D;completionService.take();</span><br><span class="line">                ImageData imageData&#x3D;f.get();</span><br><span class="line">                renderImage(imageData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(InterruptException e)&#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;catch(ExceutionException e)&#123;</span><br><span class="line">            throw launderThrowable(e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
		<div>
			
				<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

			
		</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/juc/" rel="tag"># juc</a>
              <a href="/tags/concurrent/" rel="tag"># concurrent</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/16/mysql/" rel="prev" title="mysql">
      <i class="fa fa-chevron-left"></i> mysql
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/01/01/springmvc/" rel="next" title="springmvc">
      springmvc <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#并发简史"><span class="nav-number">1.</span> <span class="nav-text">并发简史</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程间通信"><span class="nav-number">1.1.</span> <span class="nav-text">进程间通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#守护线程"><span class="nav-number">1.2.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发和并行"><span class="nav-number">1.3.</span> <span class="nav-text">并发和并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#吞吐率和吞吐量"><span class="nav-number">1.4.</span> <span class="nav-text">吞吐率和吞吐量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求的处理-bio-nio-aio"><span class="nav-number">1.5.</span> <span class="nav-text">请求的处理(bio,nio,aio)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全性和活跃性"><span class="nav-number">1.6.</span> <span class="nav-text">安全性和活跃性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁-活锁-饥饿"><span class="nav-number">1.7.</span> <span class="nav-text">死锁,活锁,饥饿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程的缺点-线程特别的多"><span class="nav-number">1.8.</span> <span class="nav-text">多线程的缺点(线程特别的多)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程的优点"><span class="nav-number">1.9.</span> <span class="nav-text">多线程的优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全的相关概念"><span class="nav-number">2.</span> <span class="nav-text">线程安全的相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全的定义"><span class="nav-number">2.1.</span> <span class="nav-text">线程安全的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全的几种实现方式"><span class="nav-number">2.2.</span> <span class="nav-text">线程安全的几种实现方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的共享"><span class="nav-number">3.</span> <span class="nav-text">对象的共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非原子的64位操作"><span class="nav-number">3.1.</span> <span class="nav-text">非原子的64位操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发布和逸出"><span class="nav-number">3.2.</span> <span class="nav-text">发布和逸出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类"><span class="nav-number">3.3.</span> <span class="nav-text">内部类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">4.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代器与ConcurrentModificationException"><span class="nav-number">5.</span> <span class="nav-text">迭代器与ConcurrentModificationException</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的阻塞与中断"><span class="nav-number">6.</span> <span class="nav-text">线程的阻塞与中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue"><span class="nav-number">7.</span> <span class="nav-text">Queue</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">7.1.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#PriorityQueue"><span class="nav-number">7.2.</span> <span class="nav-text">PriorityQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">7.3.</span> <span class="nav-text">BlockingQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SynchronousQueue"><span class="nav-number">7.4.</span> <span class="nav-text">SynchronousQueue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deque"><span class="nav-number">7.5.</span> <span class="nav-text">Deque</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentMap"><span class="nav-number">8.</span> <span class="nav-text">ConcurrentMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentMap-1"><span class="nav-number">8.1.</span> <span class="nav-text">ConcurrentMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap"><span class="nav-number">8.2.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">8.3.</span> <span class="nav-text">ConcurrentHashMap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">9.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">9.1.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步工具"><span class="nav-number">10.</span> <span class="nav-text">同步工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS"><span class="nav-number">10.1.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">10.2.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition"><span class="nav-number">10.3.</span> <span class="nav-text">Condition</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#闭锁"><span class="nav-number">10.4.</span> <span class="nav-text">闭锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">10.5.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栅栏"><span class="nav-number">10.6.</span> <span class="nav-text">栅栏</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义缓存"><span class="nav-number">11.</span> <span class="nav-text">自定义缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务执行"><span class="nav-number">12.</span> <span class="nav-text">任务执行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FutureTask"><span class="nav-number">12.1.</span> <span class="nav-text">FutureTask</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">13.</span> <span class="nav-text">CompletableFuture</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor框架"><span class="nav-number">14.</span> <span class="nav-text">Executor框架</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadPoolExecutor"><span class="nav-number">14.1.</span> <span class="nav-text">ThreadPoolExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledThreadPoolExecutor"><span class="nav-number">14.2.</span> <span class="nav-text">ScheduledThreadPoolExecutor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ForkJoinPool"><span class="nav-number">14.3.</span> <span class="nav-text">ForkJoinPool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CompletionService"><span class="nav-number">14.4.</span> <span class="nav-text">CompletionService</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vicyor"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">vicyor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vicyor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vicyor" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2457569580@qq.com" title="E-Mail → mailto:2457569580@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vicyor</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">885k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:25</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=m9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'm9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz',
            'X-LC-Key': 'g7WSuE6aDmunoX4rgyBN7SJa',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'qQhr9rNGJh6YalJA0mfaaurx-gzGzoHsz',
    appKey: 'kJy8NJeOTMPnxQ3zLihOcnw3',
    placeholder: "请留下您的宝贵评论",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

	
		 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
		 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
		 <script type="text/javascript" src="/js/src/fireworks.js"></script>
	
</body>
</html>
