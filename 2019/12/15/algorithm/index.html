<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://vicyor.gitee.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="第一次看左神的书.来谈谈自己目前的算法水平:都不会.希望在看完左神的书后,算法水平:有思路.">
<meta property="og:type" content="article">
<meta property="og:title" content="algorithm">
<meta property="og:url" content="http://vicyor.gitee.io/2019/12/15/algorithm/index.html">
<meta property="og:site_name" content="Vicyor">
<meta property="og:description" content="第一次看左神的书.来谈谈自己目前的算法水平:都不会.希望在看完左神的书后,算法水平:有思路.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://vicyor.gitee.io/2019/12/15/algorithm/max-sequence.png">
<meta property="article:published_time" content="2019-12-15T01:16:00.000Z">
<meta property="article:modified_time" content="2020-07-11T01:00:42.536Z">
<meta property="article:author" content="vicyor">
<meta property="article:tag" content="algorithm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://vicyor.gitee.io/2019/12/15/algorithm/max-sequence.png">

<link rel="canonical" href="http://vicyor.gitee.io/2019/12/15/algorithm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>algorithm | Vicyor</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vicyor</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">47</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">52</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vicyor.gitee.io/2019/12/15/algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="vicyor">
      <meta itemprop="description" content="大路且慢慢,咱一步一步走完.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vicyor">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          algorithm
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-15 09:16:00" itemprop="dateCreated datePublished" datetime="2019-12-15T09:16:00+08:00">2019-12-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-11 09:00:42" itemprop="dateModified" datetime="2020-07-11T09:00:42+08:00">2020-07-11</time>
              </span>

          
            <span id="/2019/12/15/algorithm/" class="post-meta-item leancloud_visitors" data-flag-title="algorithm" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2019/12/15/algorithm/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/12/15/algorithm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>52k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>47 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>第一次看左神的书.来谈谈自己目前的算法水平:都不会.希望在看完左神的书后,算法水平:有思路.</p>
<a id="more"></a>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="设计一个有getMin功能的栈"><a href="#设计一个有getMin功能的栈" class="headerlink" title="设计一个有getMin功能的栈"></a>设计一个有getMin功能的栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">题目: 实现一个特殊的栈,在实现栈的基本功能的基础上,再实现返回栈中最小元素的操作.</span><br><span class="line">要求: 返回栈中最小元素的操作时间复杂度为O(<span class="number">1</span>).</span><br><span class="line">难度:  *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用一个单调栈辅助完成popMin操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>&#123;</span><br><span class="line">    Stack &lt;Integer&gt; stackData;</span><br><span class="line">    <span class="comment">//单调递减栈</span></span><br><span class="line">    Stack &lt;Integer&gt; stackMin;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">(Stack&lt;Integer&gt;stackData,Stack&lt;Integer&gt;stackMin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackData=stackData;</span><br><span class="line">        <span class="keyword">this</span>.stackMin=stackMin;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8 2 4 5 7 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer num)</span></span>&#123;</span><br><span class="line">        stackData.push(num);</span><br><span class="line">        <span class="keyword">if</span>(!stackMin.isEmpty()&amp;&amp;stackMin.peek()&lt;=num)&#123;</span><br><span class="line">            stackMin.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Integer num=stackData.pop();</span><br><span class="line">        <span class="keyword">if</span>(num.equals(stackMin.peek()))&#123;</span><br><span class="line">            stackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackMin.isEmpty()?<span class="keyword">null</span>:stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="由两个栈组成的队列"><a href="#由两个栈组成的队列" class="headerlink" title="由两个栈组成的队列"></a>由两个栈组成的队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">题目:用<span class="number">2</span>个栈实现一个队列,支持队列的基本操作(add,poll,peek).</span><br><span class="line">难度：**</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoStacksQueue</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    Stack&lt;Integer&gt; stackPop;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStackQueue</span><span class="params">(Stack&lt;Integer&gt;stackPush,Stack&lt;Integer&gt;stackPop)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stackPush=stackPush;</span><br><span class="line">        <span class="keyword">this</span>.stackPop=stackPop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushToPop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackPop=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stackPush.isEmpty())&#123;</span><br><span class="line">            stackPop.push(stackPush.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">popToPush</span><span class="params">()</span></span>&#123;</span><br><span class="line">        stackPush=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stackPop.isEmpty())&#123;</span><br><span class="line">            stackPush.push(stackPop.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> pushInt)</span></span>&#123;</span><br><span class="line">        stackPush.push(pushInt);</span><br><span class="line">        pushToPop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=stackPop.pop();</span><br><span class="line">        popToPush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stackPop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何仅用递归函数和栈操作逆序一个栈"><a href="#如何仅用递归函数和栈操作逆序一个栈" class="headerlink" title="如何仅用递归函数和栈操作逆序一个栈"></a>如何仅用递归函数和栈操作逆序一个栈</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">题目: 用递归逆序一个栈</span><br><span class="line">难度: **</span><br><span class="line">思路:  </span><br><span class="line">    <span class="number">1</span>.每次递归操作都只移除栈底,并返回栈底</span><br><span class="line">    <span class="number">2</span>.在回溯时候再pop栈底.</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAndRemoveLastElement</span><span class="params">(Stack&lt;Integer&gt;stack)</span></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> result=stack.pop();</span><br><span class="line">         <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">             <span class="keyword">return</span> result;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">int</span> last=getAndRemoveLastElement(stack);</span><br><span class="line">             stack.push(result);</span><br><span class="line">             <span class="keyword">return</span> last;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Stack&lt;Integer&gt;stack)</span></span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">int</span> last=getAndRemoveLastElement(stack);</span><br><span class="line">         reverse(stack);</span><br><span class="line">         stack.push(last);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<h3 id="用一个栈实现另一个栈的排序"><a href="#用一个栈实现另一个栈的排序" class="headerlink" title="用一个栈实现另一个栈的排序"></a>用一个栈实现另一个栈的排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">题目: 用一个栈实现另一个栈的排序</span><br><span class="line">难度: *</span><br><span class="line">    <span class="comment">// 2 5 3 8 1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortStackByStack</span><span class="params">(Stack&lt;Integer&gt;stack)</span></span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt;help=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> num =stack.pop();</span><br><span class="line">            <span class="keyword">while</span>(!help.isEmpty()&amp;&amp;num&lt;help.peek())&#123;</span><br><span class="line">                stack.push(help.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            help.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!help.isEmpty())&#123;</span><br><span class="line">            stack.push(help.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        help=<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">问题:汉诺塔问题.</span><br><span class="line">难度:**</span><br><span class="line">    <span class="keyword">private</span> String left=<span class="string">"left"</span>;</span><br><span class="line">    <span class="keyword">private</span> String mid=<span class="string">"mid"</span>;</span><br><span class="line">    <span class="keyword">private</span> String right=<span class="string">"right"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> num,String from,String to,String temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//将 1号盘 从 from 移动到 to</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">            result=process(num-<span class="number">1</span>,from,temp,to);</span><br><span class="line">            <span class="comment">//将 num 号盘 从 from移动到 to</span></span><br><span class="line">            result++;</span><br><span class="line">            result+=process(num-<span class="number">1</span>,temp,to,from);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="生成窗口的最大值数组"><a href="#生成窗口的最大值数组" class="headerlink" title="生成窗口的最大值数组"></a>生成窗口的最大值数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">题目:有一个整形数组arr和一个大小为w的窗口从数组的最左边滑到最右边,窗口每次向右移动一个位置.</span><br><span class="line">难度: **</span><br><span class="line">要求:时间复杂度 O(n)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxWindow</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []res=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length-w+<span class="number">1</span>];</span><br><span class="line">    LinkedQueue&lt;Integer&gt;queue=<span class="keyword">new</span> LinkedQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;arr[queue.peekLast()]&lt;arr[i])&#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="comment">//去头</span></span><br><span class="line">        <span class="keyword">if</span>(queue.peekFirst()&lt;=i-w)&#123;</span><br><span class="line">            queue.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=w-<span class="number">1</span>&amp;&amp;i&lt;res.length-w+<span class="number">1</span>)&#123;</span><br><span class="line">            res[index++]=queue.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```    </span><br><span class="line">### 单调栈结构</span><br><span class="line">```java</span><br><span class="line">题目:给定一个不含有重复值的数组arr,找到每一个i位置左边和右边离i位置最近且值比arr[i]小的位置.</span><br><span class="line">难度: **</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[][] rightWay(<span class="keyword">int</span> []arr)&#123;</span><br><span class="line">     <span class="keyword">int</span> [][]res=<span class="keyword">new</span> <span class="keyword">int</span>[arr.length][<span class="number">2</span>];</span><br><span class="line">     Stack&lt;Integer&gt;stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">         <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;arr[stack.peek()]&gt;arr[i])&#123;</span><br><span class="line">             Integer idx=stack.pop();</span><br><span class="line">            res[idx][<span class="number">1</span>]=i;</span><br><span class="line">            <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                res[idx][<span class="number">0</span>]=stack.peek();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">             res[idx][<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         stack.push(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">         Integer idx=stack.pop();</span><br><span class="line">         res[idx][<span class="number">1</span>]=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!stack.Empty())&#123;</span><br><span class="line">            res[idx][<span class="number">0</span>]=stack.peek();</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="求最大子矩阵大小"><a href="#求最大子矩阵大小" class="headerlink" title="求最大子矩阵大小"></a>求最大子矩阵大小</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">题目: 一个整形矩阵,其中的值只有<span class="number">0</span>和<span class="number">1</span>两种,求由<span class="number">1</span>组成的最大矩形面积</span><br><span class="line">难度: ***</span><br><span class="line">    <span class="comment">//统计每一列从下到上的连续的一数量.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> []maxRecFromBottom(<span class="keyword">int</span> [][] map)&#123;</span><br><span class="line">        <span class="keyword">int</span> []res=<span class="keyword">new</span> <span class="keyword">int</span>[map[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=map.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;map[i].length;j++)&#123;</span><br><span class="line">                res[j]=res[i][j]==<span class="number">0</span>?<span class="number">0</span>:res[j]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  找出 第 i 列 左右比它小的元素, 以i列为height的最大面积为  (left~right)*height[i]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[]height)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用上一题的算法</span></span><br><span class="line">        <span class="keyword">int</span> [][]res=rightWay(height);</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i][<span class="number">0</span>]!=-<span class="number">1</span>&amp;&amp;res[i][<span class="number">1</span>]!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;(res[i][<span class="number">1</span>]-res[i][<span class="number">0</span>]-<span class="number">1</span>)*height[i])&#123;</span><br><span class="line">                    max=(res[i][<span class="number">1</span>]-res[i][<span class="number">0</span>]-<span class="number">1</span>)*height[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res[i][<span class="number">0</span>]==-<span class="number">1</span>&amp;&amp;res[i][<span class="number">0</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;height[i]*(height.length))&#123;</span><br><span class="line">                    max==height[i]*height.length;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res[i][<span class="number">0</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;height[i]*(res[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                    max=height[i]*res[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(res[i][<span class="number">1</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(max&lt;height[i]*(height.length-i))&#123;</span><br><span class="line">                    max=height[i]*(height.length-i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大值减去最小值小于或等于num的子数组数量"><a href="#最大值减去最小值小于或等于num的子数组数量" class="headerlink" title="最大值减去最小值小于或等于num的子数组数量"></a>最大值减去最小值小于或等于num的子数组数量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定数组arr和整数num,其返回有多少个子数组满足如下情况:</span><br><span class="line">      max(arr[i..j])-min(arr[i..j])&lt;=num</span><br><span class="line">难度: ***</span><br><span class="line">时间复杂度: O(N)</span><br><span class="line"><span class="comment">//下面的解时间复杂度是2N,i和j都会走下arr的下标.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="comment">//头是存极值,尾巴是存当前.</span></span><br><span class="line">    LinkedList&lt;Integer&gt;qmin=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt;qmax=<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;arr.length)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(qmin.isEmpty()||qmin.peekLast()!=j)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!qmin.isEmpty()&amp;&amp;arr[qmin.peekLast()]&gt;arr[j])&#123;</span><br><span class="line">                    qmin.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(!qmax.isEmpty()&amp;&amp;arr[qmax.peekLast()]&lt;arr[j])&#123;</span><br><span class="line">                    qmax.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if qmin.peekLast==j ==&gt; i+1 ~j</span></span><br><span class="line">            <span class="comment">//else  i~j+1</span></span><br><span class="line">            <span class="keyword">if</span>((arr[qmax.peekFirst()]-arr[qmin.peekFirst()])&gt;num)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// arr[i..j-1],arr[i..j-2],......arr[i,i+1],arr[i,i]</span></span><br><span class="line">        res+=j-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(qmax.peekFirst()==i)&#123;</span><br><span class="line">            qmax.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(qmin.peekFirst()==i)&#123;</span><br><span class="line">            qmin.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">题目: 将中缀表达式转后缀表达式.</span><br><span class="line">难度: **</span><br><span class="line">思路: </span><br><span class="line">    通过栈,从左向右遍历.</span><br><span class="line">    <span class="number">1</span>.数字 直接输出.</span><br><span class="line">    <span class="number">2</span>.<span class="string">'('</span> 直接压栈.</span><br><span class="line">    <span class="number">3</span>.<span class="string">')'</span> 栈不断得弹出并输出,直到<span class="string">'('</span>为止 (ps:<span class="string">'C'</span>不输出).</span><br><span class="line">    <span class="number">4</span>.运算符  若优先级高于栈顶运算符,则压栈.</span><br><span class="line">              若优先级低于栈顶运算符,则弹出并输出,直到找到比其小的运算符,压栈.</span><br><span class="line">    <span class="number">5</span>.输出操作数栈得所有操作符.</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">midToSuffix</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        StringBuilder result=<span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">char</span> []chs=str.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt;os=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> ch:chs)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                result.append(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">'('</span>)&#123;</span><br><span class="line">                os.push(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch==<span class="string">')'</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> c=<span class="string">''</span>;</span><br><span class="line">                <span class="keyword">while</span>((c=os.pop())!=<span class="string">'('</span>)&#123;</span><br><span class="line">                    result.append(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// * / + -</span></span><br><span class="line">                <span class="keyword">if</span>(ch==<span class="string">'+'</span>||ch==<span class="string">'-'</span>)&#123;</span><br><span class="line">                    os.push(ch);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//* /</span></span><br><span class="line">                    <span class="keyword">char</span> c=<span class="string">''</span>;</span><br><span class="line">                    <span class="keyword">while</span>(!os.isEmpty()&amp;&amp;((c=os.peek())==<span class="string">'+'</span>)||(c=os.peek())==<span class="string">'-'</span>))&#123;</span><br><span class="line">                        os.pop();</span><br><span class="line">                        result.append(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                    os.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!os.isEmpty())&#123;</span><br><span class="line">            result.append(os.pop());</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表问题"><a href="#链表问题" class="headerlink" title="链表问题"></a>链表问题</h2><h3 id="两个有序链表的公共部分"><a href="#两个有序链表的公共部分" class="headerlink" title="两个有序链表的公共部分"></a>两个有序链表的公共部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定两个有序链表的头指针head1和头指针head2,打印两个链表的公共部分.</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printCommonPart</span><span class="params">(Node head1,Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head1!=<span class="keyword">null</span>&amp;&amp;head2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head1.value==head2.value)&#123;</span><br><span class="line">            System.out.printf(<span class="string">"%s,"</span>,head1.value);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head1.value&gt;head2.value)&#123;</span><br><span class="line">            head2=head2.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(head1.value&lt;head2.value)&#123;</span><br><span class="line">            head1=head1.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断两个链表是否相交"><a href="#判断两个链表是否相交" class="headerlink" title="判断两个链表是否相交"></a>判断两个链表是否相交</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">题目:给定两个链表,判断是否相交.</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">//法一:查看尾节点是否相同.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isListIntersection</span><span class="params">(Node head1,Node head2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head1.next!=<span class="keyword">null</span>)&#123;head1=head1.next&#125;;</span><br><span class="line">    <span class="keyword">while</span>(head2.next!=<span class="keyword">null</span>)&#123;head2=head2.next&#125;;</span><br><span class="line">    <span class="keyword">return</span> head1.equals(head2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断一个链表是否存在环"><a href="#判断一个链表是否存在环" class="headerlink" title="判断一个链表是否存在环"></a>判断一个链表是否存在环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目: 判断一个链表是否存在环.</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRingList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>||head.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node fast=head.next.next;</span><br><span class="line">    Node slow=head.next;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;!fast.equals(slow))&#123;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        slow=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast==<span class="keyword">null</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在单列表中删除倒数第K个节点"><a href="#在单列表中删除倒数第K个节点" class="headerlink" title="在单列表中删除倒数第K个节点"></a>在单列表中删除倒数第K个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">题目: 删除单列表的倒数第K个节点</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">removeLastKthNode</span><span class="params">(Node head,<span class="keyword">int</span> lastKth)</span></span>&#123;</span><br><span class="line">    Node cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        head=head.next;</span><br><span class="line">        lastKth--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lastKth==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//删除的是头节点</span></span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lastKth&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(++lastKth!=<span class="number">0</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cur为删除位置的pre节点</span></span><br><span class="line">        cur.next=cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在双列表中删除到数第K个节点"><a href="#在双列表中删除到数第K个节点" class="headerlink" title="在双列表中删除到数第K个节点"></a>在双列表中删除到数第K个节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">题目:删除双列表的到数第k个节点</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> DoubleNode <span class="title">removeLastKthNode</span><span class="params">(DoubleNode head,<span class="keyword">int</span> lastKth)</span></span>&#123;</span><br><span class="line">    Node cur=head;</span><br><span class="line">    whiel(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">        lastKth--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lastKth==<span class="number">0</span>)&#123;</span><br><span class="line">        head.next.pre=<span class="keyword">null</span>;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(lastKth&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(++lastKth!=<span class="number">0</span>)&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//双列表的删除</span></span><br><span class="line">        DoubleNode p=cur.next;</span><br><span class="line">        DoubleNode pre=cur;</span><br><span class="line">        pre.next=p.next;</span><br><span class="line">        <span class="keyword">if</span>(p.next!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//非尾节点</span></span><br><span class="line">            p.next.pre=pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除链表的中间节点"><a href="#删除链表的中间节点" class="headerlink" title="删除链表的中间节点"></a>删除链表的中间节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">题目:给定链表的头节点head,实现删除链表的中间节点的函数.</span><br><span class="line">难度: **</span><br><span class="line"> <span class="number">0</span>---&gt;<span class="number">1</span>  删除 <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>---&gt;<span class="number">1</span>---&gt;<span class="number">2</span> 删除 <span class="number">1</span></span><br><span class="line"> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 数学分析</span></span><br><span class="line"><span class="comment">  *  i*2 == null</span></span><br><span class="line"><span class="comment">  *  i-1是删除节点</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Node <span class="title">removeMidNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> head;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(head.next.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">     &#125;</span><br><span class="line">     Node i=head;</span><br><span class="line">     <span class="comment">//j是2(i+1)</span></span><br><span class="line">     Node j=head.next.next;</span><br><span class="line">     <span class="comment">//if 2((i+1)+1) 不满足, i+1就是mid,i就是pre</span></span><br><span class="line">     <span class="keyword">while</span>(j.next!=<span class="keyword">null</span>&amp;&amp;j.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         j=j.next.next;</span><br><span class="line">         i=i.next;</span><br><span class="line">     &#125;</span><br><span class="line">     i.next=i.next.next;</span><br><span class="line">     <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除a-b处的节点"><a href="#删除a-b处的节点" class="headerlink" title="删除a/b处的节点"></a>删除a/b处的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">问题: 给定链表的头节点head,整数a和b,实现删除位于a/b处节点的函数.</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">removeByRatio</span><span class="params">(Node head,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;<span class="number">1</span>||a&gt;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    Node cur=head;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        n++;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    n=(<span class="keyword">int</span>)Math.ceil((a*<span class="number">1.0</span>/b*n));</span><br><span class="line">    cur=head;</span><br><span class="line">    <span class="comment">//走了n-1次,找到pre节点</span></span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.next=cur.next.next;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转单向链表"><a href="#反转单向链表" class="headerlink" title="反转单向链表"></a>反转单向链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">问题:实现反转单向列表</span><br><span class="line">要求:若链表长度为n,时间复杂度要求为o(n),空间复杂度要求为O(<span class="number">1</span>).</span><br><span class="line">难度:*</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reverseList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Node pre=head;</span><br><span class="line">    Node cur=head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        pre.next=cur.next;</span><br><span class="line">        cur.next=head;</span><br><span class="line">        head=cur;</span><br><span class="line">        cur=pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转双向链表"><a href="#反转双向链表" class="headerlink" title="反转双向链表"></a>反转双向链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">问题:实现反转双向列表</span><br><span class="line">难度:*</span><br><span class="line"><span class="function"><span class="keyword">public</span> DoubleNode <span class="title">reverseList</span><span class="params">(DoubleNode head)</span></span>&#123;</span><br><span class="line">    Node pre=head;</span><br><span class="line">    Node cur=head.next;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        pre.next=cur.next;</span><br><span class="line">        cur.next=head;</span><br><span class="line">        <span class="comment">//这个是最终位置</span></span><br><span class="line">        head.pre=cur;</span><br><span class="line">        head=cur;</span><br><span class="line">        cur=pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反转部分单向列表"><a href="#反转部分单向列表" class="headerlink" title="反转部分单向列表"></a>反转部分单向列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一个单向列表,头节点为head,对from到to位置的节点进行反转.</span><br><span class="line">    例如: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;<span class="keyword">null</span>,from=<span class="number">2</span>,to=<span class="number">4</span>. 调整结果: <span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>-&gt;<span class="keyword">null</span>.</span><br><span class="line">要求:时间复杂度 O(N) 空间复杂度O(<span class="number">1</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reversePart</span><span class="params">(Node head,<span class="keyword">int</span> from ,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    Node node1=head;</span><br><span class="line">    <span class="comment">//反转 fPre ~ tPos(不包括fpre,包括tPos) </span></span><br><span class="line">    Node fPre=<span class="keyword">null</span>;</span><br><span class="line">    Node tPos=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(node1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        node1=node1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(from&gt;to||from&lt;<span class="number">1</span>||to&gt;len)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    node1=head;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;from-<span class="number">1</span>)&#123;</span><br><span class="line">        node1=node1.next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    fPre=node1;</span><br><span class="line">    tPos=node1.next;</span><br><span class="line">    Node tempHead=fPre.next;</span><br><span class="line">    Node pre=tempHead;</span><br><span class="line">    node1=fpre.next.next;</span><br><span class="line">    index+=<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(index&lt;to+<span class="number">1</span>)&#123;</span><br><span class="line">        pre.next=node1.next;</span><br><span class="line">        node1.next=tempHead;</span><br><span class="line">        tempHead=node1;</span><br><span class="line">        node1=pre.next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    fPre.next=tempHead;</span><br><span class="line">    tPos.next=node1;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="环形单列表的约瑟夫环问题"><a href="#环形单列表的约瑟夫环问题" class="headerlink" title="环形单列表的约瑟夫环问题"></a>环形单列表的约瑟夫环问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">题目: 约瑟夫环问题: <span class="number">41</span>个人排成一个圈,从<span class="number">1</span>开始报数,到<span class="number">3</span>时剔除一个人,下一位继续报数,求最后一个人是谁.</span><br><span class="line">难度: *</span><br><span class="line">条件: Node 是一个环.</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">josephusKill</span><span class="params">(Node head,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    Node pre=head;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化pre</span></span><br><span class="line">    <span class="keyword">while</span>(pre.next!=head)&#123;</span><br><span class="line">        pre=pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pre!=head)&#123;</span><br><span class="line">        <span class="keyword">if</span>(++i==m)&#123;</span><br><span class="line">            pre.next=head.next;</span><br><span class="line">            i=<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断一个链表是否为回文结构"><a href="#判断一个链表是否为回文结构" class="headerlink" title="判断一个链表是否为回文结构"></a>判断一个链表是否为回文结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">题目: 一个链表的头节点head,判断该链表是否为回文结构</span><br><span class="line">难度: *</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 解法一:利用栈结构</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean isPalindrome(Node node)&#123;</span><br><span class="line">    Stack&lt;Integer&gt;stack&#x3D;new Stack&lt;Integer&gt;();</span><br><span class="line">    Node head&#x3D;node;</span><br><span class="line">    while(node!&#x3D;null)&#123;</span><br><span class="line">        stack.push(node.data);</span><br><span class="line">        node&#x3D;node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    node&#x3D;head;</span><br><span class="line">    boolean palindrome&#x3D;true;</span><br><span class="line">    while(node!&#x3D;null)&#123;</span><br><span class="line">        if(stack.pop!&#x3D;node.data)&#123;</span><br><span class="line">            palindrome&#x3D;false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return palindrome;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 解法二：只放链表后半部分入栈</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean isPalindrome(Node node)&#123;</span><br><span class="line">    Node right&#x3D;head;</span><br><span class="line">    Node cur&#x3D;head;</span><br><span class="line">    while(cur.next!&#x3D;null&amp;&amp;cur.next.next!&#x3D;null)&#123;</span><br><span class="line">        right&#x3D;cur.next;</span><br><span class="line">        cur&#x3D;cur.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt;stack&#x3D;new Stack();</span><br><span class="line">    while(right!&#x3D;null)&#123;</span><br><span class="line">        stack.push(right);</span><br><span class="line">        right&#x3D;right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        if(head.value!&#x3D;stack.pop().value)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        head&#x3D;head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将单向列表按给定位置划分成左边小-中间相等-右边大的形式"><a href="#将单向列表按给定位置划分成左边小-中间相等-右边大的形式" class="headerlink" title="将单向列表按给定位置划分成左边小,中间相等,右边大的形式"></a>将单向列表按给定位置划分成左边小,中间相等,右边大的形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">题目:给定一个单向链表的头节点是head,节点类型是整数类型,在给定一个整数pivot.</span><br><span class="line">     实现一个调整链表的函数,将链表调整为左部分是小于pivot位置的节点,中间部分是等于pivot的节点.右部分是大于pivot的节点.</span><br><span class="line">难度: **</span><br><span class="line">ps: 这是我自己想出来的</span><br><span class="line">public Node listParition(Node head,int pivot)&#123;</span><br><span class="line">    Node cur&#x3D;head;</span><br><span class="line">    int i&#x3D;1;</span><br><span class="line">    while(cur!&#x3D;null&amp;&amp;i&lt;pivot)&#123;</span><br><span class="line">        cur&#x3D;cur.next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&lt;pivot||pivot&lt;1)&#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node smallHead&#x3D;null;</span><br><span class="line">    Node small&#x3D;null;</span><br><span class="line">    Node bigHead&#x3D;null;</span><br><span class="line">    Node big&#x3D;null;</span><br><span class="line">    Node equalHead&#x3D;null;</span><br><span class="line">    Node equal&#x3D;null;</span><br><span class="line">    Node node&#x3D;head;</span><br><span class="line">    while(node!&#x3D;null)&#123;</span><br><span class="line">        if(node.value()&lt;cur.value())&#123;</span><br><span class="line">            if(smallHead&#x3D;&#x3D;null)&#123;</span><br><span class="line">                smallHead&#x3D;node;</span><br><span class="line">                small&#x3D;node;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                small.next&#x3D;node;</span><br><span class="line">                small&#x3D;node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if (node.value()&#x3D;&#x3D;cur.value())&#123;</span><br><span class="line">            if(equalHead&#x3D;&#x3D;null)&#123;</span><br><span class="line">                equalHead&#x3D;node;</span><br><span class="line">                equal&#x3D;node;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                equal.next&#x3D;node;</span><br><span class="line">                equal&#x3D;node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(bigHead&#x3D;&#x3D;null)&#123;</span><br><span class="line">                bigHead&#x3D;node;</span><br><span class="line">                big&#x3D;node;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                big.next&#x3D;node;</span><br><span class="line">                big&#x3D;node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node&#x3D;node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(small!&#x3D;null)&#123;</span><br><span class="line">        small.next&#x3D;equalHead;</span><br><span class="line">    &#125;</span><br><span class="line">    equal.next&#x3D;bigHead;</span><br><span class="line">    return small&#x3D;&#x3D;null?equalHead:smallHead;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复制含有随机指针节点的链表"><a href="#复制含有随机指针节点的链表" class="headerlink" title="复制含有随机指针节点的链表"></a>复制含有随机指针节点的链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">题目: 一种特殊的链表节点类描述如下:</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> Node rand;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value=date;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    rand指针是指向该链表的随机指针</span><br><span class="line">难度: **</span><br><span class="line">解析: 主要是rand指向的必须是链表中的节点,不能重复<span class="keyword">new</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法一: 使用Map</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyListWithRand</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    Map &lt;Node,Node&gt;map=<span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">    Node tmp=node;</span><br><span class="line">    <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        map.put(tmp,<span class="keyword">new</span> Node(tmp.data));</span><br><span class="line">        tmp=tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp=node;</span><br><span class="line">    <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Node newNode=map.get(tmp);</span><br><span class="line">        newNode.next=map.get(tmp.next);</span><br><span class="line">        newNode.rand=map.get(tmp.rand);</span><br><span class="line">        tmp=tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法二:</span></span><br><span class="line"><span class="comment"> * 在原列表后面插入复制节点</span></span><br><span class="line"><span class="comment"> *  1 -&gt; 2 -&gt; 3 -&gt; 4</span></span><br><span class="line"><span class="comment"> *  1 -&gt; 1' -&gt; 2 -&gt; 2' -&gt; 3 -&gt; 3' -&gt;4 -&gt;4'</span></span><br><span class="line"><span class="comment"> *  这样的话</span></span><br><span class="line"><span class="comment"> *  newNode.next = node.next.next</span></span><br><span class="line"><span class="comment"> *  newNode.rand = node.rand.next</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">copyListWithRand</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="comment">//复制</span></span><br><span class="line">    Node p=node;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Node copy=<span class="keyword">new</span> Node(p.data);</span><br><span class="line">        copy.next=p.next;</span><br><span class="line">        p.next=copy;</span><br><span class="line">        p=copy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p=node;</span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Node copy=p.next;</span><br><span class="line">        copy.next=copy.next==<span class="keyword">null</span>?<span class="keyword">null</span>:copy.next.next;</span><br><span class="line">        copy.rand=p.rand==<span class="keyword">null</span>?<span class="keyword">null</span>:p.rand.next;</span><br><span class="line">        p=p.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node res=node.next;</span><br><span class="line">    <span class="comment">//还原node</span></span><br><span class="line">    p=node;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        p=p.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="两个单列表生成相加列表"><a href="#两个单列表生成相加列表" class="headerlink" title="两个单列表生成相加列表"></a>两个单列表生成相加列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">题目:  生成<span class="number">2</span>个整数链表相加后的结果.</span><br><span class="line">要求:  *</span><br><span class="line">例如:   </span><br><span class="line">        <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span></span><br><span class="line">        <span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>     </span><br><span class="line">        <span class="number">1234</span>+<span class="number">4321</span>=<span class="number">5555</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法一:用栈作为工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">addLists</span><span class="params">(Node h1,Node h2)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt;s1=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt;s2=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Node node1=h1;</span><br><span class="line">    Node node2=h2;</span><br><span class="line">    <span class="keyword">while</span>(node1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        s1.push(node1.value());</span><br><span class="line">        node1=node1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        s2.push(node2.value());</span><br><span class="line">        node2=node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> base=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!s1.isEmpty()&amp;&amp;s2.isEmpty())&#123;</span><br><span class="line">        sum+=base*s1.pop();</span><br><span class="line">        sum+=base*s2.pop();</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s1.isEmpty())&#123;</span><br><span class="line">        sum+=base*s1.pop();</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s2.isEmpty())&#123;</span><br><span class="line">        sum+=base*s2.pop();</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法二: 逆置列表,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">addList</span><span class="params">(Node h1,Node h2)</span></span>&#123;</span><br><span class="line">    Node tail=h1;</span><br><span class="line">    Node p=h1.next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        tail.next=p.next;</span><br><span class="line">        p.next=h1;</span><br><span class="line">        h1=p;</span><br><span class="line">        p=tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail=h2;</span><br><span class="line">    p=h2.next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        tail.next=p.next;</span><br><span class="line">        p.next=h2;</span><br><span class="line">        h2=p;</span><br><span class="line">        p=tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> base=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    Node node1=h1;</span><br><span class="line">    Node node2=h2;</span><br><span class="line">    <span class="keyword">while</span>(node1!=<span class="keyword">null</span>&amp;&amp;node2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sum+=base*node1.value();</span><br><span class="line">        sum+=base*node2.value();</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">        node1=node1.next;</span><br><span class="line">        node2=node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sum+=base*node1.value();</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">        node1=node1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        sum+=base*node2.value();</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">        node2=node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将单列表的每k个节点逆序"><a href="#将单列表的每k个节点逆序" class="headerlink" title="将单列表的每k个节点逆序"></a>将单列表的每k个节点逆序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">问题:给定一个单列表,列表头为head,以k个节点为一组,实现单列表的逆置</span><br><span class="line">难度:**</span><br><span class="line">举例: </span><br><span class="line">     列表:  1-&gt;3-&gt;5-&gt;1-&gt;2-&gt;4-&gt;6-&gt;8-&gt;2   m&#x3D;3</span><br><span class="line">     逆置后:5-&gt;3-&gt;1-&gt;4-&gt;2-&gt;1-2-&gt;8-&gt;6</span><br><span class="line">     若最后一部分链表size&lt;m则不逆置.</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 使用栈结构</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Node reverseMNode(Node head,int m)&#123;</span><br><span class="line">    Stack&lt;Integer&gt;stack&#x3D;new Stack&lt;Integer&gt;();</span><br><span class="line">    Node newHead&#x3D;null;</span><br><span class="line">    Node p&#x3D;head;</span><br><span class="line">    int i&#x3D;1;</span><br><span class="line">    Node lastTail&#x3D;null;</span><br><span class="line">    while(p!&#x3D;null)&#123;</span><br><span class="line">        if(i%m&#x3D;&#x3D;1)&#123;</span><br><span class="line">            if(lastTail!&#x3D;null)</span><br><span class="line">                lastTail.next&#x3D;p;</span><br><span class="line">            lastTail&#x3D;p;</span><br><span class="line">        &#125;</span><br><span class="line">        Node tmp&#x3D;p.next;</span><br><span class="line">        if(i%m&#x3D;&#x3D;0)&#123;</span><br><span class="line">            newHead&#x3D;newHead&#x3D;&#x3D;null?p:newHead;</span><br><span class="line">            while(!stack.isEmpty())&#123;</span><br><span class="line">                p.next&#x3D;stack.pop();</span><br><span class="line">                p&#x3D;p.next;</span><br><span class="line">            &#125;    </span><br><span class="line">            lastTail.next&#x3D;temp;</span><br><span class="line">        &#125;</span><br><span class="line">        p&#x3D;tmp;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 直接逆转列表</span><br><span class="line"> *&#x2F;</span><br><span class="line">public Node reverseMNode(Node head,int m)&#123;</span><br><span class="line">    Node newHead&#x3D;null;</span><br><span class="line">    Node p&#x3D;head;</span><br><span class="line">    Node lastTail&#x3D;null;</span><br><span class="line">    int i&#x3D;1;</span><br><span class="line">    while(p!&#x3D;null)&#123;</span><br><span class="line">        if(i%m&#x3D;&#x3D;1)&#123;</span><br><span class="line">            if(lastTail!&#x3D;null)</span><br><span class="line">                lastTail.next&#x3D;p;</span><br><span class="line">            lastTail&#x3D;p;</span><br><span class="line">        &#125;</span><br><span class="line">        Node tmp&#x3D;p.next;</span><br><span class="line">        if(i%m&#x3D;&#x3D;0)&#123;</span><br><span class="line">            newHead&#x3D;newHead&#x3D;&#x3D;null?p:newHead;</span><br><span class="line">            </span><br><span class="line">            &#x2F;**</span><br><span class="line">             * 将 lastTail.next ~ p逆转</span><br><span class="line">             *&#x2F;</span><br><span class="line">            Node tHead&#x3D;lastTail&#x3D;&#x3D;null?head:lastTail.next;</span><br><span class="line">            Node q&#x3D;thead.next;</span><br><span class="line">            Node pre&#x3D;tHead;</span><br><span class="line">            while(q!&#x3D;p.next)&#123;</span><br><span class="line">                pre.next&#x3D;q.next;</span><br><span class="line">                q.next&#x3D;tHead;</span><br><span class="line">                tHead&#x3D;q;</span><br><span class="line">                q&#x3D;pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">            lastTail.next&#x3D;temp;  &#x2F;&#x2F;这一步是为了当最后一部分少于m,也能接上.</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        i++;        </span><br><span class="line">        p&#x3D;tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除无序单链表中值重复出现的节点"><a href="#删除无序单链表中值重复出现的节点" class="headerlink" title="删除无序单链表中值重复出现的节点"></a>删除无序单链表中值重复出现的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一个无序单列表的头节点head,删除链表中值重复出现的节点.</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HashSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeRep</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    HashSet&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">    set.add(head.value());</span><br><span class="line">    Node pre=head;</span><br><span class="line">    Node p=head.next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!set.contains(p.value()))&#123;</span><br><span class="line">            set.add(p.value());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//删除p</span></span><br><span class="line">            pre.next=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 穷解法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeRep</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p=head;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Node q=p.next;</span><br><span class="line">        Node qre=p;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(q.value().equals(p.value()))&#123;</span><br><span class="line">                qre.next=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将搜索二叉树转成双向链表"><a href="#将搜索二叉树转成双向链表" class="headerlink" title="将搜索二叉树转成双向链表"></a>将搜索二叉树转成双向链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">题目: 对于二叉树节点来说,有本身的值域,有指向左孩子节点和右孩子节点的指针.</span><br><span class="line">      对于双向链表节点来说,有本身的值域,有指向上一个节点和下一个节点的指针.</span><br><span class="line">      <span class="comment">//二叉树节点</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">TNode</span></span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">          <span class="keyword">public</span> TNode left;</span><br><span class="line">          <span class="keyword">public</span> TNode right;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//双向链表节点</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">          <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">          <span class="keyword">public</span> Node next;</span><br><span class="line">          <span class="keyword">public</span> Node last;</span><br><span class="line">      &#125;</span><br><span class="line">  例如:</span><br><span class="line">           <span class="number">6</span></span><br><span class="line">        <span class="number">4</span>     <span class="number">7</span></span><br><span class="line">      <span class="number">2</span>   <span class="number">5</span>      <span class="number">9</span></span><br><span class="line">    <span class="number">1</span>   <span class="number">3</span>      <span class="number">8</span></span><br><span class="line"> 转为双向链表顺序: <span class="number">1</span>~<span class="number">9</span>(中序,且链表间的连接关系打乱)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">convert</span><span class="params">(TNode root)</span></span>&#123;</span><br><span class="line">        Queue &lt;TNode&gt;queue=<span class="keyword">new</span> LinkedList&lt;TNode&gt;();</span><br><span class="line">        traversalTree(node,queue);</span><br><span class="line">        TNode hd=queue.poll();</span><br><span class="line">        Node head=<span class="keyword">new</span> Node();</span><br><span class="line">        head.value=hd.value;</span><br><span class="line">        Node pre=hd;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TNode tNode=queue.poll();</span><br><span class="line">            Node node=<span class="keyword">new</span> Node();</span><br><span class="line">            node.value=tNode.value;</span><br><span class="line">            pre.right=node;</span><br><span class="line">            node.left=pre;</span><br><span class="line">            pre=node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traversalTree</span><span class="params">(TNode node,Queue queue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traversalTree(node.left,queue);</span><br><span class="line">        queue.offer(node);</span><br><span class="line">        traversalTree(node.right,queue);</span><br><span class="line">    &#125;</span><br><span class="line">解法二 !!!:</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纯递归</span></span><br><span class="line"><span class="comment"> * 对于x节点,先将x的左节点变成链表,再将x的右节点变为链表.</span></span><br><span class="line"><span class="comment"> * ps:为了美观,这里就不区分Node和TreeNode,统一用Node</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  每次递归返回的中间结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReturnType</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node start;</span><br><span class="line">    <span class="keyword">public</span> Node end;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReturnType</span><span class="params">(Node start,Node end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start=start;</span><br><span class="line">        <span class="keyword">this</span>.end=end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ReturnType <span class="title">process</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ReturnType(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnType left=process(node.left);</span><br><span class="line">    ReturnType right=process(node.right);</span><br><span class="line">    <span class="keyword">if</span>(left.end!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        left.end.next=node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right.start!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        right.start.last=node;</span><br><span class="line">    &#125;</span><br><span class="line">    node.last=left.end;</span><br><span class="line">    node.next=right.start;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReturnType(left==<span class="keyword">null</span>?node:left.start,right==<span class="keyword">null</span>?node:right.end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">process</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    ReturnType result=process(node);</span><br><span class="line">    <span class="keyword">return</span> result.start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表的选择排序"><a href="#单链表的选择排序" class="headerlink" title="单链表的选择排序"></a>单链表的选择排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一个无序单链表的头节点head,实现单链表的选择排序.</span><br><span class="line">要求: 额外的空间复杂度为O(1).</span><br><span class="line">难度: *</span><br><span class="line">public static Node selectionSort(Node head)&#123;</span><br><span class="line">    Node order&#x3D;null;</span><br><span class="line">    Node orederHead&#x3D;null;</span><br><span class="line">    while(head!&#x3D;null)&#123;</span><br><span class="line">        Node pre&#x3D;getSmallestPreNode(head);</span><br><span class="line">        Node p&#x3D;pre&#x3D;&#x3D;null?head:pre.next;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 更新无序的</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if(pre&#x3D;&#x3D;null)&#123;</span><br><span class="line">            head&#x3D;head.next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            pre.next&#x3D;p.next;    </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 更新有序的</span><br><span class="line">         *&#x2F;</span><br><span class="line">        if(order&#x3D;&#x3D;null)&#123;</span><br><span class="line">            orderHead&#x3D;order&#x3D;p;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            order.next&#x3D;p;</span><br><span class="line">            order&#x3D;p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return orderHead;</span><br><span class="line">&#125;</span><br><span class="line">public Node getSmallestPreNode(Node head)&#123;</span><br><span class="line">    Node pre&#x3D;null;</span><br><span class="line">    Node s&#x3D;head;</span><br><span class="line">    Node sPre&#x3D;null;</span><br><span class="line">    while(head!&#x3D;null)&#123;</span><br><span class="line">        if(s.value&lt;head.value)&#123;</span><br><span class="line">            s&#x3D;head;</span><br><span class="line">            sPre&#x3D;pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre&#x3D;head;</span><br><span class="line">        head&#x3D;head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return spre&#x3D;&#x3D;null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="向有序的环形单列表中插入新节点"><a href="#向有序的环形单列表中插入新节点" class="headerlink" title="向有序的环形单列表中插入新节点"></a>向有序的环形单列表中插入新节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一个升序的环形单链表的头节点和num,请将num插入到这个环形列表中,确保插入后的环形列表依然有序.</span><br><span class="line">难度: *</span><br><span class="line">要求: 时间复杂度O(N).</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">insertNum</span><span class="params">(Node head,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    Node p=head;</span><br><span class="line">    Node pre=<span class="keyword">null</span>;</span><br><span class="line">    Node n=<span class="keyword">new</span> Node(num);</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;<span class="keyword">return</span> n&#125;;</span><br><span class="line">    <span class="comment">//环形 p.next不会为null</span></span><br><span class="line">    <span class="keyword">while</span>(p.next!=head);</span><br><span class="line">    pre=p;</span><br><span class="line">    p=pre.next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num&lt;p.value)&#123;</span><br><span class="line">        pre.next=n;</span><br><span class="line">        n.next=head;</span><br><span class="line">        head=n;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    p=p.next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//p==head 说明绕了一圈了</span></span><br><span class="line">        <span class="keyword">if</span>(p==head||p.value&gt;=num)&#123;</span><br><span class="line">            pre.next=n;</span><br><span class="line">            n.next=p</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        p=p.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个有序的单链表"><a href="#合并两个有序的单链表" class="headerlink" title="合并两个有序的单链表"></a>合并两个有序的单链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">题目: 两个链表的头节点分别为head1和head2,请合并<span class="number">2</span>个有序链表.</span><br><span class="line">要求: 时间复杂度o(M+N)</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">merge</span><span class="params">(Node head1,Node head2)</span></span>&#123;</span><br><span class="line">    Node p1=head1;</span><br><span class="line">    Node p2=head2;</span><br><span class="line">    Node head=(head1==<span class="keyword">null</span>?head2:head1);</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head ==head1)&#123;</span><br><span class="line">        p1=p1.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        p2=p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    Node p=head;</span><br><span class="line">    <span class="keyword">while</span>(p1!=<span class="keyword">null</span>&amp;&amp;p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.value&lt;p2.value)&#123;</span><br><span class="line">            p.next=p1;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next=p2;</span><br><span class="line">            p2=p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next=p1==<span class="keyword">null</span>?p2:p1;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按照左右半区的方式重新组合单链表"><a href="#按照左右半区的方式重新组合单链表" class="headerlink" title="按照左右半区的方式重新组合单链表"></a>按照左右半区的方式重新组合单链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一个单链表的头节点head,链表长度为N.如果N为奇数,前N/<span class="number">2</span>算作左半区,后N/<span class="number">2</span>+<span class="number">1</span>算作后半区,若N为偶数,前N/<span class="number">2</span>算作左半区,后N/<span class="number">2</span>算作后半区.然后将作左半区与右半区交叉.</span><br><span class="line">例子:  <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>   &lt;=&gt; <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>   </span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relocate</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow=head;</span><br><span class="line">    Node fast=slow.next.next;</span><br><span class="line">    <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * head ~ slow --&gt; left</span></span><br><span class="line"><span class="comment">     * slow.next -&gt; ... --&gt; right</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node p=<span class="keyword">null</span>;</span><br><span class="line">    Node left=head;</span><br><span class="line">    Node right=slow.next;</span><br><span class="line">    <span class="comment">//left数量&lt;right数量</span></span><br><span class="line">    <span class="keyword">while</span>(left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">            p=left;</span><br><span class="line">            left=left.next;</span><br><span class="line">            p.next=right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next=left;</span><br><span class="line">            left=left.next;</span><br><span class="line">            p.next.next=right;</span><br><span class="line">        &#125;</span><br><span class="line">        p=right;</span><br><span class="line">        right=right.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树问题"><a href="#二叉树问题" class="headerlink" title="二叉树问题"></a>二叉树问题</h2><h3 id="用递归方式实现二叉树先序遍历"><a href="#用递归方式实现二叉树先序遍历" class="headerlink" title="用递归方式实现二叉树先序遍历"></a>用递归方式实现二叉树先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">题目:用递归的方式实现二叉树先序遍历.</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    System.out.print(head.data+<span class="string">"-"</span>);</span><br><span class="line">    preOrderRecur(head.left);</span><br><span class="line">    preOrderRecur(head.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用非递归的方式实现二叉树先序遍历"><a href="#用非递归的方式实现二叉树先序遍历" class="headerlink" title="用非递归的方式实现二叉树先序遍历"></a>用非递归的方式实现二叉树先序遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">题目:用非递归的方式实现二叉树的先序遍历</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用栈作为数据结构,右节点会压栈</span></span><br><span class="line"><span class="comment"> * 模拟方法栈帧的插入和弹出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderUnRecur</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">   Stack &lt;Node&gt;stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">   <span class="keyword">while</span>(!stack.isEmpty()||head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           System.out.println(head.value);</span><br><span class="line">           stack.push(head);</span><br><span class="line">           head=head.left;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           head=stack.pop();</span><br><span class="line">           head=head.right; </span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据二叉树先序遍历的结果还原二叉树"><a href="#根据二叉树先序遍历的结果还原二叉树" class="headerlink" title="根据二叉树先序遍历的结果还原二叉树"></a>根据二叉树先序遍历的结果还原二叉树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">题目:根据二叉树先序遍历的结果还原二叉树.</span><br><span class="line">难度: *</span><br><span class="line">ps: null用-9999表示</span><br><span class="line">public Node arrToTree(int []arr)&#123;</span><br><span class="line">    if(arr&#x3D;&#x3D;null||arr.length&#x3D;&#x3D;0) return null;</span><br><span class="line">    Queue&lt;Node&gt;queue&#x3D;new Queue&lt;Node&gt;();</span><br><span class="line">    for(int i&#x3D;0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        Node node&#x3D;new Node(arr[i]);</span><br><span class="line">        if(arr[i]&#x3D;&#x3D;-9999)&#123;</span><br><span class="line">            node&#x3D;null;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.offer(node);</span><br><span class="line">    &#125;</span><br><span class="line">    return slove(queue);</span><br><span class="line">&#125;</span><br><span class="line">public Node slove(Queue&lt;Node&gt;queue)&#123;</span><br><span class="line">    if(queue.isEmpty())&#123;return null;&#125;</span><br><span class="line">    Node p&#x3D;queue.pop();</span><br><span class="line">    if(p&#x3D;&#x3D;null) return null;</span><br><span class="line">    p.left&#x3D;slove(queue);</span><br><span class="line">    p.right&#x3D;slove(queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">题目:实现二叉树的层次遍历.</span><br><span class="line">难度:*</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelTraversal</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue &lt;Node&gt;queue=<span class="keyword">new</span> LinkedQueue();</span><br><span class="line">    queue.add(node);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Node p=queue.remove();</span><br><span class="line">        System.out.print(p.value+<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">if</span>(p.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(p.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.add(p.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据二叉树层次遍历的结果构造二叉树"><a href="#根据二叉树层次遍历的结果构造二叉树" class="headerlink" title="根据二叉树层次遍历的结果构造二叉树"></a>根据二叉树层次遍历的结果构造二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">题目: 根据二叉树层次遍历的结果构造二叉树</span><br><span class="line">难度: *</span><br><span class="line">ps: <span class="keyword">null</span> ---&gt; -<span class="number">9999</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">levelToTree</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="keyword">null</span>||arr.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;Node&gt;queue=<span class="keyword">new</span> Queue&lt;Node&gt;();</span><br><span class="line">    Node head=<span class="keyword">new</span> Node(arr[<span class="number">0</span>]);</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;index&lt;arr.length)&#123;</span><br><span class="line">        Node p=queue.poll();</span><br><span class="line">        p.left=arr[index++];</span><br><span class="line">        p.right=arr[index++];</span><br><span class="line">        <span class="keyword">if</span>(p.left!=<span class="keyword">null</span>)  queue.offer(p.left);</span><br><span class="line">        <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>) queue.offer(p.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">slove</span><span class="params">(Queue&lt;Node&gt;queue,Node p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(queue.isEmpty()||p==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    p.left=queue.poll();</span><br><span class="line">    p.right=queue.poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一颗二叉树的头节点head,求这颗二叉树的最大深度.</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(head.left==<span class="keyword">null</span>&amp;&amp;head.right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(head.left!=<span class="keyword">null</span>)  res=Math.max(res,<span class="number">1</span>+maxDepth(head.left));</span><br><span class="line">    <span class="keyword">if</span>(head.right!=<span class="keyword">null</span>) res=Math.max(res,<span class="number">1</span>+maxDepth(head.right));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一颗二叉树的头节点head,求二叉树的最小深度.</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(head.left==<span class="keyword">null</span>&amp;&amp;head.right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> min=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(head.left!=<span class="keyword">null</span>) min=Math.min(min,minDepth(head.left)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(head.right!=<span class="keyword">null</span>) min=Math.min(min,minDepth(head.right)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树节点的个数"><a href="#二叉树节点的个数" class="headerlink" title="二叉树节点的个数"></a>二叉树节点的个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">题目给定一颗二叉树的头节点head,求二叉树的节点个数</span><br><span class="line">难度: *</span><br><span class="line">public int  numberOfNodes(Node head)&#123;</span><br><span class="line">    if(head&#x3D;&#x3D;null) return 0;</span><br><span class="line">    if(head.left&#x3D;&#x3D;0&amp;&amp;head.right&#x3D;&#x3D;0) return 1;</span><br><span class="line">    int sum&#x3D;0;</span><br><span class="line">    if(head.left!&#x3D;null)  sum+&#x3D;numberOfNodes(head.left);</span><br><span class="line">    if(head.right!&#x3D;null) sum+&#x3D;numberOfNodes(head.right);</span><br><span class="line">    return sum+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何直观的打印二叉树"><a href="#如何直观的打印二叉树" class="headerlink" title="如何直观的打印二叉树"></a>如何直观的打印二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">题目:直观的打印二叉树</span><br><span class="line">难度: **</span><br><span class="line">例子:</span><br><span class="line">     <span class="number">1</span></span><br><span class="line">   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">   <span class="number">7</span></span><br><span class="line">打印(右在上,左在下)</span><br><span class="line">                    ^<span class="number">6</span>^</span><br><span class="line">          ^<span class="number">3</span>^</span><br><span class="line">                    v5v</span><br><span class="line">H1H</span><br><span class="line">                   </span><br><span class="line">          v2v    </span><br><span class="line">                          ^<span class="number">7</span>^</span><br><span class="line">                    v4v </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 右 中 左  逆向的中序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Binary Tree :"</span>);</span><br><span class="line">    printInOrder(head,<span class="number">0</span>,<span class="string">"H"</span>,<span class="number">17</span>);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printInOrder</span><span class="params">(Node head,<span class="keyword">int</span> height,String tag,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)  <span class="keyword">return</span>;</span><br><span class="line">    printInOrder(head.right,height+<span class="number">1</span>,<span class="string">"v"</span>,length);</span><br><span class="line">    String value=tag+head.value+tag;</span><br><span class="line">    <span class="keyword">int</span> lenM=val.length();</span><br><span class="line">    <span class="keyword">int</span> lenL=(length-lenM)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> lenR=length-lenM-lenL;</span><br><span class="line">    val=getSpace(lenL)+val+getSpace(lenR);</span><br><span class="line">    System.out.println(getSpace(height*length)+val);</span><br><span class="line">    printInOrder(head.left,height+<span class="number">1</span>,<span class="string">"^"</span>,length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getSpace</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    String space=<span class="string">" "</span>;</span><br><span class="line">    StringBuffer buf=<span class="keyword">new</span> StringBuffer(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">        buf.append(space);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在二叉树中找到累加和为指定值的最长路径长度"><a href="#在二叉树中找到累加和为指定值的最长路径长度" class="headerlink" title="在二叉树中找到累加和为指定值的最长路径长度"></a>在二叉树中找到累加和为指定值的最长路径长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一个二叉树的头节点为head和一个<span class="number">32</span>位整数sum,二叉树节点类型为整形,求累加和为sum的最长路径长度.</span><br><span class="line">难度: **</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用一个map&lt;key,value&gt;  key---&gt; 从root到当前节点的和(不能覆盖),value为第一次出现和的节点层数(不能覆盖).</span></span><br><span class="line"><span class="comment"> *  map[i].key -map[j].key = sum ---&gt;  j+1 ~ i 的层数是result</span></span><br><span class="line"><span class="comment"> *  j+1 不包括 root(0),所有必须先把root先放入</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxPathLength</span><span class="params">(Node head,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">preOrder</span><span class="params">(Node head,<span class="keyword">int</span> k,<span class="keyword">int</span> preSum,<span class="keyword">int</span> level,<span class="keyword">int</span> maxLen,HashMap&lt;Integer,Integer&gt;sumMap)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> maxLen;</span><br><span class="line">    <span class="keyword">int</span> sum=preSum+head.value();</span><br><span class="line">    <span class="keyword">if</span>(!sumMap.containsKey(sum))&#123;</span><br><span class="line">        sumMap.put(sum,level);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sumMap.containsKey(sum-k))&#123;</span><br><span class="line">        <span class="keyword">int</span> jLevel=sumMap.get(sum-k);</span><br><span class="line">        maxLen=Math.max(maxLen,level-jLevel+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    maxLen=preOrder(head.left,k,sum,level+<span class="number">1</span>,maxLen,sumMap);</span><br><span class="line">    maxLen=preOrder(head.right,k,sum,level+<span class="number">1</span>,maxLen,sumMap);</span><br><span class="line">    <span class="comment">//回溯删除该节点,避免树的不同路径(不同分支)的影响</span></span><br><span class="line">    <span class="keyword">if</span>(sumMap.get(sum)==level) sumMap.remove(sum);</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">题目: 二叉树被记录成文件的过程叫作二叉树的序列化.通过文件内容重建原来二叉树的过程叫做二叉树的反序列化.</span><br><span class="line">      在遍历的每个节点的值末尾加!,若为null节点,则用#表示值.</span><br><span class="line">难度: *</span><br><span class="line">方法一:先序遍历</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialByPre</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    <span class="keyword">return</span> head.value+<span class="string">"!"</span>+serialByPre(head.left)+serialByPre(head.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reconByPreString</span><span class="params">(String preStr)</span></span>&#123;</span><br><span class="line">    String[]values=preStr.split(<span class="string">"!"</span>);</span><br><span class="line">    Queue&lt;String&gt;queue=<span class="keyword">new</span> Queue&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str:values)&#123;</span><br><span class="line">        queue.offer(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">reconPreOrder</span><span class="params">(Queue&lt;String&gt;queue)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终点</span></span><br><span class="line">    <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String value=queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(value.equals(<span class="string">"#"</span>))   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node node=<span class="keyword">new</span> Node(value);</span><br><span class="line">    node.left=reconPreOder(queue);</span><br><span class="line">    node.right=reconPreOrder(queue);</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line">方法二:层次遍历</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialByLevel</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    String res=head.value+<span class="string">"!"</span>;</span><br><span class="line">    Queue&lt;Node&gt;queue=<span class="keyword">new</span> Queue&lt;Node&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Node p=queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(p.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res+=p.left.value+<span class="string">"!"</span>;</span><br><span class="line">            queue.offer(p.left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res+=<span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res+=p.right.value+<span class="string">"!"</span>;</span><br><span class="line">            queue.offer(p.right);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res+=<span class="string">"#!"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> * key--&gt;通过index索引决定孩子节点的位置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">deserialByLevel</span><span class="params">(String levelStr)</span></span>&#123;</span><br><span class="line">    String[]strs=levelStr.split(<span class="string">"!"</span>);</span><br><span class="line">    <span class="keyword">if</span>(strs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;Node&gt;queue=<span class="keyword">new</span> Queue&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    Node head=<span class="keyword">new</span> Node(strs[index++]);</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty()&amp;&amp;index&lt;strs.length)&#123;</span><br><span class="line">        Node p=queue.poll();</span><br><span class="line">        String left=str[index++];</span><br><span class="line">        <span class="keyword">if</span>(!left.equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            p.left=<span class="keyword">new</span> Node(left);</span><br><span class="line">            queue.offer(<span class="keyword">new</span> Node(left));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;strs.length)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String right=str[index++];</span><br><span class="line">        <span class="keyword">if</span>(!right.equals(<span class="string">"#"</span>))&#123;</span><br><span class="line">            p.right=<span class="keyword">new</span> Node(right);</span><br><span class="line">            queue.offer(<span class="keyword">new</span> Node(right));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的按层打印与ZigZag打印"><a href="#二叉树的按层打印与ZigZag打印" class="headerlink" title="二叉树的按层打印与ZigZag打印"></a>二叉树的按层打印与ZigZag打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一个二叉树的头节点head,分别实现按层和ZigZag打印二叉树的函数</span><br><span class="line">难度:**</span><br><span class="line">例子:</span><br><span class="line">        <span class="number">2</span></span><br><span class="line">      <span class="number">1</span>    <span class="number">3</span></span><br><span class="line">     <span class="number">4</span> <span class="number">8</span>  <span class="number">7</span> <span class="number">5</span></span><br><span class="line">输出:</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用last表示当前行的最右端,nLast表示下一行的最右端.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printByLevel</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>)   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Queue&lt;Node&gt;queue=<span class="keyword">new</span> LinkedQueue&lt;Node&gt;();</span><br><span class="line">    Node last=head;</span><br><span class="line">    Node nLast=<span class="keyword">null</span>;</span><br><span class="line">    Stack&lt;Node&gt;stack=<span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    stack.push(head);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">       Node p=stack.pop();</span><br><span class="line">       System.out.printf(<span class="string">" %d "</span>,p.data);</span><br><span class="line">       <span class="keyword">if</span>(p.left!=<span class="keyword">null</span>) stack.push(p.left);</span><br><span class="line">       <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>) stack.push(p.right);</span><br><span class="line">       nLast=stack.peek();</span><br><span class="line">       <span class="keyword">if</span>(p==last)&#123;</span><br><span class="line">           System.out.println();</span><br><span class="line">           last=NLast;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找搜索二叉树中两个错误的节点"><a href="#查找搜索二叉树中两个错误的节点" class="headerlink" title="查找搜索二叉树中两个错误的节点"></a>查找搜索二叉树中两个错误的节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">题目: 二叉树原本是搜索二叉树,但是其中有两个节点调换了位置,使得这颗二叉树不再是搜索二叉树(节点的左节点数比节点的数小,节点的右节点数比节点的数大).求找出<span class="number">2</span>个错误节点并返回</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路: 二叉树的中序遍历是递增的</span></span><br><span class="line"><span class="comment"> *                         较大    较小</span></span><br><span class="line"><span class="comment"> * 举个例子: --&gt;  p1 p2 p3 (p6) p5 (p4) p7 p8 p9 p10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Node [] getTwoErrNodes(Node head)&#123;</span><br><span class="line">    Node []errs= <span class="keyword">new</span> Node[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> errs;</span><br><span class="line">    Node pre=<span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//通过栈完成中序遍历</span></span><br><span class="line">    Stack&lt;Node&gt; stack=<span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()||head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;      <span class="comment">//节点进栈</span></span><br><span class="line">            stack.push(head);</span><br><span class="line">            head=head.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;               <span class="comment">//节点出栈</span></span><br><span class="line">            head=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(pre!=<span class="keyword">null</span>&amp;&amp;pre.value&gt;head.value)&#123;</span><br><span class="line">                <span class="keyword">if</span>(errs[<span class="number">0</span>]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    errs[<span class="number">0</span>]=pre;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    errs[<span class="number">1</span>]=head;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pre=head;<span class="comment">//更新pre节点</span></span><br><span class="line">            head=head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> *  递归的方式</span></span><br><span class="line"><span class="comment"> *  pre ---&gt;中序遍历的上一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node pre=<span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTwoErrNodes</span><span class="params">(Node head,Node []errs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> errs;</span><br><span class="line">    <span class="keyword">if</span>(head.left==<span class="keyword">null</span>&amp;&amp;head.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">if</span>(pre==<span class="keyword">null</span>)</span><br><span class="line">        pre=head; <span class="comment">//初始化pre</span></span><br><span class="line">    &#125; </span><br><span class="line">    getTwoErrNodes(head.left,errs);</span><br><span class="line">    <span class="keyword">if</span>(pre==head) <span class="keyword">return</span> errs; <span class="comment">//第一个节点没有pre</span></span><br><span class="line">    <span class="keyword">if</span>(pre.value&gt;head.value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(error[<span class="number">0</span>]==<span class="keyword">null</span>)&#123;</span><br><span class="line">            error[<span class="number">0</span>]=pre;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            error[<span class="number">1</span>]=head; <span class="comment">//其实到这里递归就因该结束了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=head;</span><br><span class="line">    getTwoErrNodes(head.right,errs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="进阶问题"><a href="#进阶问题" class="headerlink" title="进阶问题"></a>进阶问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">题目: 在上一题的基础上对搜索二叉树中交换的节点进行交换</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方式 基于栈遍历找到2个错误节点的parents</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Node [] getTwoErrParents(Node head,Node e1,Node e2)&#123;</span><br><span class="line">    Node []parents=<span class="keyword">new</span> Node[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> parents;</span><br><span class="line">    Stack&lt;Node&gt;stack=<span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()||head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head=head.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            head=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(head.left==e1||head.right==e1)&#123;</span><br><span class="line">                parents[<span class="number">0</span>]=head;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(head.left==e2||head.right==e2)&#123;</span><br><span class="line">                parents[<span class="number">1</span>]=head;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parents;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 书上说是有14种情况</span></span><br><span class="line"><span class="comment"> *  像2个错误节点中,存在父子的关系这种特殊情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Node []errs,Node[]parents)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先交换 2 个 errs 的子节点</span></span><br><span class="line">    Node left=errs[<span class="number">0</span>].left;</span><br><span class="line">    Node right=errs[<span class="number">0</span>].right;</span><br><span class="line">    errs[<span class="number">0</span>].left=errs[<span class="number">1</span>].left;</span><br><span class="line">    errs[<span class="number">0</span>].right=errs[<span class="number">1</span>].right;</span><br><span class="line">    errs[<span class="number">1</span>].left=left;</span><br><span class="line">    errs[<span class="number">1</span>].right=right;</span><br><span class="line">    <span class="keyword">if</span>(parents[<span class="number">0</span>].left==errs[<span class="number">0</span>])&#123;</span><br><span class="line">        parents[<span class="number">0</span>].left=errs[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(parents[<span class="number">1</span>].left==errs[<span class="number">1</span>])&#123;</span><br><span class="line">            parents[<span class="number">1</span>].left=errs[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parents[<span class="number">1</span>].right==errs[<span class="number">1</span>])&#123;</span><br><span class="line">            parents[<span class="number">1</span>].right=errs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parents[<span class="number">0</span>].right==errs[<span class="number">0</span>])&#123;</span><br><span class="line">        parents[<span class="number">0</span>].right=errs[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(parents[<span class="number">1</span>].left==errs[<span class="number">1</span>])&#123;</span><br><span class="line">            parents[<span class="number">1</span>].left=errs[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parents[<span class="number">1</span>].right==errs[<span class="number">1</span>])&#123;</span><br><span class="line">            parents[<span class="number">1</span>].right=errs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于递归找到2个错误节点的父节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">getTwoErrParents</span><span class="params">(Node node,Node []errs,Node[]parents)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">   getTwoErrParents(node.left,errs,parents);</span><br><span class="line">   <span class="keyword">if</span>(node.left==errs[<span class="number">0</span>]||node.right==errs[<span class="number">0</span>])&#123;</span><br><span class="line">       parents[<span class="number">0</span>]=errs[<span class="number">0</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(node.left==errs[<span class="number">1</span>]||node.right==errs[<span class="number">1</span>])&#123;</span><br><span class="line">       parents[<span class="number">1</span>]=errs[<span class="number">1</span>];</span><br><span class="line">   &#125;</span><br><span class="line">   getTwoErrParents(node.right,errs,parents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断t1树是否包含t2树"><a href="#判断t1树是否包含t2树" class="headerlink" title="判断t1树是否包含t2树"></a>判断t1树是否包含t2树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">题目: 判断t1这颗树是否包含t2这颗树</span><br><span class="line">难度: *</span><br><span class="line">例子:  </span><br><span class="line">        <span class="number">2</span>                    <span class="number">1</span></span><br><span class="line">      <span class="number">1</span>   <span class="number">4</span>                <span class="number">6</span>   <span class="number">8</span></span><br><span class="line">    <span class="number">6</span>  <span class="number">8</span>                  <span class="number">4</span></span><br><span class="line">   <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node t1,Node t2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(t1==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(t2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//在t1中找t2的根节点,通过层次遍历找.</span></span><br><span class="line">      Queue&lt;Node&gt; queue=<span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">      queue.add(t1);</span><br><span class="line">      <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">          t1=queue.pop();</span><br><span class="line">          <span class="keyword">if</span>(t1.equals(t2))&#123;</span><br><span class="line">              <span class="keyword">boolean</span> res=check(t1,t2);</span><br><span class="line">              <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(t1.left!=<span class="keyword">null</span>) queue.add(t1.left);</span><br><span class="line">          <span class="keyword">if</span>(t1.right!=<span class="keyword">null</span>) queue.add(t1.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  先序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Node t1,Node t2)</span></span>&#123;</span><br><span class="line">   <span class="comment">//t2为空不影响</span></span><br><span class="line">   <span class="keyword">if</span>(t2==<span class="keyword">null</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(t1==<span class="keyword">null</span>||!t1.equals(t2))&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> check(t1.left,t2.left)&amp;&amp;check(t1.right,t2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断t1树是否完全包含t2树的拓扑结构-把null也当成结构一部分"><a href="#判断t1树是否完全包含t2树的拓扑结构-把null也当成结构一部分" class="headerlink" title="判断t1树是否完全包含t2树的拓扑结构(把null也当成结构一部分)"></a>判断t1树是否完全包含t2树的拓扑结构(把null也当成结构一部分)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">题目: 判断t1树是否完全包含t2树的拓扑结构.</span><br><span class="line">难度: ***</span><br><span class="line">例子:</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>    <span class="number">3</span>                   <span class="number">2</span>                  <span class="number">2</span></span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span> <span class="number">6</span>  <span class="number">7</span>               <span class="number">4</span>    <span class="number">5</span>             <span class="number">4</span>    <span class="number">5</span>   </span><br><span class="line">   <span class="number">8</span> <span class="number">9</span>                      <span class="number">8</span>  <span class="number">9</span>                <span class="number">8</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法一:可以和上题一样,check方法改一下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Node t1,Node t2)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(t1==t2)&#123; <span class="comment">//解决null问题</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(t1==<span class="keyword">null</span>||t2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span>(t1.value!=t2.value)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> check(t1.left,t2.left)&amp;&amp;check(t1.right,t2.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解法二: 将树结构转换成字符串,再判断t2是不是t1的子串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">preOrder</span><span class="params">(Node p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String str=p.value+<span class="string">"!"</span>;</span><br><span class="line">    <span class="keyword">return</span> str+preOrder(p.left)+preOrder(p.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Node t1,Node t2)</span></span>&#123;</span><br><span class="line">    String str1=preOrder(t1);</span><br><span class="line">    String str2=preOrder(t2);</span><br><span class="line">    <span class="keyword">return</span> str1.contains(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断二叉树是否是平衡二叉树"><a href="#判断二叉树是否是平衡二叉树" class="headerlink" title="判断二叉树是否是平衡二叉树"></a>判断二叉树是否是平衡二叉树</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题目: 判断二叉树是否是平衡二叉树.平衡二叉树是指树的左节点树与树的右节点树的高度差不为1.</span><br><span class="line">难度: *</span><br><span class="line">boolean flag&#x3D;true; </span><br><span class="line">public int levelOfTreeNode(Node p)&#123;</span><br><span class="line">    if(p&#x3D;&#x3D;null) return 0;</span><br><span class="line">    int left&#x3D;levelOfTreeNode(p.left);</span><br><span class="line">    int right&#x3D;levelOfTreeNode(p.right);</span><br><span class="line">    if(left-right&gt;1||right-left)&#123;</span><br><span class="line">        flag&#x3D;false;</span><br><span class="line">    &#125;</span><br><span class="line">    return left &gt;right ?left+1:right+1;</span><br><span class="line">&#125;</span><br><span class="line">public boolean isAVLTree(Node head)&#123;</span><br><span class="line">    levelOfTreeNode(head);</span><br><span class="line">    return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="根据搜索二叉树后序数组重建搜索二叉树"><a href="#根据搜索二叉树后序数组重建搜索二叉树" class="headerlink" title="根据搜索二叉树后序数组重建搜索二叉树"></a>根据搜索二叉树后序数组重建搜索二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">题目:</span><br><span class="line">   <span class="number">1</span>.给定一个整数数组arr,判断arr是否可能是节点值类型为整形的搜索二叉树后续遍历的结果.</span><br><span class="line">   <span class="number">2</span>.如果整数数组arr是二叉树后序遍历的结果,请将arr构成搜索二叉树.</span><br><span class="line">例子:</span><br><span class="line">      <span class="number">8</span></span><br><span class="line">    <span class="number">4</span>   <span class="number">11</span>         ----&gt;     <span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">8</span>.</span><br><span class="line">   <span class="number">1</span> <span class="number">5</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line">判断方法: 以<span class="number">8</span>为分割点,切成<span class="number">1</span> <span class="number">5</span> <span class="number">4</span>,<span class="number">9</span> <span class="number">10</span> <span class="number">11</span>.判断<span class="number">1</span> <span class="number">5</span> <span class="number">4</span>是否比<span class="number">8</span>小,<span class="number">9</span> <span class="number">11</span> 是否比<span class="number">8</span>大. </span><br><span class="line">         以<span class="number">4</span>为分割点,以<span class="number">11</span>为分割点.</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPost</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(end==start)&#123;<span class="keyword">return</span> <span class="keyword">true</span>;&#125;</span><br><span class="line">   <span class="keyword">int</span> less=-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> more=end;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(arr[i]&lt;arr[end])&#123;</span><br><span class="line">           less=i;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="comment">//第一次</span></span><br><span class="line">           more=more==end?i:more;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 链表</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span>(less==-<span class="number">1</span>||more==end)&#123;</span><br><span class="line">       <span class="keyword">return</span> isPost(arr,start,end-<span class="number">1</span>);</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">if</span>(less!=more-<span class="number">1</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> isPost(arr,start,less)&amp;&amp;isPost(arr,more,end-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">postToBST</span><span class="params">(<span class="keyword">int</span> []posArray,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node=<span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">int</span> less=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> more=end;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;arr[end])&#123;</span><br><span class="line">            less=i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            more=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.value=posArray[end];</span><br><span class="line">    <span class="comment">//这是优化判断</span></span><br><span class="line">    <span class="keyword">if</span>(less==-<span class="number">1</span>||more==end)&#123;</span><br><span class="line">        <span class="comment">//链表</span></span><br><span class="line">        <span class="keyword">if</span>(less==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.right=postToBST(posArray,start,end-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(more==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.left=postToBST(posArray,start,end-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.left=postToBST(posArray,start,less);</span><br><span class="line">    node.right=postToBST(posArray,more,end-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断一个二叉树是否是搜索二叉树"><a href="#判断一个二叉树是否是搜索二叉树" class="headerlink" title="判断一个二叉树是否是搜索二叉树"></a>判断一个二叉树是否是搜索二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">题目: 判断一个二叉树是否是搜索二叉树(BST).</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中序遍历结果是升序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Stack&lt;Node&gt;stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">int</span> val=-<span class="number">1</span>*Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">boolean</span> result=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()||root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root=root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.val&lt;val)&#123;</span><br><span class="line">                result= <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            val=root.val;</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断一棵树是否是完全二叉树"><a href="#判断一棵树是否是完全二叉树" class="headerlink" title="判断一棵树是否是完全二叉树"></a>判断一棵树是否是完全二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">题目: 判断一颗树是否是完全二叉树(CBT).</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 层次遍历: </span></span><br><span class="line"><span class="comment"> *   若一个节点只存在右子节点   ----&gt;   false</span></span><br><span class="line"><span class="comment"> *   若一个节点只存在左子节点   ----&gt;   则该节点往后的所有节点都是叶子节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCBT</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">    Queue&lt;Node&gt;queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">boolean</span> result=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        Node p=queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(p.left==<span class="keyword">null</span>&amp;&amp;p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            result=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offser(p.left);</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                p=queue.pop();</span><br><span class="line">                <span class="keyword">if</span>(p.left!=<span class="keyword">null</span>||p.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    result=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!result)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            queue.offer(p.left);</span><br><span class="line">            queue.offer(p.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组和矩阵问题"><a href="#数组和矩阵问题" class="headerlink" title="数组和矩阵问题"></a>数组和矩阵问题</h2><h3 id="求全是正数数组累加和为指定值的最大子数组长度"><a href="#求全是正数数组累加和为指定值的最大子数组长度" class="headerlink" title="求全是正数数组累加和为指定值的最大子数组长度"></a>求全是正数数组累加和为指定值的最大子数组长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">题目:求全是正整数数据累加和为指定值的最大子数组长度</span><br><span class="line">难度:*</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间复杂度为 o(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;array.length)&#123;</span><br><span class="line">        temp+=arr[right];</span><br><span class="line">        <span class="keyword">if</span>(temp==sum)&#123;</span><br><span class="line">            result=Math.max(result,right-left+<span class="number">1</span>);</span><br><span class="line">            temp-=arr[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp&gt;sum)&#123;</span><br><span class="line">            temp-=arr[left++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求未排序数组中累加和为指定值的最大子数组长度"><a href="#求未排序数组中累加和为指定值的最大子数组长度" class="headerlink" title="求未排序数组中累加和为指定值的最大子数组长度"></a>求未排序数组中累加和为指定值的最大子数组长度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">题目:求未排序数组中累加和为指定值的最大子数组长度.</span><br><span class="line">难度:**</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * arr[i] ---&gt; 表示 从 o~i的sum</span></span><br><span class="line"><span class="comment"> * map&lt;key,value&gt; ---&gt; key ---&gt; arr[i](不会覆盖),value---&gt;i (不会覆盖)</span></span><br><span class="line"><span class="comment"> * arr[i] - arr[j] ==k  -&gt; j+1 ~ i 的和为k</span></span><br><span class="line"><span class="comment"> * 注意:要将 &lt;0,-1&gt; 放入map ----&gt;对应arr[i] == k 的特殊情况,因为 j+1不包括0,0位置会算不到.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> sum )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []arr=<span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        temp+=arr[i]; </span><br><span class="line">        arr[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Integer,Integer&gt;map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(arr[i]))&#123;</span><br><span class="line">            map.put(arr[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(arr[i]-sum))&#123;</span><br><span class="line">            <span class="keyword">int</span> j=map.get(arr[i]-sum);</span><br><span class="line">            result=Math.max((i-(j+<span class="number">1</span>)+<span class="number">1</span>),result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串数组拼接问题"><a href="#字符串数组拼接问题" class="headerlink" title="字符串数组拼接问题"></a>字符串数组拼接问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">问题: 有一个完全由正整数组成的数组,求由该数组拼接而成的最大的数问题</span><br><span class="line">难度: **</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">concatStrsArray</span><span class="params">(String[]strs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size=strs.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;size)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Long.parseLong(strs[index]+strs[index+<span class="number">1</span>]).compareTo(Long.parseLong(strs[index+<span class="number">1</span>]+strs[index]))&lt;<span class="number">0</span>)&#123;</span><br><span class="line">              String tmp=strs[index];</span><br><span class="line">              strs[index]=strs[index+<span class="number">1</span>];</span><br><span class="line">              strs[index+<span class="number">1</span>]=strs[index];</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.stream(strs).collect(Collectors.joining(<span class="string">""</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="按照从外向里以顺时针的顺序依次打印出每一个数字"><a href="#按照从外向里以顺时针的顺序依次打印出每一个数字" class="headerlink" title="按照从外向里以顺时针的顺序依次打印出每一个数字"></a>按照从外向里以顺时针的顺序依次打印出每一个数字</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">题目: 输入一个矩阵,按照从外向里以顺时针的顺序依次打印出每一个数字。</span><br><span class="line">难度: ***</span><br><span class="line">例:</span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span> </span><br><span class="line">   <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span> </span><br><span class="line">   <span class="number">9</span>   <span class="number">10</span>  <span class="number">11</span> <span class="number">12</span> </span><br><span class="line">   <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span> <span class="number">16</span> </span><br><span class="line">则依次打印出数字<span class="number">1</span>,  <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">10</span>.</span><br><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line">    <span class="keyword">if</span>(array.length==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">int</span> n = array.length,m = array[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">int</span> layers = (Math.min(n,m)-<span class="number">1</span>)/<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//这个是层数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;layers;i++)&#123;</span><br><span class="line">        <span class="comment">//m列数,n是行数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = i;k&lt;m-i; k++) result.add(array[i][k]);<span class="comment">//左至右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n-i;j++) result.add(array[j][m-i-<span class="number">1</span>]);<span class="comment">//右上至右下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=m-i-<span class="number">2</span>;(k&gt;=i)&amp;&amp;(n-i-<span class="number">1</span>!=i);k--) result.add(array[n-i-<span class="number">1</span>][k]);<span class="comment">//右至左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n-i-<span class="number">2</span>;(j&gt;i)&amp;&amp;(m-i-<span class="number">1</span>!=i);j--) result.add(array[j][i]);<span class="comment">//左下至左上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">问题: 通过冒泡排序将数组排序</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                arr[i+<span class="number">1</span>]=arr[i]+arr[i+<span class="number">1</span>];</span><br><span class="line">                arr[i]=arr[i+<span class="number">1</span>]-arr[i];</span><br><span class="line">                arr[i+<span class="number">1</span>]=arr[i+<span class="number">1</span>]-arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">问题: 通过选择排序将数组排序</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chooseSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> small=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[small])&#123;</span><br><span class="line">                small=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i]=arr[small]+arr[i];</span><br><span class="line">        arr[small]=arr[i]-arr[small];</span><br><span class="line">        arr[i]=arr[i]-arr[small];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">问题: 通过插入排序将数组排序</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=arr[i];</span><br><span class="line">        <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&gt;tmp)&#123;</span><br><span class="line">                arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arr[j+<span class="number">1</span>]=tmp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            arr[<span class="number">0</span>]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">问题: 通过归并排序将数组排序</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    recursionSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursionSort</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> head,<span class="keyword">int</span> tail)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head&gt;=tail)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(head+tail)/<span class="number">2</span>;</span><br><span class="line">    recursionSort(arr,head,mid);</span><br><span class="line">    recursionSort(arr,mid+<span class="number">1</span>,tail);</span><br><span class="line">    merge(arr,head,mid,tail);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> head,<span class="keyword">int</span> mid,<span class="keyword">int</span> tail )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []nArr=<span class="keyword">new</span> <span class="keyword">int</span>[tail-head+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=head;</span><br><span class="line">    <span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=tail)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">            nArr[index++]=arr[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nArr[index++]=arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        nArr[index++]=arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=mid)&#123;</span><br><span class="line">        nArr[index++]=arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.arrayCopy(nArr,<span class="number">0</span>,arr,head,tail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">题目: 通过快速排序对数组进行排序</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选最左端的元素为基准</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    sort(arr,start,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=end)&#123; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">int</span> index=partition(arr,start,end);</span><br><span class="line">    <span class="keyword">if</span>(index&gt;start)&#123;</span><br><span class="line">        sort(arr,start,index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;end)&#123;</span><br><span class="line">        sort(arr,index,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot=start;</span><br><span class="line">    <span class="keyword">int</span> i=start+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=end;</span><br><span class="line">    <span class="keyword">int</span> num=arr[pivot];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(arr[i]&lt;=arr[pivot]&amp;&amp;i&lt;j)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(arr[j]&gt;=arr[pivot]&amp;&amp;i&lt;j)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">          swap(arr,i,j);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// j是该数的最终位置</span></span><br><span class="line">    swap(arr,start,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=arr[i];</span><br><span class="line">    arr[i]=arr[j];</span><br><span class="line">    arr[j]=tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">问题: 通过堆排序算法对数组进行排序</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向下调整</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cLeft=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cRight=cLeft+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp=array[i];</span><br><span class="line">    <span class="keyword">int</span> max=cLeft;</span><br><span class="line">    <span class="keyword">while</span>(cLeft&lt;array.length)&#123;</span><br><span class="line">        max=cLeft;</span><br><span class="line">        <span class="keyword">if</span>(cRight&lt;array.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[cRight]&gt;array[cLeft])&#123;</span><br><span class="line">                max=cRight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[max]&lt;tmp) </span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        array[cLeft/<span class="number">2</span>]=array[max];</span><br><span class="line">        cLeft=max*<span class="number">2</span>;</span><br><span class="line">        cRight=cLeft+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max&lt;array.length)&#123;</span><br><span class="line">        array[max]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建最大堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span> []array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length/<span class="number">2</span>-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        adjustHeap(array,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> []array)</span></span>&#123;</span><br><span class="line">    buildMaxHeap(array);</span><br><span class="line">    <span class="keyword">int</span> length=array.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        swap(array,<span class="number">0</span>,length);</span><br><span class="line">        adjustHeap(array,<span class="number">0</span>);</span><br><span class="line">        length--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">问题: 通过希尔排序将整数数组进行排序</span><br><span class="line">难度: *</span><br><span class="line">例子: 比如  <span class="number">40</span>个数  ---&gt;  <span class="number">20</span> 组 ,[<span class="number">0</span>,<span class="number">20</span>]、[<span class="number">1</span>,<span class="number">21</span>]、..... [<span class="number">19</span>,<span class="number">39</span>]  ---&gt; <span class="number">10</span>组, [<span class="number">0</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>],[<span class="number">1</span>,<span class="number">11</span>,<span class="number">21</span>,<span class="number">31</span>],......[<span class="number">9</span>,<span class="number">19</span>,<span class="number">29</span>,<span class="number">39</span>]  ---&gt; <span class="number">5</span>组 [<span class="number">0</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>,<span class="number">35</span>]....[<span class="number">4</span>,<span class="number">9</span>,<span class="number">14</span>,<span class="number">19</span>,<span class="number">24</span>,<span class="number">29</span>,<span class="number">34</span>,<span class="number">39</span>] ---&gt;...</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> []array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap=(array.length+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//i表示第几组</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;gap;i++)&#123;</span><br><span class="line">         <span class="comment">//对每组使用插入排序</span></span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=i+gap;j&lt;array.length-gap;j+=gap)&#123;</span><br><span class="line">             <span class="keyword">int</span> k=j;</span><br><span class="line">             <span class="keyword">int</span> tmp=array[k];</span><br><span class="line">             <span class="keyword">while</span>(k&gt;=i)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(tmp&gt;array[k-gap])&#123;</span><br><span class="line">                     array[k]=tmp;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 array[k]=array[k-gap];</span><br><span class="line">                 k-=gap;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">if</span>(k&lt;i)&#123;</span><br><span class="line">                 array[i]=tmp;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">         gap/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">问题: 通过桶排序对数组进行排序</span><br><span class="line">难度: *</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> []bucketSort(<span class="keyword">int</span> []array)&#123;</span><br><span class="line">    <span class="keyword">int</span> max=Arrays.stream(array).max().getAsInt();</span><br><span class="line">    <span class="keyword">int</span> min=Arrays.stream(array).min().getAsInt();</span><br><span class="line">    <span class="keyword">int</span> bucketNum=(max-min)/<span class="number">5</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//每个桶的大小为5 个</span></span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt;buckets=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bucketNum;i++)&#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> ArrayList());</span><br><span class="line">    &#125;</span><br><span class="line">    Array.stream(array).forEach(number-&gt;&#123;</span><br><span class="line">        <span class="keyword">int</span> index=(number-min)/<span class="number">5</span>;</span><br><span class="line">        buckets.get(index).add(number);</span><br><span class="line">    &#125;);</span><br><span class="line">    buckets.stream().forEach(bucket-&gt;&#123;Collections.sort(bucket);&#125;);</span><br><span class="line">    <span class="keyword">return</span>   (<span class="keyword">int</span>[]) buckets.stream()  <span class="comment">//Stream&lt;List&lt;Integer&gt;&gt;</span></span><br><span class="line">                            .flatMap(Collection::stream) <span class="comment">//Stream&lt;Integer&gt;</span></span><br><span class="line">                            .collect(Collectors.toList()).toArray(); <span class="comment">//Object[]</span></span><br><span class="line">                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.将大规模问题拆分成小规模问题.</span><br><span class="line">2.将小规模问题的解合并成大规模问题的解</span><br></pre></td></tr></table></figure>
<h3 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一个有序的数组和一个目标值,返回目标值的位置.</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findIndex(array,<span class="number">0</span>,array.length-<span class="number">1</span>,target);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findIndex</span><span class="params">(<span class="keyword">int</span>[]array,<span class="keyword">int</span> start,<span class="keyword">int</span> end ,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end==start)&#123;</span><br><span class="line">        <span class="keyword">return</span> array[start]==target?start:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(start+end)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(target&gt;array[mid])&#123;</span><br><span class="line">        <span class="keyword">return</span> findIndex(array,mid+<span class="number">1</span>,end,target);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findIndex(array,start,mid,target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环赛日程表"><a href="#循环赛日程表" class="headerlink" title="循环赛日程表"></a>循环赛日程表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">问题: 有 n=<span class="number">2</span>^k个选手参加循环赛,请设计一个循环赛日程表,使得</span><br><span class="line">      <span class="number">1</span>.每个选手与其它n-<span class="number">1</span>个选手各赛一次.</span><br><span class="line">      <span class="number">2</span>.每个选手一天只能赛一次.</span><br><span class="line">      <span class="number">3</span>.循环赛一共有n-<span class="number">1</span>天.</span><br><span class="line">难度: *</span><br><span class="line">举例: 例如<span class="number">8</span>个人</span><br><span class="line">  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span></span><br><span class="line">  <span class="number">2</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">7</span></span><br><span class="line">  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">5</span>  <span class="number">6</span></span><br><span class="line">  <span class="number">4</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span></span><br><span class="line">  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line">  <span class="number">6</span>  <span class="number">5</span>  <span class="number">8</span>  <span class="number">7</span>  <span class="number">2</span>  <span class="number">1</span>  <span class="number">4</span>  <span class="number">3</span></span><br><span class="line">  <span class="number">7</span>  <span class="number">8</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">  <span class="number">8</span>  <span class="number">7</span>  <span class="number">6</span>  <span class="number">5</span>  <span class="number">4</span>  <span class="number">3</span>  <span class="number">2</span>  <span class="number">1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] getSchedule(<span class="keyword">int</span> n)&#123;</span><br><span class="line">    <span class="keyword">int</span> [][]schedule=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    schedule[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    schedule[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    schedule[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">2</span>;</span><br><span class="line">    schedule[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    slove(n,schedule);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * size是分治时候大小 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> [][]schedule)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    slove(size/<span class="number">2</span>,schedule);</span><br><span class="line">    <span class="keyword">int</span> n=size/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="comment">//右</span></span><br><span class="line">            arr[i][n+j]=arr[i][j]+n;</span><br><span class="line">            <span class="comment">//下</span></span><br><span class="line">            arr[i+n][j]=arr[i][j]+n;</span><br><span class="line">            <span class="comment">//右下</span></span><br><span class="line">            arr[i+n][j+m]=arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="合并排序"><a href="#合并排序" class="headerlink" title="合并排序"></a>合并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">题目: 使用归并排序对数组进行排序</span><br><span class="line">难度: *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[]array)</span></span>&#123;</span><br><span class="line">    slove(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3 4 5 6 7 8</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j-i==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(i+j)/<span class="number">2</span>;</span><br><span class="line">    slove(array,i,mid,size/<span class="number">2</span>);</span><br><span class="line">    slove(array,mid+<span class="number">1</span>,j,size/<span class="number">2</span>);</span><br><span class="line">    merge(array,i,mid,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> start,<span class="keyword">int</span> mid,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> []nArray=<span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=start,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i]&lt;=array[j])&#123;</span><br><span class="line">            nArray[index++]=array[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nArray[index++]=array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        nArray[index++]=array[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=end)&#123;</span><br><span class="line">        nArray[index++]=array[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    System.arrayCopy(nArray,<span class="number">0</span>,array,start,end-start+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">题目:  通过快速排序完成对数组的排序</span><br><span class="line">难度:  *</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> []arr)</span></span>&#123;</span><br><span class="line">    quickSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;=end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p=partition(arr,start,end);</span><br><span class="line">    swap(arr,start,p);</span><br><span class="line">    slove(arr,start,p-<span class="number">1</span>);</span><br><span class="line">    slove(arr,p+<span class="number">1</span>,end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=arr[start];</span><br><span class="line">    <span class="keyword">int</span> i=start+<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> j=end;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j&amp;&amp;arr[i++]&lt;=tmp);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j&amp;&amp;arr[j--]&gt;tmp);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;j) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">题目:汉诺塔问题.</span><br><span class="line">要求: 一次移动一个盘子,大盘不能移动到小盘子上.</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">//最上面为编号1,最下面为编号为N</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 思路: </span></span><br><span class="line"><span class="comment"> * 1.将n-1个盘移到tmp上</span></span><br><span class="line"><span class="comment"> * 2.将n号盘移到to上</span></span><br><span class="line"><span class="comment"> * 3.将n-1号盘移动到to上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hannoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> from,<span class="keyword">int</span> tmp,<span class="keyword">int</span> to)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将第一个盘子从from移动到tmp</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        move(<span class="number">1</span>,from,tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将n-1个盘  从from 使用to 到 tmp</span></span><br><span class="line">    hanoi(n-<span class="number">1</span>,from,to,tmp);</span><br><span class="line">    <span class="comment">//将第n个盘子移动到to</span></span><br><span class="line">    move(n,from,to);</span><br><span class="line">    <span class="comment">//将n-1个盘  从 tmp 使用 from 到to</span></span><br><span class="line">    hanoi(n-<span class="number">1</span>,tmp,from,to);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">动态规划法的关键点:</span><br><span class="line">    1.最优化原理.最优子结构.</span><br><span class="line">    2.子问题的重叠性. !!</span><br><span class="line">思路:</span><br><span class="line">   1.推导出公式,找出n和n-1的关系.</span><br><span class="line">   2.通过dp记录 1,2,3...n-1 方面计算n</span><br></pre></td></tr></table></figure>
<h3 id="走台阶问题"><a href="#走台阶问题" class="headerlink" title="走台阶问题"></a>走台阶问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">问题: 有n阶台阶,一个人每次上一级或者两级台阶,问有多少种走完n阶台阶的方法.</span><br><span class="line">难度: *</span><br><span class="line">公式:f(n) = f(<span class="number">0</span>)+f(<span class="number">1</span>)+...+f(n-<span class="number">2</span>)+f(n-<span class="number">1</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有点像Fibonacci Sequence</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt;dp=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    dp.put(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    dp.put(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;n;i++)&#123;</span><br><span class="line">        dp.put(i,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">          dp.put(i,dp.get(j)+dp.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp.get(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最小路径和问题"><a href="#最小路径和问题" class="headerlink" title="最小路径和问题"></a>最小路径和问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">题目: 给定一个矩阵m,从左上角开始每次只能向右或向下走,最后到达右下角的位置,路径中所有数字累加起来就是路径和,返回所有路径的最小路径和.</span><br><span class="line">难度: *</span><br><span class="line">例子:</span><br><span class="line">  <span class="number">1</span>   <span class="number">3</span>   <span class="number">5</span>   <span class="number">9</span></span><br><span class="line">  <span class="number">8</span>   <span class="number">1</span>   <span class="number">3</span>   <span class="number">4</span>           </span><br><span class="line">  <span class="number">5</span>   <span class="number">0</span>   <span class="number">6</span>   <span class="number">1</span>              ----&gt;   <span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">0</span></span><br><span class="line">  <span class="number">8</span>   <span class="number">8</span>   <span class="number">4</span>   <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathLength</span><span class="params">(<span class="keyword">int</span> [][]arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> [][]dp=<span class="keyword">new</span> <span class="keyword">int</span> [arr.length][arr[<span class="number">0</span>].length];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=arr[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i]=arr[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr[<span class="number">0</span>].length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">            dp[i][j]=Math.min(arr[i-<span class="number">1</span>][j],arr[i][j-<span class="number">1</span>])+arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr[arr.length-<span class="number">1</span>][arr[<span class="number">0</span>].length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子序列问题-LCS"><a href="#最长公共子序列问题-LCS" class="headerlink" title="最长公共子序列问题(LCS)"></a>最长公共子序列问题(LCS)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题目: 求<span class="number">2</span>个字符串数组的最长公共子序列.</span><br><span class="line">难度: **</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/15/algorithm/max-sequence.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public static int[][] generateDP(String s1,String s2)&#123;</span><br><span class="line">    int [][]dp&#x3D;new int [s1.length+1][s2.length+1];</span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;s1.length;i++)&#123;</span><br><span class="line">        dp[i][0]&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;0;i&lt;&#x3D;s2.length;i++)&#123;</span><br><span class="line">        dp[0][i]&#x3D;0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i&#x3D;1;i&lt;&#x3D;s1.length;i++)&#123;</span><br><span class="line">        for(int j&#x3D;1;j&lt;&#x3D;s2.length;j++)&#123;</span><br><span class="line">            if(s1.charAt(i)&#x3D;&#x3D;s2.charAt(j))&#123;</span><br><span class="line">                dp[i][j]&#x3D;dp[i-1][j-1]+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               dp[i][j]&#x3D;Math.max(dp[i-1][j],dp[i][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 递归的方式,比较麻烦</span><br><span class="line"> *&#x2F;</span><br><span class="line">public int gengerateDP(String s1,String s2,int i,int j,int [][]dp)&#123;</span><br><span class="line">    if(i&#x3D;&#x3D;0||j&#x3D;&#x3D;0)&#123;return 0&#125;;</span><br><span class="line">    if(s1.charAt(i)&#x3D;&#x3D;s2.charAt(j))&#123;</span><br><span class="line">        return gengerateDP(s1,s2,i,j,dp)+1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return dp[i][j]&#x3D;Math.max(gengerateDP(s1,s2,i-1,j,dp),gengerateDP(s1,s2,i,j-1,dp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 入口有1~n个,出口只有1个,所以从后向前遍历</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static String printSeq(int[][]dp,String s1)&#123;</span><br><span class="line">    int i&#x3D;dp.length-1;</span><br><span class="line">    int j&#x3D;dp[0].length-1;</span><br><span class="line">    StringBuilder sb&#x3D;new StringBuilder();</span><br><span class="line">    while(i&gt;&#x3D;1&amp;&amp;j&gt;&#x3D;1)&#123;</span><br><span class="line">        if(dp[i][j]&#x3D;&#x3D;dp[i-1][j-1])&#123;</span><br><span class="line">            sb.append(s1.charAt(i));</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            if(dp[i-1][j]&gt;dp[i][j-1])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dp[0][0]&#x3D;&#x3D;dp[1][1])&#123;</span><br><span class="line">        sb.append(s1.charAt(0));</span><br><span class="line">    &#125;</span><br><span class="line">    return sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">题目: 求<span class="number">2</span>个字符串的最长公共子串(ps: 连续字串)</span><br><span class="line">难度: *</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与最长公共子序列的差别在于dp的计算</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> [][]gengerteDP(String str1,String str2)&#123;</span><br><span class="line">    <span class="keyword">int</span> [][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[str1.length][str2.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.length;i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str2.length;j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;str1.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;str2.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1.charAt(i)==str2.charAt(j))&#123;</span><br><span class="line">               dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">printSeq</span><span class="params">(<span class="keyword">int</span> [][]dp,String str1,String str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> iMax=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> jMax=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str2.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]&gt;max)&#123;</span><br><span class="line">                max=dp[i][j];</span><br><span class="line">                i=iMax;</span><br><span class="line">                j=jMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(dp[iMax][jMax]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sb.append(dp[iMax][jMax]);</span><br><span class="line">        <span class="comment">//连续是斜的</span></span><br><span class="line">        iMax--;</span><br><span class="line">        jMax--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">题目: 一个背包固定的承重W,有N件物品,每件物品都有自己的价值和重量,分别记录在数组v和数组w中.</span><br><span class="line">      每件物品只能选择装入还是不装入背包,要求不超过背包承重的前提下,选出物品总价值最大.</span><br><span class="line">难度: *</span><br><span class="line">思路:</span><br><span class="line">   x是编号,y是背包剩余重量</span><br><span class="line">   dp[x][y]=max&#123;dp[x-<span class="number">1</span>][y],dp[x-<span class="number">1</span>][y-w[x]]+v[x]&#125;;   y&gt;=w[i]   剩余重量 &gt;= 物品质量  </span><br><span class="line">   dp[x][y]=dp[x-<span class="number">1</span>][y]                              y&lt;w[i]    剩余容量放不下</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非动态规划法求解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span>[]w,<span class="keyword">int</span> [] v,<span class="keyword">int</span> i,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||c&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(c&lt;w[i])&#123;<span class="comment">//放不下</span></span><br><span class="line">        <span class="keyword">return</span> slove(w,v,i-<span class="number">1</span>,c);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(slove(w,v,i-<span class="number">1</span>,c),v[i]+slove(w,v,i-<span class="number">1</span>,c-w[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 记忆法求解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> []w,<span class="keyword">int</span> []v,<span class="keyword">int</span> i,<span class="keyword">int</span> c,<span class="keyword">int</span> [][]memo)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||c&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//已经算过</span></span><br><span class="line">    <span class="keyword">if</span>(memo[i][c]!=<span class="number">0</span>) &#123;<span class="keyword">return</span> memo[i][c];&#125;</span><br><span class="line">    <span class="keyword">if</span>(c&lt;w[i])&#123;</span><br><span class="line">       <span class="keyword">return</span> memo[i][c]=slove(w,v,i-<span class="number">1</span>,c,memo); <span class="comment">//放不下</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slove=Math.max(slove(w,v,i-<span class="number">1</span>,c,memo),slove(w,v,i-<span class="number">1</span>,c-w[i],memo)+v[i]);  </span><br><span class="line">        <span class="keyword">return</span> memo[i][c]=slove;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态规划法</span></span><br><span class="line"><span class="comment"> * 比较难理解</span></span><br><span class="line"><span class="comment"> * v --&gt; 背包载重量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">slove</span><span class="params">(<span class="keyword">int</span> []w,<span class="keyword">int</span> []v,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp=<span class="keyword">new</span> <span class="keyword">int</span>[c+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="comment">//对于第0个物品而言,背包载重量从1-c变化时的价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        dp[i]=i&gt;=w[<span class="number">0</span>]?w[<span class="number">0</span>]:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对于第j个物品,背包载重量从1-c变化时的价值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;v.length;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            dp[i]=i&gt;=w[j]?Math.max(dp[i],dp[i-w[j]]+v[j]):dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
		<div>
			
				<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

			
		</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/algorithm/" rel="tag"># algorithm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2019/12/16/spring/" rel="next" title="spring">
      spring <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#栈和队列"><span class="nav-number">1.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#设计一个有getMin功能的栈"><span class="nav-number">1.1.</span> <span class="nav-text">设计一个有getMin功能的栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#由两个栈组成的队列"><span class="nav-number">1.2.</span> <span class="nav-text">由两个栈组成的队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何仅用递归函数和栈操作逆序一个栈"><span class="nav-number">1.3.</span> <span class="nav-text">如何仅用递归函数和栈操作逆序一个栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用一个栈实现另一个栈的排序"><span class="nav-number">1.4.</span> <span class="nav-text">用一个栈实现另一个栈的排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#汉诺塔问题"><span class="nav-number">1.5.</span> <span class="nav-text">汉诺塔问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成窗口的最大值数组"><span class="nav-number">1.6.</span> <span class="nav-text">生成窗口的最大值数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求最大子矩阵大小"><span class="nav-number">1.7.</span> <span class="nav-text">求最大子矩阵大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最大值减去最小值小于或等于num的子数组数量"><span class="nav-number">1.8.</span> <span class="nav-text">最大值减去最小值小于或等于num的子数组数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中缀表达式转后缀表达式"><span class="nav-number">1.9.</span> <span class="nav-text">中缀表达式转后缀表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链表问题"><span class="nav-number">2.</span> <span class="nav-text">链表问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两个有序链表的公共部分"><span class="nav-number">2.1.</span> <span class="nav-text">两个有序链表的公共部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断两个链表是否相交"><span class="nav-number">2.2.</span> <span class="nav-text">判断两个链表是否相交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断一个链表是否存在环"><span class="nav-number">2.3.</span> <span class="nav-text">判断一个链表是否存在环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在单列表中删除倒数第K个节点"><span class="nav-number">2.4.</span> <span class="nav-text">在单列表中删除倒数第K个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在双列表中删除到数第K个节点"><span class="nav-number">2.5.</span> <span class="nav-text">在双列表中删除到数第K个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除链表的中间节点"><span class="nav-number">2.6.</span> <span class="nav-text">删除链表的中间节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除a-b处的节点"><span class="nav-number">2.7.</span> <span class="nav-text">删除a&#x2F;b处的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反转单向链表"><span class="nav-number">2.8.</span> <span class="nav-text">反转单向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反转双向链表"><span class="nav-number">2.9.</span> <span class="nav-text">反转双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反转部分单向列表"><span class="nav-number">2.10.</span> <span class="nav-text">反转部分单向列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#环形单列表的约瑟夫环问题"><span class="nav-number">2.11.</span> <span class="nav-text">环形单列表的约瑟夫环问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断一个链表是否为回文结构"><span class="nav-number">2.12.</span> <span class="nav-text">判断一个链表是否为回文结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将单向列表按给定位置划分成左边小-中间相等-右边大的形式"><span class="nav-number">2.13.</span> <span class="nav-text">将单向列表按给定位置划分成左边小,中间相等,右边大的形式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制含有随机指针节点的链表"><span class="nav-number">2.14.</span> <span class="nav-text">复制含有随机指针节点的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两个单列表生成相加列表"><span class="nav-number">2.15.</span> <span class="nav-text">两个单列表生成相加列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将单列表的每k个节点逆序"><span class="nav-number">2.16.</span> <span class="nav-text">将单列表的每k个节点逆序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除无序单链表中值重复出现的节点"><span class="nav-number">2.17.</span> <span class="nav-text">删除无序单链表中值重复出现的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将搜索二叉树转成双向链表"><span class="nav-number">2.18.</span> <span class="nav-text">将搜索二叉树转成双向链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单链表的选择排序"><span class="nav-number">2.19.</span> <span class="nav-text">单链表的选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向有序的环形单列表中插入新节点"><span class="nav-number">2.20.</span> <span class="nav-text">向有序的环形单列表中插入新节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并两个有序的单链表"><span class="nav-number">2.21.</span> <span class="nav-text">合并两个有序的单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按照左右半区的方式重新组合单链表"><span class="nav-number">2.22.</span> <span class="nav-text">按照左右半区的方式重新组合单链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二叉树问题"><span class="nav-number">3.</span> <span class="nav-text">二叉树问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用递归方式实现二叉树先序遍历"><span class="nav-number">3.1.</span> <span class="nav-text">用递归方式实现二叉树先序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用非递归的方式实现二叉树先序遍历"><span class="nav-number">3.2.</span> <span class="nav-text">用非递归的方式实现二叉树先序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据二叉树先序遍历的结果还原二叉树"><span class="nav-number">3.3.</span> <span class="nav-text">根据二叉树先序遍历的结果还原二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的层次遍历"><span class="nav-number">3.4.</span> <span class="nav-text">二叉树的层次遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据二叉树层次遍历的结果构造二叉树"><span class="nav-number">3.5.</span> <span class="nav-text">根据二叉树层次遍历的结果构造二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的最大深度"><span class="nav-number">3.6.</span> <span class="nav-text">二叉树的最大深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的最小深度"><span class="nav-number">3.7.</span> <span class="nav-text">二叉树的最小深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树节点的个数"><span class="nav-number">3.8.</span> <span class="nav-text">二叉树节点的个数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何直观的打印二叉树"><span class="nav-number">3.9.</span> <span class="nav-text">如何直观的打印二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在二叉树中找到累加和为指定值的最长路径长度"><span class="nav-number">3.10.</span> <span class="nav-text">在二叉树中找到累加和为指定值的最长路径长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的序列化和反序列化"><span class="nav-number">3.11.</span> <span class="nav-text">二叉树的序列化和反序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树的按层打印与ZigZag打印"><span class="nav-number">3.12.</span> <span class="nav-text">二叉树的按层打印与ZigZag打印</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查找搜索二叉树中两个错误的节点"><span class="nav-number">3.13.</span> <span class="nav-text">查找搜索二叉树中两个错误的节点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进阶问题"><span class="nav-number">3.13.1.</span> <span class="nav-text">进阶问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断t1树是否包含t2树"><span class="nav-number">3.14.</span> <span class="nav-text">判断t1树是否包含t2树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断t1树是否完全包含t2树的拓扑结构-把null也当成结构一部分"><span class="nav-number">3.15.</span> <span class="nav-text">判断t1树是否完全包含t2树的拓扑结构(把null也当成结构一部分)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断二叉树是否是平衡二叉树"><span class="nav-number">3.16.</span> <span class="nav-text">判断二叉树是否是平衡二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据搜索二叉树后序数组重建搜索二叉树"><span class="nav-number">3.17.</span> <span class="nav-text">根据搜索二叉树后序数组重建搜索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断一个二叉树是否是搜索二叉树"><span class="nav-number">3.18.</span> <span class="nav-text">判断一个二叉树是否是搜索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断一棵树是否是完全二叉树"><span class="nav-number">3.19.</span> <span class="nav-text">判断一棵树是否是完全二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组和矩阵问题"><span class="nav-number">4.</span> <span class="nav-text">数组和矩阵问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#求全是正数数组累加和为指定值的最大子数组长度"><span class="nav-number">4.1.</span> <span class="nav-text">求全是正数数组累加和为指定值的最大子数组长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#求未排序数组中累加和为指定值的最大子数组长度"><span class="nav-number">4.2.</span> <span class="nav-text">求未排序数组中累加和为指定值的最大子数组长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串数组拼接问题"><span class="nav-number">4.3.</span> <span class="nav-text">字符串数组拼接问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#按照从外向里以顺时针的顺序依次打印出每一个数字"><span class="nav-number">4.4.</span> <span class="nav-text">按照从外向里以顺时针的顺序依次打印出每一个数字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#排序问题"><span class="nav-number">5.</span> <span class="nav-text">排序问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#冒泡排序"><span class="nav-number">5.1.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选择排序"><span class="nav-number">5.2.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插入排序"><span class="nav-number">5.3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序"><span class="nav-number">5.4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序"><span class="nav-number">5.5.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#堆排序"><span class="nav-number">5.6.</span> <span class="nav-text">堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#希尔排序"><span class="nav-number">5.7.</span> <span class="nav-text">希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桶排序"><span class="nav-number">5.8.</span> <span class="nav-text">桶排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分治算法"><span class="nav-number">6.</span> <span class="nav-text">分治算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#二分搜索"><span class="nav-number">6.1.</span> <span class="nav-text">二分搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环赛日程表"><span class="nav-number">6.2.</span> <span class="nav-text">循环赛日程表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并排序"><span class="nav-number">6.3.</span> <span class="nav-text">合并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速排序-1"><span class="nav-number">6.4.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#汉诺塔"><span class="nav-number">6.5.</span> <span class="nav-text">汉诺塔</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态规划法"><span class="nav-number">7.</span> <span class="nav-text">动态规划法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#走台阶问题"><span class="nav-number">7.1.</span> <span class="nav-text">走台阶问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最小路径和问题"><span class="nav-number">7.2.</span> <span class="nav-text">最小路径和问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子序列问题-LCS"><span class="nav-number">7.3.</span> <span class="nav-text">最长公共子序列问题(LCS)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长公共子串"><span class="nav-number">7.4.</span> <span class="nav-text">最长公共子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#0-1背包问题"><span class="nav-number">7.5.</span> <span class="nav-text">0&#x2F;1背包问题</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vicyor"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">vicyor</p>
  <div class="site-description" itemprop="description">大路且慢慢,咱一步一步走完.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vicyor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vicyor" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2457569580@qq.com" title="E-Mail → mailto:2457569580@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vicyor</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">911k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:48</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=m9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'm9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz',
            'X-LC-Key': 'g7WSuE6aDmunoX4rgyBN7SJa',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'qQhr9rNGJh6YalJA0mfaaurx-gzGzoHsz',
    appKey: 'kJy8NJeOTMPnxQ3zLihOcnw3',
    placeholder: "请留下您的宝贵评论",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

	
		 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
		 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
		 <script type="text/javascript" src="/js/src/fireworks.js"></script>
	
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
