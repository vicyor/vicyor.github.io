<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://vicyor.gitee.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="学习&lt;&lt;深入拆解JAVA虚拟机&gt;&gt;这门课所做的笔记，只记录部分,像JIT编译器后端编译器对IR处理等(知道太少,就不记录了).">
<meta property="og:type" content="article">
<meta property="og:title" content="java_virtual_machine">
<meta property="og:url" content="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/index.html">
<meta property="og:site_name" content="Vicyor">
<meta property="og:description" content="学习&lt;&lt;深入拆解JAVA虚拟机&gt;&gt;这门课所做的笔记，只记录部分,像JIT编译器后端编译器对IR处理等(知道太少,就不记录了).">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/swdt.jpg">
<meta property="og:image" content="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/method_table.jpg">
<meta property="og:image" content="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/inline.jpg">
<meta property="og:image" content="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/finally.jpg">
<meta property="og:image" content="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/lock.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/JITCompiler.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/javacompile.png">
<meta property="article:published_time" content="2020-05-30T00:09:28.000Z">
<meta property="article:modified_time" content="2020-12-15T15:56:41.887Z">
<meta property="article:author" content="vicyor">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/swdt.jpg">

<link rel="canonical" href="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>java_virtual_machine | Vicyor</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vicyor</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">54</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">61</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vicyor.gitee.io/2020/05/30/java-virtual-machine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="vicyor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vicyor">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java_virtual_machine
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-30 08:09:28" itemprop="dateCreated datePublished" datetime="2020-05-30T08:09:28+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-15 23:56:41" itemprop="dateModified" datetime="2020-12-15T23:56:41+08:00">2020-12-15</time>
              </span>

          
            <span id="/2020/05/30/java-virtual-machine/" class="post-meta-item leancloud_visitors" data-flag-title="java_virtual_machine" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/05/30/java-virtual-machine/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/05/30/java-virtual-machine/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>60k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>54 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>学习&lt;&lt;深入拆解JAVA虚拟机&gt;&gt;这门课所做的笔记，只记录部分,像JIT编译器后端编译器对IR处理等(知道太少,就不记录了).</p>
<a id="more"></a>
<p><img src="/2020/05/30/java-virtual-machine/swdt.jpg" alt></p>
<h2 id="JAVA虚拟机基本原理"><a href="#JAVA虚拟机基本原理" class="headerlink" title="JAVA虚拟机基本原理"></a>JAVA虚拟机基本原理</h2><h3 id="JAVA代码如何运行"><a href="#JAVA代码如何运行" class="headerlink" title="JAVA代码如何运行"></a>JAVA代码如何运行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Java virtual Machine -&gt; 代码可移植性、代码托管(例如自动内存管理).</span><br><span class="line">2.JDK.HostSpot采用混合执行策略 -&gt; 解释执行+ 及时编译(JIT Compiler).</span><br></pre></td></tr></table></figure>
<h4 id="JAVA语言与C语言运行方式"><a href="#JAVA语言与C语言运行方式" class="headerlink" title="JAVA语言与C语言运行方式"></a>JAVA语言与C语言运行方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.C语言直接编译成机器可读的机器码.</span><br><span class="line">2.JAVA语言是Java编译器(Java Compiler)将源代码编译成字节码,JRE(JVM+核心类库)的JVM可以解释执行字节码.</span><br><span class="line">    字节码(Byte Code) -&gt; Java字节码指令的操作码(opcode)固定为1个字节.</span><br><span class="line">3.java    机器码 &lt;-&gt; 字节码</span><br><span class="line">最左列是偏移；中间列是给虚拟机读的机器码；最右列是给人读的代码</span><br><span class="line">0x00:  b2 00 02         getstatic java.lang.System.out</span><br><span class="line">0x03:  12 03            ldc &quot;Hello, World!&quot;</span><br><span class="line">0x05:  b6 00 04         invokevirtual java.io.PrintStream.println</span><br><span class="line">0x08:  b1               return</span><br><span class="line">4.JAVA -&gt; Compile once, run everywhere.(可移植性) </span><br><span class="line">5.JVM -&gt; 托管环境(Managed Runtime) -&gt; 自动内存管理、垃圾回收.</span><br></pre></td></tr></table></figure>
<h4 id="Java-虚拟机具体运行JAVA字节码"><a href="#Java-虚拟机具体运行JAVA字节码" class="headerlink" title="Java 虚拟机具体运行JAVA字节码"></a>Java 虚拟机具体运行JAVA字节码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">以JDK的HotSpot虚拟机为例进行说明.</span><br><span class="line">虚拟机加载class文件.</span><br><span class="line">    1.加载后的class文件会被放入到方法区(Method Area)中. (taps: 加载,[验证],链接(符号链接-直接链接),[初始化]).</span><br><span class="line">    2.每调用一个方法时候,虚拟机会在当前线程的方法栈中生成一个栈帧(局部变量表、操作栈、动态连接、返回地址).</span><br><span class="line">      taps: 栈帧大小提取计算完毕.栈帧在内存空间连续分布.</span><br><span class="line">    3.方法执行.</span><br><span class="line">        方式一.解释执行.从Method对应的Code属性中获取字节码指令,将字节码指令解释成机器指令后执行. 优势:立刻执行.</span><br><span class="line">        方式二.即时编译.将方法中的所有字节码先编译成机器码,然后再执行. 优势:执行速度快.</span><br><span class="line">     taps: HotSpot采用混合模式,综合了解释执行与即时编译两者的优点,先解释执行字节码,反复执行热点代码,以方法为单位进行即使编译.</span><br></pre></td></tr></table></figure>
<h4 id="Java虚拟机的运行效率"><a href="#Java虚拟机的运行效率" class="headerlink" title="Java虚拟机的运行效率"></a>Java虚拟机的运行效率</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.二八定律-&gt;20%的代码占据了80%的计算资源.</span><br><span class="line">    对于小部分的热点代码,可以将其编译成机器码,以达到理想的运行速度.</span><br><span class="line">    taps:由于及时编译器的优化,编译后Java代码的执行效率,有可能超过C++程序(JIT编译器会优化).</span><br><span class="line">2.C1与C2和Graal(Java10).</span><br><span class="line">    C1 -&gt;Client Compiler,面向对启动性能有要求的客户端GUI程序.编译时间较短,优化手段简单.</span><br><span class="line">    C2 -&gt;Server Compiler,面向对峰值性能有要求的服务端程序,编译时间长,优化手段复杂.生成代码的执行效率较高.</span><br><span class="line">    taps:从Java7开始,HotSpot采用分层编译的方式,热点方法首先会被C1编译,而后热点方法中的热点会进一步被C2编译.</span><br><span class="line">    taps:HotSpot的即时编译由编译线程进行编译,C1与C2对应的编译线程比为1:2.</span><br><span class="line">    taps:编译后的代码再下次调用该方法时启用,会替换原本的解释执行.</span><br></pre></td></tr></table></figure>
<h4 id="小作业"><a href="#小作业" class="headerlink" title="小作业"></a>小作业</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">下载asmtools.jar(修改和生成class文件),并在命令行中运行下述指令.</span><br><span class="line">$ echo &#39;</span><br><span class="line">public class Foo &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">  boolean flag &#x3D; true;</span><br><span class="line">  if (flag) System.out.println(&quot;Hello, Java!&quot;);</span><br><span class="line">  if (flag &#x3D;&#x3D; true) System.out.println(&quot;Hello, JVM!&quot;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;&#39; &gt; Foo.java</span><br><span class="line">$ javac Foo.java</span><br><span class="line">$ java Foo</span><br><span class="line">$ java -cp &#x2F;path&#x2F;to&#x2F;asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm.1</span><br><span class="line">$ awk &#39;NR&#x3D;&#x3D;1,&#x2F;iconst_1&#x2F;&#123;sub(&#x2F;iconst_1&#x2F;, &quot;iconst_2&quot;)&#125; 1&#39; Foo.jasm.1 &gt; Foo.jasm</span><br><span class="line">$ java -cp &#x2F;path&#x2F;to&#x2F;asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm</span><br><span class="line">$ java Foo</span><br><span class="line">解析:</span><br><span class="line">jvm 将true 当成iconst_1,</span><br><span class="line">if(flag) -&gt;jvm判断flag是否为iconst_0，不为iconst_0就执行.</span><br><span class="line">if(flag&#x3D;&#x3D;ture) -&gt;由于awk将iconst_1改成了iconst_2,所以,flag&#x3D;&#x3D;ture及iconst_2&#x3D;&#x3D;iconst_1为假.不执行.</span><br></pre></td></tr></table></figure>
<h3 id="Java的基本类型"><a href="#Java的基本类型" class="headerlink" title="Java的基本类型"></a>Java的基本类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.基本类型由虚拟机预先定义.</span><br><span class="line">2.boolean -&gt; 整数 </span><br><span class="line">    true -&gt; 1</span><br><span class="line">    false -&gt; 0</span><br><span class="line">3.float&#x2F;double -&gt; +0.0f,-0.0f,NAN</span><br><span class="line">4.局部变量表-&gt;1个单元8字节.</span><br><span class="line">5.操作数栈 -&gt; 1个单元8字节.</span><br><span class="line">6.基本数据类型优势在于其存储空间比对象小,而且可以重复利用.</span><br></pre></td></tr></table></figure>
<h4 id="Java虚拟机的boolean"><a href="#Java虚拟机的boolean" class="headerlink" title="Java虚拟机的boolean"></a>Java虚拟机的boolean</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在Java虚拟机规范中,boolean类型被映射成int类型,true -&gt; 1,false -&gt; 0</span><br><span class="line">2.对于if语句的判断.</span><br><span class="line">  if(flag) -&gt; ifeq -&gt;条件为iconst_0则跳转.</span><br><span class="line">  if(flag&#x3D;&#x3D;true) -&gt; if_icmpne -&gt; &#x3D;两边参数不相等则跳转</span><br></pre></td></tr></table></figure>
<h4 id="其它的基本数据类型"><a href="#其它的基本数据类型" class="headerlink" title="其它的基本数据类型"></a>其它的基本数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">taps:javac编译器会对这些变量做类型检查</span><br><span class="line">boolean -&gt; 0(false),1(true)</span><br><span class="line">char    -&gt; [0,65535]</span><br><span class="line">浮点数</span><br><span class="line">float   -&gt; IEEE 754</span><br><span class="line">  +0.0f -&gt; 0x0000000</span><br><span class="line">  -0.0f -&gt; 0x8000000</span><br><span class="line">  正无穷-&gt; 0x7F80000</span><br><span class="line">  负无穷-&gt; 0xFF80000</span><br><span class="line">  NAN   -&gt;0x7F800001~0x7FFFFFFF</span><br></pre></td></tr></table></figure>
<h4 id="Java基本类型的大小"><a href="#Java基本类型的大小" class="headerlink" title="Java基本类型的大小"></a>Java基本类型的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.局部变量区 -&gt; 数组</span><br><span class="line">    boolean,byte,char,short,int -&gt;一个数组单元(8Byte-64位hotpot)</span><br><span class="line">    long,double                 -&gt;二个数组单元(16Byte-64位hotpot)</span><br><span class="line">    taps:堆中byte1个字节,char 2个字节...</span><br><span class="line">2.操作数栈 -&gt;算术运算</span><br><span class="line">    taps:下面是指堆中到操作数栈中会扩展,局部变量表的不需要扩展</span><br><span class="line">    boolean、char 零扩展(扩展为int)</span><br><span class="line">    byte、short  符号扩展</span><br></pre></td></tr></table></figure>
<h4 id="小作业-1"><a href="#小作业-1" class="headerlink" title="小作业"></a>小作业</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">boolean</span> boolValue;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    boolValue = <span class="keyword">true</span>; <span class="comment">// 将这个true替换为2或者3，再看看打印结果</span></span><br><span class="line">    <span class="keyword">if</span> (boolValue) System.out.println(<span class="string">"Hello, Java!"</span>);</span><br><span class="line">    <span class="keyword">if</span> (boolValue == <span class="keyword">true</span>) System.out.println(<span class="string">"Hello, JVM!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">taps: jvm在<span class="keyword">boolean</span>实际存储时候只取二进制最后一位(<span class="keyword">boolean</span>的掩码操作)，所以 boolValue=<span class="number">3</span> -&gt;boolValue=<span class="number">1</span>-&gt;boolValue==<span class="keyword">true</span> ; boolValue=<span class="number">2</span> -&gt;boolValue=<span class="number">0</span> -&gt;boolValue=<span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Java虚拟机是如何加载Java类"><a href="#Java虚拟机是如何加载Java类" class="headerlink" title="Java虚拟机是如何加载Java类"></a>Java虚拟机是如何加载Java类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.类型 -&gt; 基本类型 + 引用类型</span><br><span class="line">2.引用类型 -&gt; 类,接口,数组,泛型</span><br><span class="line">3.双亲委派机制 -&gt; 从上往下的加载过程,防止重复加载. 双亲并不是继承关系,只是逻辑上的双亲.</span><br><span class="line">4.JVM将字节流转化为Java类过程.</span><br><span class="line">    加载  -&gt; 默认双亲委派</span><br><span class="line">    链接  -&gt; 验证,准备(static给空间,生成类的方法表),解析(符号引用-&gt;直接引用)</span><br><span class="line">    初始化-&gt;&lt;Clinit&gt;,ConstValue</span><br></pre></td></tr></table></figure>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">taps: 数组类没有对应的字节流,由java虚拟机直接生成.其它的对象类,Java虚拟机借助类加载器加载字节流.</span><br><span class="line">taps: 加载具体是根据字节流去获取class文件,生成class对象,将类相关信息放入方法区.</span><br><span class="line">1.启动类加载器.   bootstrap class loader. taps: C++实现,没有对应的JAVA对象.</span><br><span class="line">  1.JRE的lib目录下jar包中的类. </span><br><span class="line">  2.-Xbootclasspath -&gt;设置其它的jar包位置.</span><br><span class="line">2.扩展类加载器(extension class loader).</span><br><span class="line">  1.JRE的lib&#x2F;ext目录下jar包中的类. </span><br><span class="line">  2.由系统变量java.ext.dirs指定的类.</span><br><span class="line">3.应用类加载器(application class loader).</span><br><span class="line">   1. -cp 指定classpath运行参数.</span><br><span class="line">   2. 系统变量java.class.path.</span><br><span class="line">   3. 环境变量CLASSPATH.</span><br><span class="line">taps: Java 9 引入 模块系统,扩展类加载器 -&gt; 平台类加载器(platform class loader).</span><br><span class="line">      java.base     -&gt;      启动类加载器</span><br><span class="line">4.命名空间 -&gt; 类的唯一性由类加载器实例及类的全名确定.</span><br></pre></td></tr></table></figure>
<h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">链接分为验证、准备、解析.</span><br><span class="line">1.验证:  JVM加载的类满足Java虚拟机的约束条件. taps:这部分到讲解字节码注入时候再详细介绍.</span><br><span class="line">2.准备:  </span><br><span class="line">    1.为被加载类的静态字段分配内存.</span><br><span class="line">    2.构造与类关联的方法表.</span><br><span class="line">3.解析:</span><br><span class="line">    符号引用(指向方法、字段、其他类)解析成直接引用.</span><br><span class="line">    taps:若符号引用指向一个未被加载的类,解析将会触发这个类的加载.</span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.初始化阶段会为静态字段赋值.</span><br><span class="line">    jvm完成初始化-&gt; final static 基本数据类型&#x2F;String</span><br><span class="line">    执行&lt;clinit&gt;     -&gt; 编译器会生成类字段赋值的&lt;clinit&gt;方法</span><br><span class="line">taps: 类初始化是线程安全的.</span><br><span class="line">2.类初始化触发情况.</span><br><span class="line">    1.主类初始化.    main类.</span><br><span class="line">    2.new指令.</span><br><span class="line">    3.invokestatic(调用静态方法).</span><br><span class="line">    4.getstatic(获取静态字段值).</span><br><span class="line">    5.子类初始化触发父类初始化.</span><br><span class="line">    6.接口的实现类初始化会触发接口的初始化.</span><br><span class="line">    7.反射.</span><br><span class="line">    8.MethodHandle实例会初始化该MethodHandle指向方法所在的类.</span><br><span class="line">    taps:数组会引发元素类加载但不会引发类初始化.</span><br><span class="line">taps:类初始化是线程安全的,并且被执行一次.</span><br><span class="line">单例模式</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">  private Singleton() &#123;&#125;</span><br><span class="line">  private static class LazyHolder &#123;</span><br><span class="line">    static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  public static Singleton getInstance() &#123;</span><br><span class="line">    return LazyHolder.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">taps:这种算是通过私有静态内部类实现的懒加载模式,避免了饿汉式以及双重加锁懒汉式的缺点.</span><br></pre></td></tr></table></figure>
<h3 id="JVM如何执行方法调用-上"><a href="#JVM如何执行方法调用-上" class="headerlink" title="JVM如何执行方法调用(上)"></a>JVM如何执行方法调用(上)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.重载. java-&gt;参数. jvm -&gt;参数+返回类型.</span><br><span class="line">2.静态绑定 -&gt; 解析时候确定目标方法</span><br><span class="line">3.动态绑定 -&gt; 运行时根据调用者的动态类型识别目标方法</span><br><span class="line">4.重写.</span><br><span class="line">  java重写与jvm重写亦不同.</span><br><span class="line">  不同点: 1.java允许子类参数替换父类参数.</span><br><span class="line">          2.java允许范型.</span><br><span class="line">  解决方法: 在子类生成桥接方法.</span><br></pre></td></tr></table></figure>
<h4 id="重载与重写"><a href="#重载与重写" class="headerlink" title="重载与重写"></a>重载与重写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">重载: 同一个类中,方法名字相同的方法叫重载.</span><br><span class="line">1.java编译器与jvm对重载的约束.</span><br><span class="line">  java编译器约束:   参数.</span><br><span class="line">  jvm约束:          参数、返回类型.</span><br><span class="line">2.对于重载的方法,方法调用的判断过程.</span><br><span class="line">  阶段1-挑选出多个适配方法</span><br><span class="line">    1.不考虑自动装拆箱、可变长参数(即根据参数去调用).</span><br><span class="line">    2.只考虑自动装拆箱.</span><br><span class="line">    3.考虑自动装菜与可变长参数.</span><br><span class="line">  阶段2-过滤方法</span><br><span class="line">    1.参数类型的继承关系.</span><br><span class="line">      taps: &quot;abc&quot;即匹配String,也匹配CharSequence,也匹配Object,但是由于继承关系,最终会匹配String.</span><br><span class="line">3.重载在父子类之间依然生效.</span><br><span class="line"></span><br><span class="line">重写: 子类方法与父类方法名称,参数相同,则子类方法重写了父类方法. taps:若子类和父类静态方法,则是子类隐藏了父类的方法(非重写).</span><br><span class="line">1.JVM的重写与Java的重写也不同,JVM的重写要求返回类型亦一致.</span><br><span class="line">2.对于返回类型不同与范型,java编译器通过在子类生成桥接方法解决这个问题.</span><br><span class="line">  桥接一般用于返回类型不同或泛型的重写方法.</span><br><span class="line">  class Father&#123;</span><br><span class="line">      public String speak()&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  class Son extends Father&#123;</span><br><span class="line">      @Override</span><br><span class="line">      public Object speak()&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  例如: Father f&#x3D;new Son();</span><br><span class="line">  使得f.speak()依然调用son.speak()方法,son.speck可以返回类型与父类不同,或者存在范型.</span><br></pre></td></tr></table></figure>
<h4 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void invoke(Object obj, Object... args) &#123; ... &#125;</span><br><span class="line">void invoke(String s, Object obj, Object... args) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">invoke(null, 1);    &#x2F;&#x2F; 调用第二个invoke方法</span><br><span class="line">invoke(null, 1, 2); &#x2F;&#x2F; 调用第二个invoke方法</span><br><span class="line">invoke(null, new Object[]&#123;1&#125;); &#x2F;&#x2F; 只有手动绕开可变长参数的语法糖，</span><br><span class="line">                               &#x2F;&#x2F; 才能调用第一个invoke方法</span><br></pre></td></tr></table></figure>
<h4 id="JVM的静态绑定与动态绑定"><a href="#JVM的静态绑定与动态绑定" class="headerlink" title="JVM的静态绑定与动态绑定"></a>JVM的静态绑定与动态绑定</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.方法描述符  -&gt;  参数类型+返回类型.</span><br><span class="line"><span class="number">2</span>.静态绑定 -&gt; 解析时候就能识别目标方法.</span><br><span class="line"><span class="number">3</span>.动态绑定 -&gt; jvm根据调用者的类型去识别目标方法.</span><br><span class="line">Java字节码中与调用相关的指令.</span><br><span class="line"><span class="number">1</span>.invokestatic -&gt; 调用静态方法.</span><br><span class="line"><span class="number">2</span>.invokespecial -&gt; 调用<span class="keyword">private</span>,构造方法,<span class="keyword">super</span>调用父类方法,接口默认方法(<span class="keyword">default</span>).</span><br><span class="line"><span class="number">3</span>.invokevirtual -&gt; 调用非私有实例方法.</span><br><span class="line"><span class="number">4</span>.invokeinterface -&gt; 调用接口方法.</span><br><span class="line"><span class="number">5</span>.invokedynamic -&gt; 调用动态方法.</span><br><span class="line">静态绑定: invokestatic , invokespecial，invokevirtual(这个是指有<span class="keyword">final</span>修饰的非私有非静态方法)</span><br><span class="line">动态绑定: invokevirtual,invokeinterface</span><br></pre></td></tr></table></figure>
<h4 id="调用指令的符号引用"><a href="#调用指令的符号引用" class="headerlink" title="调用指令的符号引用"></a>调用指令的符号引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.符号引用包括目标方法所在的类或接口,以及目标方法的方法名和方法描述符. </span><br><span class="line">    Methodref -&gt;  Class             -&gt;  Utf8 &quot;java&#x2F;lang&#x2F;Object&quot;</span><br><span class="line">              -&gt;  NameAndType       -&gt;  Utf8 &quot;&lt;init&gt;&quot;  +  Utf8 &quot;()V&quot;</span><br><span class="line">2.符号引用存储在class文件的常量池中.</span><br><span class="line">  根据目标方法是否为接口方法,可分为接口符号引用和非接口符号引用.</span><br><span class="line">3.链接的解析阶段会将部分符号引用转直接引用.</span><br><span class="line">  解析符号引用过程.</span><br><span class="line">  1.非接口类型的符号引用</span><br><span class="line">    设服务引用执行类C,虚拟机将会按照以下步骤进行查找.</span><br><span class="line">    taps:先找父类，再找扩展接口.</span><br><span class="line">    1.在C中查找符合名字及描述符的方法.</span><br><span class="line">    2.未找到,在C的父类中找.直至Object类.</span><br><span class="line">    3.未找到,在C类直接实现或间接实现的接口中找,找到即返回.</span><br><span class="line">  2.接口类型的符号引用.</span><br><span class="line">    设符号引用指向的接口为I,虚拟机将会按照以下步骤进行查找》</span><br><span class="line">    1.在I中查找符合名字及描述符的方法.</span><br><span class="line">    2.未找到,在Object类中找(奇怪).</span><br><span class="line">    3.未找到,在I的超接口中搜索.</span><br><span class="line">4.直接引用(实际引用).</span><br><span class="line">    1.静态绑定的方法,实际引用是一个指向方法的指针.</span><br><span class="line">    2.动态绑定的方法,实际引用是一个指向方法表的索引.</span><br></pre></td></tr></table></figure>
<h4 id="小例子-1"><a href="#小例子-1" class="headerlink" title="小例子"></a>小例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 客户 </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isVIP</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 商户 </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> 折后价格(<span class="keyword">double</span> 原价, 客户 某客户) &#123;</span><br><span class="line">    <span class="keyword">return</span> 原价 * <span class="number">0.8</span>d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 奸商 <span class="keyword">extends</span> 商户 </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">double</span> 折后价格(<span class="keyword">double</span> 原价, 客户 某客户) &#123;</span><br><span class="line">    <span class="keyword">if</span> (某客户.isVIP()) &#123;                         <span class="comment">// invokeinterface      </span></span><br><span class="line">      <span class="keyword">return</span> 原价 * 价格歧视();                    <span class="comment">// invokestatic</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.折后价格(原价, 某客户);          <span class="comment">// invokespecial</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> 价格歧视() &#123;</span><br><span class="line">    <span class="comment">// 咱们的杀熟算法太粗暴了，应该将客户城市作为随机数生成器的种子。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Random()                          <span class="comment">// invokespecial</span></span><br><span class="line">           .nextDouble()                         <span class="comment">// invokevirtual</span></span><br><span class="line">           + <span class="number">0.8</span>d;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">javap -v 奸商<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">....</span></span><br><span class="line"><span class="class">#这里举常量池中方法描述符说明.</span></span><br><span class="line">   #1 = Methodref          #11.#23        // 商户."&lt;init&gt;":()V</span><br><span class="line">   #2 = InterfaceMethodref #24.#25        // 客户.isVIP:()Z       //接口符号引用,Z-&gt;boolean</span><br><span class="line">   #3 = Methodref          #10.#26        // 奸商.价格歧视:()D</span><br><span class="line">   #4 = Methodref          #11.#27        // 商户.折后价格:(DL客户;)D</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<h4 id="小作业-2"><a href="#小作业-2" class="headerlink" title="小作业"></a>小作业</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">看看Java编译器两个生成桥接方法的例子.</span><br><span class="line">taps:可以通过javap编译器查看</span><br><span class="line"><span class="number">1</span>.重写方法的返回类型不一致.</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">isVIP</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Merchant</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Number <span class="title">actionPrice</span><span class="params">(<span class="keyword">double</span> price, Customer customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NaiveMerchant</span> <span class="keyword">extends</span> <span class="title">Merchant</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Double <span class="title">actionPrice</span><span class="params">(<span class="keyword">double</span> price, Customer customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  javap  -v NaiveMerchant<span class="class">.<span class="keyword">class</span> 查看生成的桥接方法.</span></span><br><span class="line"><span class="class">    ......</span></span><br><span class="line">    #2 = Methodref          #3.#15         // NaiveMerchant.actionPrice:(DLCustomer;)Ljava/lang/Double;</span><br><span class="line">    ......</span><br><span class="line">      <span class="keyword">public</span> java.lang.<span class="function">Number <span class="title">actionPrice</span><span class="params">(<span class="keyword">double</span>, Customer)</span></span>;</span><br><span class="line">        descriptor: (DLCustomer;)Ljava/lang/Number;</span><br><span class="line">        flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">        Code:</span><br><span class="line">          stack=<span class="number">4</span>, locals=<span class="number">4</span>, args_size=<span class="number">3</span></span><br><span class="line">             <span class="number">0</span>: aload_0</span><br><span class="line">             <span class="number">1</span>: dload_1</span><br><span class="line">             <span class="number">2</span>: aload_3</span><br><span class="line">             3: invokevirtual #2                  // Method actionPrice:(DLCustomer;)Ljava/lang/Double; #这里会调用真正的方法</span><br><span class="line">             <span class="number">6</span>: areturn</span><br><span class="line">          LineNumberTable:</span><br><span class="line">            line <span class="number">12</span>: <span class="number">0</span>  </span><br><span class="line">    .......</span><br><span class="line">    桥接作用: Merchant m=<span class="keyword">new</span> NaiveMerchant(); Number d=m.actionPrice(<span class="number">1.0f</span>,<span class="keyword">new</span> Customer());</span><br><span class="line"><span class="number">2</span>.范型参数类型造成方法参数类型不一致.</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">boolean</span> <span class="title">isVIP</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">VIP</span> <span class="keyword">extends</span> <span class="title">Customer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Merchant</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Customer</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">actionPrice</span><span class="params">(<span class="keyword">double</span> price, T customer)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VIPOnlyMerchant</span> <span class="keyword">extends</span> <span class="title">Merchant</span>&lt;<span class="title">VIP</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">actionPrice</span><span class="params">(<span class="keyword">double</span> price, VIP customer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    javap -v VIPOnlyMerchant<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">    ......</span></span><br><span class="line">   #2 = Class              #18            // VIP</span><br><span class="line">   #3 = Methodref          #4.#19         // VIPOnlyMerchant.actionPrice:(DLVIP;)D    </span><br><span class="line">    ......</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">actionPrice</span><span class="params">(<span class="keyword">double</span>, Customer)</span></span>;</span><br><span class="line">        descriptor: (DLCustomer;)D</span><br><span class="line">        flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC</span><br><span class="line">        Code:</span><br><span class="line">          stack=<span class="number">4</span>, locals=<span class="number">4</span>, args_size=<span class="number">3</span></span><br><span class="line">             <span class="number">0</span>: aload_0</span><br><span class="line">             <span class="number">1</span>: dload_1</span><br><span class="line">             <span class="number">2</span>: aload_3</span><br><span class="line">             3: checkcast     #2                  // class VIP</span><br><span class="line">             6: invokevirtual #3                  // Method actionPrice:(DLVIP;)D</span><br><span class="line">             <span class="number">9</span>: dreturn</span><br><span class="line">          LineNumberTable:</span><br><span class="line">            line <span class="number">13</span>: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="JVM如何执行方法调用-下"><a href="#JVM如何执行方法调用-下" class="headerlink" title="JVM如何执行方法调用(下)"></a>JVM如何执行方法调用(下)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.虚方法 -&gt; invokevirtual&#x2F;invokeinterface. taps: 若有final修饰,则不是虚方法.</span><br><span class="line">2.动态绑定 -&gt; 方法表 -&gt;直接引用是方法表的索引.</span><br><span class="line">3.内联缓存 -&gt; 记录 &lt;方法,类型&gt;之间的关系.</span><br></pre></td></tr></table></figure>
<h4 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.方法表是一个数组,数组中的元素指向当前类或祖先类的虚方法(非静态，非私有).</span><br><span class="line">    <span class="number">1</span>.子类方法表中包含父类方法表中的所有方法.</span><br><span class="line">    <span class="number">2</span>.子类方法表与父类方法表中相同的方法索引值相同.</span><br><span class="line">    taps:其实就是子类将父类方法表放在自己的首部.</span><br><span class="line">举个例子:</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">passThroughImmigration</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForeignerPassenger</span> <span class="keyword">extends</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">passThroughImmigration</span><span class="params">()</span> </span>&#123; <span class="comment">/* 进外国人通道 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinesePassenger</span> <span class="keyword">extends</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">passThroughImmigration</span><span class="params">()</span> </span>&#123; <span class="comment">/* 进中国人通道 */</span> &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">visitDutyFreeShops</span><span class="params">()</span> </span>&#123; <span class="comment">/* 逛免税店 */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Passenger passenger = ...</span><br><span class="line">passenger.passThroughImmigration();</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2.动态绑定方法调用操作.</span><br><span class="line">  1.访问栈上调用者,获取调用者的动态类型.</span><br><span class="line">  2.根据类型查找方法表,获取索引对应的方法.</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/30/java-virtual-machine/method_table.jpg" alt></p>
<h4 id="内联缓存"><a href="#内联缓存" class="headerlink" title="内联缓存"></a>内联缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.内联缓存-加快动态绑定的优化技术.缓存调用者的动态类型与目标方法.</span><br><span class="line">  key -&gt; 目标方法 , value -&gt; 动态类型</span><br><span class="line">单态 -&gt; 仅有一种状态的情况.    -&gt; 单态内联缓存  -&gt;  只缓存一种动态类型及其对应的目标方法.</span><br><span class="line">多态 -&gt; 有限数量的状态.       -&gt;  多态内联缓存  -&gt;  缓存了多个动态类型及其目标方法.</span><br><span class="line">超多态 -&gt; 更多种状态的情况.</span><br></pre></td></tr></table></figure>
<h4 id="小作业-3"><a href="#小作业-3" class="headerlink" title="小作业"></a>小作业</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run with: java -XX:CompileCommand=dontinline,*.passThroughImmigration Passenger</span></span><br><span class="line"><span class="comment">// Run with: java -XX:CompileCommand=inline,*.passThroughImmigration Passenger</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">passThroughImmigration</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Passenger a = <span class="keyword">new</span> ChinesePassenger();</span><br><span class="line">  Passenger b = <span class="keyword">new</span> ForeignerPassenger();</span><br><span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2_000_000_000</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % <span class="number">100_000_000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> temp = System.currentTimeMillis();</span><br><span class="line">        System.out.println(temp - current);</span><br><span class="line">        current = temp;</span><br><span class="line">      &#125;</span><br><span class="line">      Passenger c = (i &lt; <span class="number">1_000_000_000</span>) ? a : b;</span><br><span class="line">      c.passThroughImmigration();</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinesePassenger</span> <span class="keyword">extends</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">passThroughImmigration</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForeignerPassenger</span> <span class="keyword">extends</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">passThroughImmigration</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/30/java-virtual-machine/inline.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用内联明显比不使用内联快很多.</span><br><span class="line">内联的11次输出时间间隔变大是因为ForeignerPassenger替换了ChinesePassenger.</span><br></pre></td></tr></table></figure>
<h3 id="JVM是如何处理异常的"><a href="#JVM是如何处理异常的" class="headerlink" title="JVM是如何处理异常的"></a>JVM是如何处理异常的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Throwable -&gt; Exception -&gt; RuntimeException</span><br><span class="line">            -&gt; Error</span><br><span class="line">2.java字节码中,每个方法对应一个异常表.</span><br><span class="line">  当异常发生时候,java虚拟机查找异常表,决定需要将控制流转移到哪个异常处理器(条目)中.</span><br><span class="line">3.catch和finally都会生成异常表条目.</span><br><span class="line">4.Java7引入Suppressed异常.</span><br><span class="line">5.Java7语法糖 try-with-resources、多异常捕获</span><br></pre></td></tr></table></figure>
<h4 id="异常基本概念"><a href="#异常基本概念" class="headerlink" title="异常基本概念"></a>异常基本概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Throwable -&gt; Exception -&gt; RuntimeException </span><br><span class="line">               Error </span><br><span class="line">2.构造异常时候,JVM需要生成异常的栈轨迹,构造十分昂贵.该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。</span><br><span class="line">taps:异常对应的栈轨迹并非throw语句,而是新建异常位置.所以在实践中,我们throw new Exception(e);这样写.</span><br></pre></td></tr></table></figure>
<h4 id="Java-虚拟机是如何捕获异常的"><a href="#Java-虚拟机是如何捕获异常的" class="headerlink" title="Java 虚拟机是如何捕获异常的"></a>Java 虚拟机是如何捕获异常的</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.异常表中的每一个条目都代表一个异常处理器.</span><br><span class="line">  条目 -&gt; from指针、to指针、target指针以及所捕获的异常类型.</span><br><span class="line">如:</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        mayThrowException();</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对应的Java字节码</span><br><span class="line">    &#x2F;&#x2F;from ~ to try&#123;&#125;  target ~ catch(..)&#123;&#125;</span><br><span class="line">    public static void main(java.lang.String[]);</span><br><span class="line">      Code:</span><br><span class="line">        0: invokestatic mayThrowException:()V</span><br><span class="line">        3: goto 11</span><br><span class="line">        6: astore_1  #将异常存到局部变量表中</span><br><span class="line">        7: aload_1</span><br><span class="line">        8: invokevirtual java.lang.Exception.printStackTrace</span><br><span class="line">       11: return</span><br><span class="line">      Exception table:</span><br><span class="line">        from  to target type</span><br><span class="line">          0   3   6  Class java&#x2F;lang&#x2F;Exception  &#x2F;&#x2F; 异常表条目</span><br><span class="line">2.java异常处理过程</span><br><span class="line">    1.当程序触发异常时候,Java虚拟机会从上至下遍历异常表所有条目.</span><br><span class="line">    2.根据异常字节码索引值去找到对应的异常表条目.</span><br><span class="line">    3.判断抛出的异常与该条目要捕获的异常是否匹配.</span><br><span class="line">    4.若所有条目都不匹配,弹出当前方法栈帧,在调用者的方法栈帧的异常表中重复上述操作,直到找到.</span><br><span class="line">    4.若匹配,Java虚拟机会将控制流转移到该条目target指向的字节码.</span><br><span class="line">3.finally代码块的编译.</span><br><span class="line">  1.Java编译器的做法是复制finally代码块的内容,分别放在try-catch代码块所有正常执行路径以及异常执行路径的出口.</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/30/java-virtual-machine/finally.jpg" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">举个例子</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> tryBlock;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> catchBlock;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> finallyBlock;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> methodExit;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      tryBlock = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      catchBlock = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      finallyBlock = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    methodExit = <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ javap -c Foo</span><br><span class="line">...</span><br><span class="line">#20 -&gt;tryBlock</span><br><span class="line">#22 -&gt;catchBlock</span><br><span class="line">#24 -&gt;finallyBlock</span><br><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0                           <span class="comment">//try-&gt; this进操作数栈</span></span><br><span class="line">       <span class="number">1</span>: iconst_0                          </span><br><span class="line">       2: putfield      #20                 </span><br><span class="line">       <span class="number">5</span>: goto          <span class="number">30</span>                  <span class="comment">// goto  finally</span></span><br><span class="line">       <span class="number">8</span>: astore_1                       !!!<span class="comment">//try发生异常,将exception存入局部变量表</span></span><br><span class="line">       <span class="number">9</span>: aload_0                           <span class="comment">//catch-&gt; this进操作数栈</span></span><br><span class="line">      <span class="number">10</span>: iconst_1                          </span><br><span class="line">      11: putfield      #22                 </span><br><span class="line">      <span class="number">14</span>: aload_0                           <span class="comment">//catch正常出口,finally-&gt;this进操作数栈</span></span><br><span class="line">      <span class="number">15</span>: iconst_2                          </span><br><span class="line">      16: putfield      #24                 </span><br><span class="line">      <span class="number">19</span>: goto          <span class="number">35</span>                  <span class="comment">//goto methodExit</span></span><br><span class="line">      <span class="number">22</span>: astore_2                       !!!<span class="comment">//catch发生异常,将exception存入局部变量表</span></span><br><span class="line">      <span class="number">23</span>: aload_0                           <span class="comment">//catch异常出口,finally-&gt;this进操作数栈</span></span><br><span class="line">      <span class="number">24</span>: iconst_2                          </span><br><span class="line">      25: putfield      #24                 </span><br><span class="line">      <span class="number">28</span>: aload_2                           </span><br><span class="line">      <span class="number">29</span>: athrow                            <span class="comment">//抛出catch异常,若走athrow下面就不执行了</span></span><br><span class="line">      <span class="number">30</span>: aload_0                           <span class="comment">//try正常出口,</span></span><br><span class="line">      <span class="number">31</span>: iconst_2</span><br><span class="line">      32: putfield      #24                 </span><br><span class="line">      <span class="number">35</span>: aload_0                           <span class="comment">//finally正常出口</span></span><br><span class="line">      <span class="number">36</span>: iconst_3</span><br><span class="line">      37: putfield      #26                 // Field methodExit:I</span><br><span class="line">      <span class="number">40</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">0</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/Exception    <span class="comment">// try </span></span><br><span class="line">           <span class="number">0</span>    <span class="number">14</span>    <span class="number">22</span>   any                          <span class="comment">// try+catch</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">finally</span>有<span class="number">3</span>份,分别对应<span class="keyword">try</span>正常出口,<span class="keyword">catch</span>正常出口,<span class="keyword">catch</span>异常出口.</span><br></pre></td></tr></table></figure>
<h4 id="Java7-Suppressed异常以及语法糖"><a href="#Java7-Suppressed异常以及语法糖" class="headerlink" title="Java7 Suppressed异常以及语法糖"></a>Java7 Suppressed异常以及语法糖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">1.Suppressed异常可以将一个异常附在另一个异常之上. </span><br><span class="line">  解决: catch捕获异常，并抛出新异常,原本的异常捕获的异常将会丢失,Suppressed异常解决该问题.</span><br><span class="line">2.try-with-resources语法糖(java 7). 在字节码层面自动使用Suppressed异常.,该语法糖可以精简资源打开关闭的用法.</span><br><span class="line">java7之前繁琐的代码.</span><br><span class="line">  FileInputStream in0 &#x3D; null;</span><br><span class="line">  FileInputStream in1 &#x3D; null;</span><br><span class="line">  FileInputStream in2 &#x3D; null;</span><br><span class="line">  ...</span><br><span class="line">  try &#123;</span><br><span class="line">    in0 &#x3D; new FileInputStream(new File(&quot;in0.txt&quot;));</span><br><span class="line">    ...</span><br><span class="line">    try &#123;</span><br><span class="line">      in1 &#x3D; new FileInputStream(new File(&quot;in1.txt&quot;));</span><br><span class="line">      ...</span><br><span class="line">      try &#123;</span><br><span class="line">        in2 &#x3D; new FileInputStream(new File(&quot;in2.txt&quot;));</span><br><span class="line">        ...</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        if (in2 !&#x3D; null) in2.close();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (in1 !&#x3D; null) in1.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    if (in0 !&#x3D; null) in0.close();</span><br><span class="line">  &#125;</span><br><span class="line">java7的try-with-resources,对于AutoCloseable接口的实现类,若其放在try()中,Java编译器会自动添加其对应的close操作.</span><br><span class="line">public class Foo implements AutoCloseable &#123;</span><br><span class="line">  private final String name;</span><br><span class="line">  public Foo(String name) &#123; this.name &#x3D; name; &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void close() &#123;</span><br><span class="line">    throw new RuntimeException(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    try (Foo foo0 &#x3D; new Foo(&quot;Foo0&quot;); &#x2F;&#x2F; try-with-resources</span><br><span class="line">         Foo foo1 &#x3D; new Foo(&quot;Foo1&quot;);</span><br><span class="line">         Foo foo2 &#x3D; new Foo(&quot;Foo2&quot;)) &#123;</span><br><span class="line">      throw new RuntimeException(&quot;Initial&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 运行结果：-&gt;RuntimeException-&gt;Initial并未丢失.</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.RuntimeException: Initial</span><br><span class="line">        at Foo.main(Foo.java:18)</span><br><span class="line">        Suppressed: java.lang.RuntimeException: Foo2</span><br><span class="line">                at Foo.close(Foo.java:13)</span><br><span class="line">                at Foo.main(Foo.java:19)</span><br><span class="line">        Suppressed: java.lang.RuntimeException: Foo1</span><br><span class="line">                at Foo.close(Foo.java:13)</span><br><span class="line">                at Foo.main(Foo.java:19)</span><br><span class="line">        Suppressed: java.lang.RuntimeException: Foo0</span><br><span class="line">                at Foo.close(Foo.java:13)</span><br><span class="line">                at Foo.main(Foo.java:19)</span><br><span class="line"></span><br><span class="line">3.java7关于catch的其它语法糖.</span><br><span class="line">可以在同一catch代码块中捕获多种异常.</span><br><span class="line">try&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;catch(SomeException se|OtherException oe)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JVM时如何实现反射的"><a href="#JVM时如何实现反射的" class="headerlink" title="JVM时如何实现反射的"></a>JVM时如何实现反射的</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.反射实现为委派调用.</span><br><span class="line">    -&gt; 本地实现  -&gt;c++</span><br><span class="line">    -&gt; 动态实现  -&gt;java生成调用目标函数字节码</span><br><span class="line">2.反射性能开销-&gt; 变长参数导致Object数组、自动装拆箱、方法内联.</span><br></pre></td></tr></table></figure>
<h4 id="反射API简介"><a href="#反射API简介" class="headerlink" title="反射API简介"></a>反射API简介</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.获取Class对象的三种方式.</span><br><span class="line">    1.Class.forName</span><br><span class="line">    2.obj.getClass()</span><br><span class="line">    3.类名.class.</span><br><span class="line">2.基本数据类型.</span><br><span class="line">  int.class</span><br><span class="line">  Integer有一个名为TYPE的静态字段,该字段指向基本类型对应的Class对象.</span><br><span class="line">3.数组类型.</span><br><span class="line">   int[].class</span><br><span class="line">   int.class.getComponentType()-&gt;int[].class</span><br></pre></td></tr></table></figure>
<h4 id="方法的反射调用"><a href="#方法的反射调用" class="headerlink" title="方法的反射调用"></a>方法的反射调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.Method.invoke源码.</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Method</span> <span class="keyword">extends</span> <span class="title">Executable</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> <span class="keyword">throws</span> ... </span>&#123;</span><br><span class="line">        ... <span class="comment">// 权限检查</span></span><br><span class="line">        MethodAccessor ma = methodAccessor;</span><br><span class="line">        <span class="keyword">if</span> (ma == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ma = acquireMethodAccessor();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ma.invoke(obj, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">2</span>.MethodAccessor -&gt; 委派实现          DelegatingMethodAccessorImpl  -&gt;Method实例第一次反射调用时候会生成一个委派实现.</span><br><span class="line">                        -&gt;本地实现        NativeMethodAccessorImpl  -&gt;c++方法.</span><br><span class="line">                        -&gt;动态实现        GenerateMethodAccessor1   -&gt;通过字节码生成技术,直接调用目标方法 -&gt;字节码生成技术.</span><br><span class="line"><span class="number">3</span>.通过一个例子解释下方法调用的栈帧.</span><br><span class="line"><span class="comment">// v0版本</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">target</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Exception(<span class="string">"#"</span> + i).printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Class&lt;?&gt; klass = Class.forName(<span class="string">"Test"</span>);</span><br><span class="line">    Method method = klass.getMethod(<span class="string">"target"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    method.invoke(<span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 不同版本的输出略有不同，这里我使用了Java 10。</span><br><span class="line">$ java Test</span><br><span class="line">java.lang.Exception: #0</span><br><span class="line">        at Test.target(Test.java:<span class="number">5</span>)</span><br><span class="line">        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">        at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">        at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">        at java.base/java.lang.reflect.Method.invoke(Method.java:<span class="number">564</span>)</span><br><span class="line">        at Test.main(Test.java:<span class="number">131</span>)</span><br><span class="line"><span class="number">4</span>.为啥要在本地实现前加一层委派实现?</span><br><span class="line">    委派实现的目的是实现本地实现与动态实现(动态生成字节码实现)的切换.</span><br><span class="line">    NativeMethodAccessorImpl#invoke</span><br><span class="line">    parent -&gt; DelegatingMethodAccessorImpl</span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Object[] var2)</span> <span class="keyword">throws</span> IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (++<span class="keyword">this</span>.numInvocations &gt; ReflectionFactory.inflationThreshold() &amp;&amp; !ReflectUtil.isVMAnonymousClass(<span class="keyword">this</span>.method.getDeclaringClass())) &#123;</span><br><span class="line">                MethodAccessorImpl var3 = (MethodAccessorImpl)(<span class="keyword">new</span> MethodAccessorGenerator()).generateMethod(<span class="keyword">this</span>.method.getDeclaringClass(), <span class="keyword">this</span>.method.getName(), <span class="keyword">this</span>.method.getParameterTypes(), <span class="keyword">this</span>.method.getReturnType(), <span class="keyword">this</span>.method.getExceptionTypes(), <span class="keyword">this</span>.method.getModifiers());</span><br><span class="line">                <span class="keyword">this</span>.parent.setDelegate(var3);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> invoke0(<span class="keyword">this</span>.method, var1, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    当调用次数达到阈值时候,会向DelegatingMethodAccessorImpl设置新的delegate,新的delegate即为动态实现.(Inflation -&gt;通货膨胀)</span><br><span class="line">    动态实现生成的字节码类似如下.</span><br><span class="line">        <span class="comment">// 动态实现的伪代码，这里只列举了关键的调用逻辑，其实它还包括调用者检测、参数检测的字节码。</span></span><br><span class="line">        <span class="keyword">package</span> jdk.internal.reflect;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratedMethodAccessor1</span> <span class="keyword">extends</span> ... </span>&#123;</span><br><span class="line">          <span class="meta">@Overrides</span>    </span><br><span class="line">          <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object obj, Object[] args)</span> <span class="keyword">throws</span> ... </span>&#123;</span><br><span class="line">            Test.target((<span class="keyword">int</span>) args[<span class="number">0</span>]); <span class="comment">//并没有调用C++函数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="number">5</span>.动态实现与本地实现比较.</span><br><span class="line">    <span class="number">1</span>.动态实现比本地实现要快的多,因为本地实现要Java与C++来回切换.</span><br><span class="line">    <span class="number">2</span>.阈值  sun.reflect.inflationThreshold=<span class="number">15</span></span><br><span class="line">    <span class="comment">// v1版本</span></span><br><span class="line">    <span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">target</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Exception(<span class="string">"#"</span> + i).printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; klass = Class.forName(<span class="string">"Test"</span>);</span><br><span class="line">        Method method = klass.getMethod(<span class="string">"target"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">          method.invoke(<span class="keyword">null</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 使用-verbose:class打印加载的类</span><br><span class="line">    $ java -verbose:<span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">    ...</span></span><br><span class="line">    java.lang.Exception: #14</span><br><span class="line">            at Test.target(Test.java:<span class="number">5</span>)</span><br><span class="line">            at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .invoke0(Native Method)</span><br><span class="line">            at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">            at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl .invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">            at java.base/java.lang.reflect.Method.invoke(Method.java:<span class="number">564</span>)</span><br><span class="line">            at Test.main(Test.java:<span class="number">12</span>)</span><br><span class="line">    [0.158s][info][class,load] ...</span><br><span class="line">    ...</span><br><span class="line">    [0.160s][info][class,load] jdk.internal.reflect.GeneratedMethodAccessor1 source: __JVM_DefineClass__</span><br><span class="line">    java.lang.Exception: #15</span><br><span class="line">           at Test.target(Test.java:<span class="number">5</span>)</span><br><span class="line">           at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .invoke0(Native Method)</span><br><span class="line">           at java.base/jdk.internal.reflect.NativeMethodAccessorImpl .invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">           at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl .invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">           at java.base/java.lang.reflect.Method.invoke(Method.java:<span class="number">564</span>)</span><br><span class="line">           at Test.main(Test.java:<span class="number">12</span>)</span><br><span class="line">    java.lang.Exception: #16</span><br><span class="line">           at Test.target(Test.java:<span class="number">5</span>)</span><br><span class="line">           at jdk.internal.reflect.GeneratedMethodAccessor1 .invoke(Unknown Source)</span><br><span class="line">           at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl .invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">           at java.base/java.lang.reflect.Method.invoke(Method.java:<span class="number">564</span>)</span><br><span class="line">           at Test.main(Test.java:<span class="number">12</span>)</span><br><span class="line">    ...</span><br><span class="line">    <span class="number">3</span>.sun.reflect.noInflation=<span class="keyword">true</span> -&gt;一开始就使用动态实现,不需要设置阈值.</span><br></pre></td></tr></table></figure>
<h4 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">1.clazz.getMethod&#x2F;clazz.getMethods&#x2F;clazz.getDeclaredMethods-&gt;返回查找结果的拷贝. (taps:这种操作会导致堆空间浪费).</span><br><span class="line">  taps: 在应用程序端缓存Class.forName与Class.getMethod结果.</span><br><span class="line">2.举例测试.</span><br><span class="line"> 1.v2版本.</span><br><span class="line">    &#x2F;&#x2F; v2版本</span><br><span class="line">    mport java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">    public class Test &#123;</span><br><span class="line">      public static void target(int i) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空方法</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class&lt;?&gt; klass &#x3D; Class.forName(&quot;Test&quot;);</span><br><span class="line">        Method method &#x3D; klass.getMethod(&quot;target&quot;, int.class);</span><br><span class="line"></span><br><span class="line">        long current &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 2_000_000_000; i++) &#123;</span><br><span class="line">          if (i % 100_000_000 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            long temp &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(temp - current);</span><br><span class="line">            current &#x3D; temp;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          method.invoke(null, 128);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   v2版本对应的部分字节码.</span><br><span class="line">       59: aload_2                         &#x2F;&#x2F; 加载Method对象</span><br><span class="line">       60: aconst_null                     &#x2F;&#x2F; 反射调用的第一个参数null</span><br><span class="line">       61: iconst_1</span><br><span class="line">       62: anewarray Object                &#x2F;&#x2F; 生成一个长度为1的Object数组</span><br><span class="line">       65: dup</span><br><span class="line">       66: iconst_0</span><br><span class="line">       67: sipush 128</span><br><span class="line">       70: invokestatic Integer.valueOf    &#x2F;&#x2F; 将128自动装箱成Integer</span><br><span class="line">       73: aastore                         &#x2F;&#x2F; 存入Object数组中</span><br><span class="line">       74: invokevirtual Method.invoke     &#x2F;&#x2F; 反射调用</span><br><span class="line">    taps: 1.method.invoke第二个参数是边长参数,java编译器会将传入的参数转成Object[].</span><br><span class="line">          2.Object数组,需要将int装箱,128的Integer.valueOf没有缓存.</span><br><span class="line"> 2.v3版本.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; v3版本</span><br><span class="line">    import java.lang.reflect.Method;</span><br><span class="line">    &#x2F;&#x2F;-Djava.lang.Integer.IntegerCache.high&#x3D;128</span><br><span class="line">    public class Test &#123;</span><br><span class="line">      public static void target(int i) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空方法</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class&lt;?&gt; klass &#x3D; Class.forName(&quot;Test&quot;);</span><br><span class="line">        Method method &#x3D; klass.getMethod(&quot;target&quot;, int.class);</span><br><span class="line"></span><br><span class="line">        Object[] arg &#x3D; new Object[1]; &#x2F;&#x2F; 在循环外构造参数数组</span><br><span class="line">        arg[0] &#x3D; 128;</span><br><span class="line"></span><br><span class="line">        long current &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 2_000_000_000; i++) &#123;</span><br><span class="line">          if (i % 100_000_000 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            long temp &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(temp - current);</span><br><span class="line">            current &#x3D; temp;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          method.invoke(null, arg);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   taps: 1.将Integer的缓存池上限改到128,不用每次都new Integer了</span><br><span class="line">         2.直接传入Object数组.</span><br><span class="line">         缺点: arg在循环体外,逃逸分析优化失败,像V2那种可以自动生成的Object数组可以在栈上分配,这里只能在堆中分配了.</span><br><span class="line">         总体而言由于栈上分配优化丢失,比V2还慢.</span><br><span class="line"> 3.v4版本.</span><br><span class="line">    &#x2F;&#x2F; v4版本</span><br><span class="line">    import java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在运行指令中添加如下两个虚拟机参数：</span><br><span class="line">    &#x2F;&#x2F; -Djava.lang.Integer.IntegerCache.high&#x3D;128</span><br><span class="line">    &#x2F;&#x2F; -Dsun.reflect.noInflation&#x3D;true</span><br><span class="line">    public class Test &#123;</span><br><span class="line">      public static void target(int i) &#123;</span><br><span class="line">        &#x2F;&#x2F; 空方法</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Class&lt;?&gt; klass &#x3D; Class.forName(&quot;Test&quot;);</span><br><span class="line">        Method method &#x3D; klass.getMethod(&quot;target&quot;, int.class);</span><br><span class="line">        method.setAccessible(true);  &#x2F;&#x2F; 关闭权限检查</span><br><span class="line"></span><br><span class="line">        long current &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; 2_000_000_000; i++) &#123;</span><br><span class="line">          if (i % 100_000_000 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            long temp &#x3D; System.currentTimeMillis();</span><br><span class="line">            System.out.println(temp - current);</span><br><span class="line">            current &#x3D; temp;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          method.invoke(null, 128);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   taps: 开启动态实现.</span><br></pre></td></tr></table></figure>
<h3 id="JVM如何实现invokedynamic-上"><a href="#JVM如何实现invokedynamic-上" class="headerlink" title="JVM如何实现invokedynamic(上)"></a>JVM如何实现invokedynamic(上)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.MethodHandle是一个强类型的、能够被直接执行的引用。</span><br><span class="line">2.仅关心所指向方法的参数类型以及返回类型，而不关心方法所在的类以及方法名。</span><br><span class="line">3.动态类型语言,权限检查&#x2F;类型检查在LookUp创建过程中.</span><br><span class="line">  相对于反射而言,权限检查次数大大降低.</span><br><span class="line">4.方法句柄支持增删改参数操作.</span><br><span class="line">  增 -&gt; 绑定this</span><br><span class="line">  删 -&gt; 删除第几个参数</span><br><span class="line">  改 -&gt; MethodType变动.</span><br></pre></td></tr></table></figure>
<h4 id="方法句柄概念"><a href="#方法句柄概念" class="headerlink" title="方法句柄概念"></a>方法句柄概念</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.MethodHandle(方法句柄) - 方法句柄可以指向静态方法和实例方法,也可以指向构造器或者字段.</span><br><span class="line">  方法引用指向字段时候,方法句柄实际上是指向包含字段访问字节码的虚构方法,语义上等价于目标字段的getter和setter方法.</span><br><span class="line">2.方法句柄的类型(MethodType) -&gt; 方法的参数类型+返回类型. </span><br><span class="line">  创建 -&gt; MethodHandles.Lookup    -&gt; Method查找</span><br><span class="line">                                  -&gt; 类、方法名、方法句柄类型。 -&gt; Lookup.findStatic - invokeStatic</span><br><span class="line">                                                                 Lookup.findVirtual - invokeVirtual&#x2F;invokeinterface</span><br><span class="line">                                                                 Lookup.findSpecial - invokeSpecial</span><br><span class="line">ForExamples:</span><br><span class="line">    class Foo&#123;</span><br><span class="line">        private static void bar(Object o)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        public static Lookup lookup() &#123; return MethodHandles.lookup(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MethodHandles.Lookup l&#x3D; Foo.lookup(); &#x2F;&#x2F;具有Foo类的访问权限,可以访问private字段或方法</span><br><span class="line">    &#x2F;&#x2F;通过Method获取方法句柄</span><br><span class="line">    Method m&#x3D;Foo.class.getDeclaredMethod(&quot;bar&quot;,Object.class);</span><br><span class="line">    MethodHandle mh0&#x3D;l.unreflect(m);</span><br><span class="line">    &#x2F;&#x2F;通过MethodType,类，方法名查找方法句柄</span><br><span class="line">    MethodType t&#x3D;MethodType.methodType(void.class,Object.class);</span><br><span class="line">    MethodHandle mh1&#x3D;l.findStatic(Foo.class,&quot;bar&quot;,t);</span><br><span class="line">3.MethodHandle的权限检查是在Lookup对象创建时检查.相对于反射而言不会在每次调用方法句柄时候都会进行权限检查(优化).</span><br><span class="line">  例:上例中的lookup对象是在Foo类中创建的,所以MethodHandle可以访问Foo类的私有字段或方法.</span><br></pre></td></tr></table></figure>
<h4 id="方法句柄的操作"><a href="#方法句柄的操作" class="headerlink" title="方法句柄的操作"></a>方法句柄的操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">1.方法句柄的调用分为两种 -&gt;  invokeExact -&gt; 严格匹配.即参数是Object,你传String这种会在运行时候抛出方法类型不匹配,必须传(Object)str.</span><br><span class="line">                        -&gt;  invoke      </span><br><span class="line">2.invokeExact.</span><br><span class="line">  public final native @PolymorphicSignature Object invokeExact(Object... args) throws Throwable;</span><br><span class="line">  @PolymorphicSignature -&gt; 多态描述符，java编译器会根据传入的参数的声明类型来生成方法描述符,而不是采用目标方法所声明的描述符.</span><br><span class="line">  拿invokeExact举例,参数类型是变长参数即Object[].</span><br><span class="line">    public void test(MethodHandle mh, String s) throws Throwable &#123;</span><br><span class="line">      mh.invokeExact(s);</span><br><span class="line">      mh.invokeExact((Object) s);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 对应的Java字节码</span><br><span class="line">    public void test(MethodHandle, String) throws java.lang.Throwable;</span><br><span class="line">      Code:</span><br><span class="line">         0: aload_1</span><br><span class="line">         1: aload_2</span><br><span class="line">         2: invokevirtual MethodHandle.invokeExact:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">         5: aload_1</span><br><span class="line">         6: aload_2</span><br><span class="line">         7: invokevirtual MethodHandle.invokeExact:(Ljava&#x2F;lang&#x2F;Object;)V</span><br><span class="line">        10: return</span><br><span class="line">        </span><br><span class="line">    发现编译后的invokeExact参数类型变成了传入的参数类型.</span><br><span class="line"> taps:invokeExact会将实际传入的参数方法描述符与目标方法的方法描述符进行严格匹配.</span><br><span class="line">3.方法句柄的参数增删改操作.</span><br><span class="line"> 1.改方法句柄的MethodType.</span><br><span class="line">  MethodHandle#asType</span><br><span class="line">  MethodHandle asType(MethodType newType) -&gt; 会将MethodHandle转成methodType为newType的MethodHandle</span><br><span class="line">  这个主要用于类型转换,例如String-&gt;Object</span><br><span class="line"> 2.删操作会在调用target句柄前删除一些伪参数.</span><br><span class="line">  MethodHandles#dropArguments</span><br><span class="line">  MethodHandle dropArguments(MethodHandle target, int pos, Class&lt;?&gt;... valueTypes)</span><br><span class="line">    MethodHandle cat &#x3D; lookup().findVirtual(String.class,</span><br><span class="line">      &quot;concat&quot;, methodType(String.class, String.class));</span><br><span class="line">    assertEquals(&quot;xy&quot;, (String) cat.invokeExact(&quot;x&quot;, &quot;y&quot;));     &#x2F;&#x2F;可以</span><br><span class="line">    MethodHandle d0 &#x3D; dropArguments(cat, 0, String.class);</span><br><span class="line">    assertEquals(&quot;yz&quot;, (String) d0.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)); &#x2F;&#x2F;可以</span><br><span class="line">    MethodHandle d1 &#x3D; dropArguments(cat, 1, String.class);</span><br><span class="line">    assertEquals(&quot;xz&quot;, (String) d1.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)); &#x2F;&#x2F;可以</span><br><span class="line">    MethodHandle d2 &#x3D; dropArguments(cat, 2, String.class);</span><br><span class="line">    assertEquals(&quot;xy&quot;, (String) d2.invokeExact(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)); &#x2F;&#x2F;可以</span><br><span class="line">    MethodHandle d12 &#x3D; dropArguments(cat, 1, int.class, boolean.class);</span><br><span class="line">    assertEquals(&quot;xz&quot;, (String) d12.invokeExact(&quot;x&quot;, 12, true, &quot;z&quot;));&#x2F;&#x2F;可以</span><br><span class="line"> 3.增操作(绑定this)会往传入的参数中插入额外的参数</span><br><span class="line">  taps:Java8中lambda表达式通过这种操作实现.</span><br><span class="line">  MethodHandle#bindTo</span><br><span class="line">  MethodHandle bindTo(Object x)</span><br><span class="line">  举个例子: </span><br><span class="line">  taps:这个例子不恰当,其实是绑定this的</span><br><span class="line">      methodHandle0 -&gt;  f(x,y)</span><br><span class="line">      methodHandle1&#x3D;MethodHandle.bindTo(4) -&gt;f(4,y)</span><br><span class="line">      methodHandle1.invoke(5) -&gt; f(4,5)</span><br></pre></td></tr></table></figure>
<h4 id="方法句柄的实现"><a href="#方法句柄的实现" class="headerlink" title="方法句柄的实现"></a>方法句柄的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1.例子</span><br><span class="line">    import java.lang.invoke.*;</span><br><span class="line"></span><br><span class="line">    public class Foo &#123;</span><br><span class="line">      public static void bar(Object o) &#123;</span><br><span class="line">        new Exception().printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void main(String[] args) throws Throwable &#123;</span><br><span class="line">        MethodHandles.Lookup l &#x3D; MethodHandles.lookup();</span><br><span class="line">        MethodType t &#x3D; MethodType.methodType(void.class, Object.class);</span><br><span class="line">        MethodHandle mh &#x3D; l.findStatic(Foo.class, &quot;bar&quot;, t);</span><br><span class="line">        mh.invokeExact(new Object());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $ java -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames Foo</span><br><span class="line">    java.lang.Exception</span><br><span class="line">            at Foo.bar(Foo.java:5)</span><br><span class="line">            at java.base&#x2F;java.lang.invoke.DirectMethodHandle$Holder. invokeStatic(DirectMethodHandle$Holder:1000010)</span><br><span class="line">            at java.base&#x2F;java.lang.invoke.LambdaForm$MH000&#x2F;766572210. invokeExact_MT000_LLL_V(LambdaForm$MH000:1000019)</span><br><span class="line">            at Foo.main(Foo.java:12)    </span><br><span class="line"> 打印隐藏栈帧-&gt;发现LambdaForm,DirectMethodHandle.</span><br><span class="line">2.LambdaForm$MH000  -&gt;  与方法句柄类型相关的特殊适配器.</span><br><span class="line">    Invokers.checkExactType  -&gt; 检查方法参数类型</span><br><span class="line">    Invokers.checkCustomized -&gt; 若方法调用次数大于java.lang.invoke.MethodHandle.CUSTOMIZE_THRESHOLD&#x3D;127,则会进行优化</span><br><span class="line">    Invokers.invokeBasic      </span><br><span class="line">            -&gt; invokeBasic同样存在一个适配器(LambdaForm).</span><br><span class="line">                -&gt; DirectMethodHandle.internalMemberName</span><br><span class="line">                -&gt; MethodHandle.linkToStatic -&gt;该方法会根据MemberName参数所存储的方法地址或者方法表索引，直接跳转至目标方法.</span><br><span class="line">  Invokers.checkCustomized -&gt;优化,就像内联缓存(方法和类型)一样,会直接存MemberName与MethodHandle之间的关系.</span><br></pre></td></tr></table></figure>
<h3 id="JVM如何实现invokedynamic-下"><a href="#JVM如何实现invokedynamic-下" class="headerlink" title="JVM如何实现invokedynamic(下)"></a>JVM如何实现invokedynamic(下)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.invokedynamic抽象出 CallSite(调用点)概念,并会调用CallSite所连接的MethodHandle.</span><br><span class="line">2.Lambda表达式 -&gt; 函数式接口之间的转换通过invokedynamic指令实现.</span><br><span class="line">  bootStrap方法通过ASM生成一个适配器类(函数式接口实现).</span><br><span class="line">  并通过返回的Callsite指向生成的适配器类.</span><br></pre></td></tr></table></figure>
<h4 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.invokedynamic 是java7引入的一条新指令,用于支持动态语言的调用.</span><br><span class="line"><span class="number">2</span>.invokedynamic将调用点(CallSite)抽线成一个Java类.</span><br><span class="line">    -&gt;将原来由java虚拟机控制的方法调用以及方法链接暴漏给应用程序.</span><br><span class="line">  invokedynamic 指令通过bootStrap方法捆绑一个CallSite,并且会调用CallSite所链接的MethodHandle.</span><br><span class="line">举个例子:</span><br><span class="line"> V1</span><br><span class="line">    <span class="keyword">import</span> java.lang.invoke.*;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Horse</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Horse.race()"</span>); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Deer</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">race</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Deer.race()"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// javac Circuit.java</span></span><br><span class="line">    <span class="comment">// java Circuit</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circuit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startRace</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// aload obj</span></span><br><span class="line">        <span class="comment">// invokedynamic race()</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        startRace(<span class="keyword">new</span> Horse());</span><br><span class="line">        <span class="comment">// startRace(new Deer());</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">bootstrap</span><span class="params">(MethodHandles.Lookup l, String name, MethodType callSiteType)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MethodHandle mh = l.findVirtual(Horse<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>, <span class="title">MethodType</span>.<span class="title">methodType</span>(<span class="title">void</span>.<span class="title">class</span>))</span>;</span><br><span class="line">        <span class="comment">//ConstantCallSite -&gt; 不可更改链接对象的调用点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(mh.asType(callSiteType));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> taps: -&gt; startRace中invokeDynamic不好模拟,可以通过字节码ASM工具包去弄下.</span><br><span class="line">          ASM工具包具体更改逻辑这里就不说了,太难了.</span><br><span class="line"> taps: -&gt;startRace方法对应的字节码.</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startRace</span><span class="params">(java.lang.Object)</span></span>;</span><br><span class="line">             <span class="number">0</span>: aload_0               <span class="comment">// 0是this即调用者</span></span><br><span class="line">             1: invokedynamic #80,  0 // race:(Ljava/lang/Object;)V</span><br><span class="line">             <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line"> taps: 逻辑是执行bootStrap方法获取CallSite，执行CallSite中的MethodHandle,MethodHandle的target方法参数为Object.</span><br><span class="line"> taps: 反编译的race方法与Horse或Deer的race方法描述符都不同.(mh.asType(callSiteType)修改了)</span><br><span class="line"> taps: callSiteType会将调用者亦传入到目标方法中，可能是通过字节码技术弄了新的目标方法出来,不影响原先的目标方法参数</span><br><span class="line"> </span><br><span class="line"> V2 - 添加单态内联缓存 - 添加了额外的MethodHandle作为中转对象,目的是可以调用任意类型的相同目标方法</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要更改ASMHelper.MyMethodVisitor中的BOOTSTRAP_CLASS_NAME</span></span><br><span class="line">    <span class="keyword">import</span> java.lang.invoke.*;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonomorphicInlineCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> MethodHandles.Lookup lookup;</span><br><span class="line">      <span class="comment">//方法名</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">MonomorphicInlineCache</span><span class="params">(MethodHandles.Lookup lookup, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lookup = lookup;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> Class&lt;?&gt; cachedClass = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">private</span> MethodHandle mh = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//receiver-&gt;horse对象/deer对象</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object receiver)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cachedClass != receiver.getClass()) &#123;</span><br><span class="line">          cachedClass = receiver.getClass();</span><br><span class="line">          mh = lookup.findVirtual(cachedClass, name, MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mh.invoke(receiver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *  name -&gt;方法名</span></span><br><span class="line"><span class="comment">       *  Methodtype -&gt; 入参和出参</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">bootstrap</span><span class="params">(MethodHandles.Lookup l, String name, MethodType callSiteType)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        MonomorphicInlineCache ic = <span class="keyword">new</span> MonomorphicInlineCache(l, name);</span><br><span class="line">        MethodHandle mh = l.findVirtual(MonomorphicInlineCache.class, "invoke", MethodType.methodType(void.class, Object.class));</span><br><span class="line">        <span class="comment">//将ic作为this传入invoke函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(mh.bindTo(ic));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Java8的lambda表达式"><a href="#Java8的lambda表达式" class="headerlink" title="Java8的lambda表达式"></a>Java8的lambda表达式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">1.在java8中,Lambda表达式借助invokedynamic指令实现.</span><br><span class="line">2.编译过程,Java编译器会对Lambda表达式进行解语法糖(desugar).</span><br><span class="line">  1.bootStrap方法中用ASM生成函数式接口的实现.</span><br><span class="line">  2.bootStrap返回的CallSite的MethodHandle指向函数式接口的实现(并将外部类对象作为this放入其中).</span><br><span class="line">3.举个例子:</span><br><span class="line">    interface FI &#123;</span><br><span class="line">        void doSomething(int i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class Foo&#123;</span><br><span class="line">        public static void main(String[] args) &#123;</span><br><span class="line">            FI fi &#x3D; (x) -&gt; &#123;</span><br><span class="line">                System.out.println(x);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F;查看其字节码</span><br><span class="line">  javap -v Foo.class</span><br><span class="line">      public static void main(java.lang.String[]);</span><br><span class="line">        descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">        flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">        Code:</span><br><span class="line">          stack&#x3D;1, locals&#x3D;2, args_size&#x3D;1</span><br><span class="line">             0: invokedynamic #2,  0              &#x2F;&#x2F; InvokeDynamic #0:doSomething:()LFI;</span><br><span class="line">             5: astore_1</span><br><span class="line">             6: return</span><br><span class="line"> taps: 这里invokedynamic对应的BootStrap的返回值CallSite为ConstantCallSite.</span><br><span class="line">       CallSite的MethodHandle指向下方对应的Foo$$Lambda$1的doSomething方法.</span><br><span class="line">  &#x2F;&#x2F;查看生成的lambda适配类</span><br><span class="line">  java -Djdk.internal.lambda.dumpProxyClasses&#x3D;.&#x2F; Foo</span><br><span class="line">  javap -v javap -v Foo\$\$Lambda\$1.class </span><br><span class="line">     final class Foo$$Lambda$1 implements FI</span><br><span class="line">     ...</span><br><span class="line">     &#123;</span><br><span class="line">          public void doSomething(int);</span><br><span class="line">             descriptor: (I)V</span><br><span class="line">             flags: ACC_PUBLIC</span><br><span class="line">             Code:</span><br><span class="line">               stack&#x3D;1, locals&#x3D;2, args_size&#x3D;2</span><br><span class="line">                  0: iload_1</span><br><span class="line">                  1: invokestatic  #18                 &#x2F;&#x2F; Method Foo.lambda$main$0:(I)V</span><br><span class="line">                  4: return</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">    &#x2F;&#x2F;Foo.lambda$main$0</span><br><span class="line">    即为main方法中lambda表达式中的内容.</span><br><span class="line">        System.out.println(x);</span><br><span class="line">4.若lambda表达式用到宿体局部变量的话.</span><br><span class="line">   例如: int y&#x3D;3;</span><br><span class="line">        FI fi &#x3D; (x) -&gt; &#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">            System.out.println(y);</span><br><span class="line">        &#125;;</span><br><span class="line">   对应的Foo$$Lambda$1</span><br><span class="line">   会多个int型字段  -&gt; </span><br><span class="line">     #15 &#x3D; Fieldref           #2.#14         &#x2F;&#x2F; Foo$$Lambda$1.arg$1:I</span><br></pre></td></tr></table></figure>
<h3 id="Java对象的内存布局"><a href="#Java对象的内存布局" class="headerlink" title="Java对象的内存布局"></a>Java对象的内存布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.内存布局 -&gt; 压缩指针  -&gt;减少空间使用</span><br><span class="line">          -&gt; 字段重排列 -&gt;内存对齐</span><br></pre></td></tr></table></figure>
<h4 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.对象创建的几种方式.</span><br><span class="line">    1. new </span><br><span class="line">      &#x2F;&#x2F;Foo foo&#x3D;new Foo();</span><br><span class="line">          new Foo</span><br><span class="line">          dup</span><br><span class="line">          invokespecial Foo()</span><br><span class="line">          astore_1</span><br><span class="line">      &#x2F;&#x2F;构造函数对应的字节码</span><br><span class="line">      &#x2F;&#x2F; Foo类构造器会调用其父类Object的构造器</span><br><span class="line">      public Foo();</span><br><span class="line">        0 aload_0 [this]</span><br><span class="line">        1 invokespecial java.lang.Object() [8] #父类构造器</span><br><span class="line">        4 return      </span><br><span class="line">    2. 反射</span><br><span class="line">    3. Object.clone</span><br><span class="line">    4.反序列化</span><br><span class="line">    5.Unsafe.allocateInstance &#x2F;&#x2F;不会初始化</span><br><span class="line">2.通过new 指令 新建出来的对象,其内存涵盖所有父类中的实例字段.</span><br></pre></td></tr></table></figure>
<h4 id="压缩指针"><a href="#压缩指针" class="headerlink" title="压缩指针"></a>压缩指针</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.对象头(Object Header) -&gt; Mark Word(8字节) -&gt; 哈希码、GC信息、锁信息。 </span><br><span class="line">                        -&gt; 类型指针(8字节)  -&gt; 指向类.</span><br><span class="line">2.压缩指针开启,可以将类型指针由8字节,压缩到4字节.</span><br><span class="line">  虚拟机选项 -&gt; -XX:+UseCompressedOops -&gt; 将类型指针从8字节压缩到4字节.</span><br><span class="line">  taps: 压缩指针可以用于对象头的类型指针、引用类型的字段以及引用类型数组。</span><br><span class="line">3.压缩后的指针如何寻址?</span><br><span class="line">  例: A -&gt; 128</span><br><span class="line">  压缩后 A -&gt; 64</span><br><span class="line">  寻址 A *2</span><br><span class="line"> taps:像这种*2压缩的,对象原先地址必须以偶数开始. </span><br><span class="line">4.内存对齐 -&gt; -XX:ObjectAlignmentInBytes&#x3D;8-&gt;对象起始地址对齐至8的倍数。</span><br><span class="line">  taps:若一个对象内存大小小于8字节,呢么空余的空间浪费.</span><br><span class="line">  默认的内存对齐:</span><br><span class="line">     long,double,非压缩状态下的引用字段地址为8的倍数</span><br><span class="line">  taps:字段对齐的原因是让字段只出现在同一CPU的缓存行中.</span><br></pre></td></tr></table></figure>
<h4 id="字段重排列"><a href="#字段重排列" class="headerlink" title="字段重排列"></a>字段重排列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.字段重排列 -&gt; Java虚拟机重新分配字段先后顺序,以达到内存对齐的目的.</span><br><span class="line">2.Java 虚拟机中字段重排列的两个规则.</span><br><span class="line">    1. 子类继承父类的字段,需要与父类对应的字段偏移量保持一致。</span><br><span class="line">    2.如果一个字段占据 C 个字节，那么该字段的偏移量需要对齐至 NC。这里偏移量指的是字段地址与对象的起始地址差值。</span><br><span class="line">举个例子:</span><br><span class="line">    class A &#123;</span><br><span class="line">      int i;</span><br><span class="line">      long l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class B extends A &#123;</span><br><span class="line">      int i;</span><br><span class="line">      long l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # 关闭压缩指针时，B类的字段分布</span><br><span class="line">    B object internals:</span><br><span class="line">     OFFSET  SIZE   TYPE DESCRIPTION</span><br><span class="line">          0     4        (object header)</span><br><span class="line">          4     4        (object header)</span><br><span class="line">          8     4        (object header)</span><br><span class="line">         12     4        (object header)</span><br><span class="line">         16     8   long A.l</span><br><span class="line">         24     4    int A.i</span><br><span class="line">         28     4        (alignment&#x2F;padding gap)                  </span><br><span class="line">         32     8   long B.l</span><br><span class="line">         40     4    int B.i</span><br><span class="line">         44     4        (loss due to the next object alignment)</span><br><span class="line">  taps: long排到了int之前,为的是字段地址为8N.</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收-上"><a href="#垃圾回收-上" class="headerlink" title="垃圾回收(上)"></a>垃圾回收(上)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Java虚拟机使用可达性分析算法探索所有存活的对象.从GC Roots出发,边标记边搜索所有被引用的对象.</span><br><span class="line">2.为了防止在标记过程中堆栈的状态发生改变，</span><br><span class="line">  Java 虚拟机采取安全点机制来实现 Stop-the-world 操作，暂停其他非垃圾回收线程.</span><br><span class="line">3.垃圾回收的三种方式:</span><br><span class="line">    1.sweep -&gt; 内存碎片,分配效率低.</span><br><span class="line">    2.compact -&gt;压缩算法耗时.</span><br><span class="line">    3.copy  -&gt; 浪费空间.</span><br></pre></td></tr></table></figure>
<h4 id="引用计数法与可达性分析"><a href="#引用计数法与可达性分析" class="headerlink" title="引用计数法与可达性分析"></a>引用计数法与可达性分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.引用计数法(古老的辨别方法) -&gt; 对象的引用计数为0时候,对象已死.</span><br><span class="line">  taps: 循环引用: a -&gt; &lt;- b , 导致a和b对象都没法回收。-&gt; 内存泄露</span><br><span class="line">2.可达性分析算法.</span><br><span class="line">  将一系列GC Roots作为初始存活对象集合,从该集合出发,将所有被该集合引用到的对象加入到该集合中(标记).</span><br><span class="line">  未被标记的对象便是死亡的,即可以回收的.</span><br><span class="line">3.GC Roots -&gt; 堆外指向堆内的引用.</span><br><span class="line">    1.方法栈帧中的局部变量.</span><br><span class="line">    2.类的静态变量.</span><br><span class="line">    3.JNI handles.</span><br><span class="line">    4.已启动且未停止的Java线程.</span><br></pre></td></tr></table></figure>
<h4 id="stop-the-world-及-安全点"><a href="#stop-the-world-及-安全点" class="headerlink" title="stop the world 及 安全点"></a>stop the world 及 安全点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.stop the world -&gt; 垃圾回收时候,停止其它非垃圾回收线程的工作，直到垃圾回收完成.</span><br><span class="line">2.安全点 -&gt; 安全点的目的不是让其它线程停下来,而是找到一个稳定的执行状态.</span><br><span class="line">    稳定的执行状态 -&gt; Java虚拟机的堆栈不会发生变化.垃圾回收器能够安全的执行可达性分析.</span><br><span class="line">举个例子:</span><br><span class="line">  Java程序通过JNI执行本地代码时候，</span><br><span class="line">  若这段代码不访问Java对象，调用Java方法或返回至java方法，呢么java虚拟机的堆栈就不会发生改变,</span><br><span class="line">  代表这段本地代码可以作为同一个安全点.</span><br><span class="line">3.java线程的状态及安全点状态.</span><br><span class="line">  java线程状态:</span><br><span class="line">    1.执行JNI本地代码.    -&gt;安全点检测</span><br><span class="line">    2.解释执行字节码.     -&gt;字节码与字节码之间进行安全点检测</span><br><span class="line">    3.执行即时编译生成的机器码. -&gt;机器码直接运行在底层硬件上,HotSpot做法是在生成代码的方法出口以及非计数循环回边(back-edge)处插入安全点检测.</span><br><span class="line">    4.线程阻塞.           -&gt;安全点检测</span><br></pre></td></tr></table></figure>
<h4 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.清除(sweep) -&gt; 将死亡的对象所占据的内存回收 ,并将回收的内存记录在一个空闲列表(free list)之中.</span><br><span class="line">  缺点: 1.存在内存碎片. -&gt;java堆中对象是连续分配的,小对象回收后的空间可能放不下大对象导致内存碎片问题.</span><br><span class="line">        2.分配效率较低. -&gt;java虚拟机需要迭代空闲列表中的元素,以找到一个能放进新建对象的空闲内存.</span><br><span class="line">2.压缩(compact) -&gt; 将存活的对象聚集到内存区域的起始位置,空闲的内存空间为连续的.</span><br><span class="line">  缺点: 1.压缩算法性能问题.</span><br><span class="line">3.复制(copy) -&gt; </span><br><span class="line">    将内存区域分为2部分,并用两个指针from和to维护.</span><br><span class="line">    from指针指向的内存区域用来分配内存.</span><br><span class="line">    垃圾回收时候,</span><br><span class="line">    1.将存活的对象复制到to指针指向的内存区域中.</span><br><span class="line">    2.交换from指针与to指针的内容.</span><br><span class="line">  缺点: 堆空间使用效率极其低下.</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收-下"><a href="#垃圾回收-下" class="headerlink" title="垃圾回收(下)"></a>垃圾回收(下)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.java对象大部分都是朝生夕死的,大部分java对象只存活一小段时间,小部分java对象会存活很长一段时间.</span><br><span class="line">2.新生代   -&gt;  大部分对象朝生夕死,并且可以频繁的采用较短的垃圾回收算法(标记清除-sweep).</span><br><span class="line">  老年代   -&gt;  堆空间不够分配时候,会触发老年代的回收-&gt;全堆扫描.</span><br><span class="line">3.对象晋升.</span><br><span class="line">  -XX:+MaxTenuringThreshold&#x3D;15</span><br><span class="line">  -XX:MaxTenuringThreshold&#x3D;50%</span><br><span class="line">4.Card Table 标识Card是否具有新生代对象引用.</span><br><span class="line">  可以在Minor GC时候，查阅Card Table就知道老年代指向年轻代的引用,避免扫描老年代.</span><br></pre></td></tr></table></figure>
<h4 id="Java虚拟机的堆划分"><a href="#Java虚拟机的堆划分" class="headerlink" title="Java虚拟机的堆划分"></a>Java虚拟机的堆划分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.堆  -&gt;  新生代  -&gt;  Eden + From Survivor &#x2F;To Survivor</span><br><span class="line">      -&gt;  老年代</span><br><span class="line">2.新生代默认采取的是一种动态分配的策略(Java虚拟机参数 -XX:+UsePSAdaptiveSurvivorSizePolicy).</span><br><span class="line"> UsePSAdaptiveSurvivorSizePolicy-&gt;Eden不能小于Survivor中的任意一个,所以最小为1&#x2F;3 * $&#123;-Xmn&#125;</span><br><span class="line">   1.动态调整Eden区和Survivor区的比例-&gt;根据生成对象的速率与Survivor区的使用情况.</span><br><span class="line">   2.-XX:SurvivorRatio -&gt; 手动设置Eden与Survivor区的比例大小.</span><br><span class="line">   taps: 若比例设置过小,导致Survivor过大,则会导致浪费大量的空间(To Surivivor一直是空的).</span><br><span class="line">3.TLAB -&gt; Thread Local Allocation Buffer.</span><br><span class="line">  -XX:UseTLAB -&gt; 线程初始化时候,向Eden园申请一个指点大小的内存(2MB左右)分配给当前线程使用,供当前线程创建对象使用.</span><br><span class="line">    1.TLAB分配时候只能让单线程使用,但是可以多线程访问TLAB中的对象.</span><br><span class="line">    2.三个指针(top,start,end). start指向TLABkong空余内存的起始位置.</span><br><span class="line">    3.指针加法(bump the pointer-指针碰撞),将start指针加上分配的对象字节数,分配的内存为对象所占用.</span><br><span class="line"> taps:TLAB主要解决并发创建对象并分配内存,访问java堆的同一个位置.</span><br><span class="line">4.Minor GC -&gt; Eden 和 Survivor 存活对象会被复制到 to 指向的 Survivor中,回收掉不可达的对象,并交换from与to指针.</span><br><span class="line">5.对象晋升.</span><br><span class="line">  1.若一个对象在年轻代复制了15次(-XX:+MaxTenuringThreshold),那么对象将会晋升到老年代.</span><br><span class="line">  2.若单个Survivor区已被占用50%(-XX:TargetSurvivorRatio),那么较高复制次数的对象也会晋升到老年代.</span><br></pre></td></tr></table></figure>
<h4 id="Java虚拟机的垃圾回收器"><a href="#Java虚拟机的垃圾回收器" class="headerlink" title="Java虚拟机的垃圾回收器"></a>Java虚拟机的垃圾回收器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.新生代的垃圾回收器 -&gt; Serial,Parallel Scavenge(注重吞吐率,不能与CMS一起使用),Parallel New.</span><br><span class="line">2.老年代的垃圾回收器 -&gt; Seial Old ,Parallel Old,CMS(mark-swap).</span><br><span class="line">3.G1 Garbage First.</span><br><span class="line">    1.横跨新生代与老年代的垃圾回收器.</span><br><span class="line">    2.Mark - Compact.</span><br><span class="line">    3.优先回收死亡对象较多的区域(价值最大).</span><br><span class="line">4.ZGC -&gt;java 11引入.</span><br></pre></td></tr></table></figure>
<h4 id="卡表"><a href="#卡表" class="headerlink" title="卡表"></a>卡表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.HotSpot通过卡表(Card Table)将整个堆划分为一个个大小为512字节的卡.</span><br><span class="line">   Card Table  -&gt;  存储每张卡的标识位.</span><br><span class="line">       标识位  -&gt;  标识位对应Card是否指向新生代对象引用. -&gt; 若指向,则说明这张卡是脏的(dirty).</span><br><span class="line">   taps:Minor GC会查Card Table中的脏卡,并将脏卡中的对象加入到Minor GC的GC Roots中.</span><br><span class="line">        Minor GC后会将标识位清0 -&gt; 原因mark -copy 算法让对象位置变了.</span><br><span class="line">        重新设置存活对象对应的Card的标识位.</span><br><span class="line">taps: Card  Table 避免在minor GC扫描老年代.</span><br></pre></td></tr></table></figure>
<h4 id="小作业-4"><a href="#小作业-4" class="headerlink" title="小作业"></a>小作业</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Run with java -XX:+PrintGC -Xmn100M -XX:PretenureSizeThreshold=10000 LifetimeTest</span></span><br><span class="line"><span class="comment">// -Xmn -&gt;年轻代   -XX:PretenureSizeThreshold -&gt; 当对象大于10000B即与等于9MB</span></span><br><span class="line"><span class="comment">// You may also try with -XX:+PrintHeapAtGC，-XX:-UsePSAdaptiveSurvivorSizePolicy or -XX:SurvivorRatio=N</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifetimeTest</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> K = <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = K * K;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> G = K * M;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ALIVE_OBJECT_SIZE = <span class="number">32</span> * M;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组长度-&gt; 32*1024/64=0.5M</span></span><br><span class="line">    <span class="keyword">int</span> length = ALIVE_OBJECT_SIZE / <span class="number">64</span>;</span><br><span class="line">    <span class="comment">//array -&gt; 1/2M * 48B = 24MB</span></span><br><span class="line">    ObjectOf64Bytes[] array = <span class="keyword">new</span> ObjectOf64Bytes[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; G; i++) &#123;<span class="comment">//48GB</span></span><br><span class="line">      <span class="comment">//ObjectOf64Bytes -&gt; 48B</span></span><br><span class="line">      array[(<span class="keyword">int</span>) (i % length)] = <span class="keyword">new</span> ObjectOf64Bytes();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectOf64Bytes</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> placeholder0;</span><br><span class="line">  <span class="keyword">long</span> placeholder1;</span><br><span class="line">  <span class="keyword">long</span> placeholder2;</span><br><span class="line">  <span class="keyword">long</span> placeholder3;</span><br><span class="line">  <span class="keyword">long</span> placeholder4;</span><br><span class="line">  <span class="keyword">long</span> placeholder5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>.java -XX:+PrintGC -Xmn100M -XX:PretenureSizeThreshold=<span class="number">10000</span> LifetimeTest  (taps:java8默认开启UsePSAdaptiveSurvivorSizePolicy)</span><br><span class="line">  UsePSAdaptiveSurvivorSizePolicy -&gt; 当Eden大于 <span class="number">1</span>/<span class="number">3</span> $&#123;-Xmn&#125;,引发Minor GC.</span><br><span class="line"><span class="number">2</span>.java -XX:+PrintGC -XX:SurvivorRatio=<span class="number">2</span> -Xmn192M  LifetimeTest  </span><br><span class="line">    to为<span class="number">48</span>MB(大于个array)时候，之前分配的对象都可以回收了</span><br></pre></td></tr></table></figure>
<h2 id="高效编译"><a href="#高效编译" class="headerlink" title="高效编译"></a>高效编译</h2><h3 id="常用工具介绍"><a href="#常用工具介绍" class="headerlink" title="常用工具介绍"></a>常用工具介绍</h3><h4 id="javap-查阅Java字节码"><a href="#javap-查阅Java字节码" class="headerlink" title="javap:查阅Java字节码"></a>javap:查阅Java字节码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.javap -[pvc] XX.class</span><br><span class="line">    -p -&gt; 打印私有字段</span><br><span class="line">    -v -&gt; 打印所有信息</span><br><span class="line">         minor version , major version , flags(访问标志) , this_class , super_class , interfaces , fields , methods , attributes</span><br><span class="line">    -c -&gt; 紧打印方法</span><br></pre></td></tr></table></figure>
<h4 id="OpenJDK项目Code-Tools-实用小工具集"><a href="#OpenJDK项目Code-Tools-实用小工具集" class="headerlink" title="OpenJDK项目Code Tools: 实用小工具集"></a>OpenJDK项目Code Tools: 实用小工具集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.反编译操作 ASMTools.</span><br><span class="line">    $ java -cp &#x2F;path&#x2F;to&#x2F;asmtools.jar org.openjdk.asmtools.jdis.Main Foo.class &gt; Foo.jasm</span><br><span class="line">    $ java -cp &#x2F;path&#x2F;to&#x2F;asmtools.jar org.openjdk.asmtools.jasm.Main Foo.jasm</span><br><span class="line">taps:jvm规范和java规范是不同的,java规范java编译器会检查,ASMTools可以修改字节码.</span><br><span class="line">2.JOL-可以查阅虚拟机中对象的内存布局.</span><br><span class="line">    $ java -jar &#x2F;path&#x2F;to&#x2F;jol-cli-0.9-full.jar internals java.util.HashMap</span><br><span class="line">    $ java -jar &#x2F;path&#x2F;to&#x2F;jol-cli-0.9-full.jar estimates java.util.HashMap</span><br></pre></td></tr></table></figure>
<h4 id="ASM-java字节码框架"><a href="#ASM-java字节码框架" class="headerlink" title="ASM: java字节码框架"></a>ASM: java字节码框架</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.ASM字节码分析及修改框架.</span><br><span class="line">    应用:Groovy、Kotlin,Cobertura,JaCoCo,Java8的Lambda....</span><br><span class="line">taps:有点...这里先不记录了.</span><br></pre></td></tr></table></figure>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Java内存模型定义了一系列happens-before操作.</span><br><span class="line">2.Java内存模型通过内存屏障来禁止指令重排序. taps:memory barrier 会限制 JIT编译器的重排序优化,也会导致缓存的刷新操作.</span><br></pre></td></tr></table></figure>
<h4 id="小例子-2"><a href="#小例子-2" class="headerlink" title="小例子"></a>小例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r2 = a;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r1 = b;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">-&gt;</span><br><span class="line"><span class="number">1</span>.单线程.</span><br><span class="line">  先 method1,后method2.  (r1,r2) -&gt; (<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">  先 method2,后method1.  (r1,r2) -&gt; (<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span>.多线程</span><br><span class="line">  线程安全               (r1,r2) -&gt; (<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">  重排序.                (r1,r2) -&gt; (<span class="number">1</span>,<span class="number">2</span>)  taps: 两对赋值操作之间没有shu数据依赖.及时编译器、处理器可能对其进行重排序.</span><br><span class="line"> taps:即时编译器造成的..</span><br><span class="line">  Thread1      Thread2</span><br><span class="line">    |            |</span><br><span class="line">   b=<span class="number">1</span>           |</span><br><span class="line">    |          r1=b                  -&gt;    (<span class="number">1</span>,<span class="number">2</span>) 指针重排序这种情况</span><br><span class="line">    |           a=<span class="number">2</span></span><br><span class="line">  r2=a           | </span><br><span class="line"><span class="number">3</span>.v1.</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r2 = a;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> r1 = b;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">volatile</span> -&gt;   r2=a 必须排在b=<span class="number">1</span>前,a=<span class="number">2</span>必须排在r1=b前,这样就不会出现(<span class="number">1</span>,<span class="number">2</span>)这种情况</span><br></pre></td></tr></table></figure>
<h4 id="Java-内存模型-与-happens-before-关系"><a href="#Java-内存模型-与-happens-before-关系" class="headerlink" title="Java 内存模型 与 happens-before 关系"></a>Java 内存模型 与 happens-before 关系</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.happens-before 描述两个操作的内存可见性 -&gt; 若X happens-before Y, 那么X的结果对Y可见.</span><br><span class="line">  1.某把锁的解锁  hb  某把锁的加锁.</span><br><span class="line">  2.volatile 写  hb  volatile读.</span><br><span class="line">  3.线程的启动   hb  线程的第一个操作.</span><br><span class="line">    线程的最后一个动作 hb 线程的终止事件.</span><br><span class="line">  4.线程对其他线程的中断操作 happens-before 被中断线程所收到的中断事件.</span><br><span class="line">  5.构造器中的最后一个操作 happens-before 析构器的第一个操作.</span><br><span class="line">taps: happens-before 具备传递性. X hb Y, Y hb Z -&gt; X hb Z</span><br></pre></td></tr></table></figure>
<h4 id="Java内存模型的底层实现"><a href="#Java内存模型的底层实现" class="headerlink" title="Java内存模型的底层实现"></a>Java内存模型的底层实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.Java内存模型通过内存屏障(memory barrier)来禁止重排序.</span><br><span class="line">                            volatile字段 -&gt;不是局部变量</span><br><span class="line">  taps:volatile的内存屏障 -&gt; volatile字段写操作之前的内存访问排序至其后,volatile字段读操作之后的内存访问重排序至其之前.</span><br><span class="line">2.内存屏障(memory barrier) -&gt;   读读</span><br><span class="line">                                读写</span><br><span class="line">                                写读  -&gt; volatile字段写操作之后,写读内存屏障需要用具体指令替代。(HotSpot的指令lock add DWORD PTR [rsp],0x0 -&gt; 将更改的数据同步至主内存中).</span><br><span class="line">                                写写</span><br><span class="line">  taps:valatile可见性,写读屏障会将更改的数据同步到主存,并无效其它处理器(线程)指向同一地址的缓存行.</span><br></pre></td></tr></table></figure>
<h4 id="锁-volatilez字段-final字段与安全发布"><a href="#锁-volatilez字段-final字段与安全发布" class="headerlink" title="锁,volatilez字段,final字段与安全发布"></a>锁,volatilez字段,final字段与安全发布</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.JIT锁消除-JTI编译器若通过逃逸分析证明某把锁仅被同一线程所持有,就可以移除相应的加锁&#x2F;解锁操作.</span><br><span class="line">    如: synchronized(new Object())&#123;&#125;;</span><br><span class="line">2.volatile -&gt;可见性,有序性，加入内存屏障防止指针重排序.</span><br><span class="line">  volatile -&gt;写读屏障,刷缓存到主存,禁止同一个线程上下指令串开.</span><br><span class="line">  缺点:volatile会强制刷缓存,严重影响程序性能.</span><br><span class="line">  taps:volatile适合于读多写少,推荐只使用一个线程进行写操作.</span><br><span class="line">3.final字段.</span><br><span class="line">  final字段写操作后会添加写写屏障,防止某些优化操作将final对象的发布(即将实例对象写入一个共享引用)重排序final字段写操作之前.</span><br><span class="line">4.安全发布 -&gt; 对象的已初始化实例字段对其它线程可见.</span><br></pre></td></tr></table></figure>
<h3 id="Java虚拟机是如何实现synchronized"><a href="#Java虚拟机是如何实现synchronized" class="headerlink" title="Java虚拟机是如何实现synchronized"></a>Java虚拟机是如何实现synchronized</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.synchronized -&gt; monitorenter ,monitor exit,ACC_SYNCHRONIZED</span><br><span class="line">2.便向锁.</span><br><span class="line">  1.重偏向 - epoch不等.</span><br><span class="line">  2.锁撤销 - epoch相等,cas失败.</span><br><span class="line">3.轻量级锁.</span><br><span class="line">  1.加锁 -  lockrecord栈push,lock-&gt;markword-&gt;lockrecord-address</span><br><span class="line">  2.重入 -  lockrecord栈push null</span><br><span class="line">  3.解锁 -  lockrecord栈pop </span><br><span class="line">4.重量级锁.</span><br><span class="line">  1.mutex.</span><br><span class="line">  2.阻塞,唤醒.</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/30/java-virtual-machine/lock.png" alt></p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.synchronized修饰代码块.</span><br><span class="line">  synchronized(new Object())&#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">  monitorenter</span><br><span class="line">  ......</span><br><span class="line">  monitorexit</span><br><span class="line">  monitorenter&#x2F;monitorexit 指令的参数为对应的锁对象.</span><br><span class="line">2.synchronized修饰方法 -&gt; 方法的访问标记包括ACC_SYNCHRONIZED.</span><br><span class="line">3.锁对象拥有一个计数器和一个指向锁占有者线程的指针.-&gt;markword.</span><br><span class="line">  计数器 -&gt; 实现可重入锁.</span><br><span class="line">4.mark word的最后两位表示对象的锁状态.</span><br><span class="line">    10 -&gt; 重量级锁</span><br><span class="line">    01 -&gt; 无锁&#x2F;偏向锁</span><br><span class="line">    00 -&gt; 轻量级锁</span><br></pre></td></tr></table></figure>

<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.重量级锁依靠操作系统的(mutex)实现.</span><br><span class="line">  系统调用 -&gt; 将操作系统从用户态切换到内核态.</span><br><span class="line">  阻塞锁.</span><br></pre></td></tr></table></figure>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.加锁操作时候,JVM判断自己是否已经是重量级锁。</span><br><span class="line">  若不是,在当前线程的当前栈帧中划出一块空间,作为锁的锁记录(Lock Record).</span><br><span class="line">  并将锁对象的markword复制到锁记录中.</span><br><span class="line">2.LockRecord.</span><br><span class="line">  LockRecord是一个栈帧结构,即获取轻量级锁,就push一个LockRecord入栈.</span><br><span class="line">                            释放轻量级锁,就pop一个LockRecord出栈.</span><br><span class="line">3.轻量级锁重入.</span><br><span class="line">  向LockRecord栈中push一个markword为null的LockRecord.</span><br><span class="line">4.轻量级锁加锁逻辑.(并不会自旋)</span><br><span class="line">  1.构造一个无锁状态的Displaced Mark Word -&gt; none.</span><br><span class="line">  2. cas (obj,obj.markword,none.markword) &#x2F;&#x2F;判断是否无锁&#x2F;偏向锁,是则直接成功.</span><br><span class="line">     thread.lockRecordStack.push(new LockRecord(obj.markword))</span><br><span class="line">     obj.setLockRecordAddress(none);</span><br><span class="line">     </span><br><span class="line">  3.cas 无锁失败.</span><br><span class="line">    判断是否是可重入锁.</span><br><span class="line">      若是的,则可重入.</span><br><span class="line">       thread.lockRecordStack.push(new LockRecord(null));</span><br><span class="line">    若不是.</span><br><span class="line">      1.锁升级(偏向锁撤销).</span><br><span class="line">      或</span><br><span class="line">      2.锁膨胀(轻量级锁).</span><br><span class="line">5.锁升级(未锁定,已偏向).</span><br><span class="line">  偏向锁 -&gt; 轻量级锁,若偏向线程还在用锁,则将轻量级锁线程改成原来偏向锁线程.</span><br><span class="line">6.解锁操作.</span><br><span class="line">  1.若LockRecordStack弹出的是null(说明是可重入锁).</span><br><span class="line">  2.若LockRecordStack弹出的不是null.</span><br><span class="line">    cas操作将Obj.markword还原.</span><br><span class="line">    若cas失败,则说明锁膨胀,通过重量级锁的释放逻辑,唤醒其它的线程.</span><br></pre></td></tr></table></figure>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.偏向锁撤销(锁升级)的两个条件.</span><br><span class="line">    1.锁对象的markword不是想获取锁的线程.</span><br><span class="line">    2.锁对象的epoch与锁class对象的epoch相等.</span><br><span class="line">2.epoch -&gt; 第几代偏向锁.</span><br><span class="line">  当某个类的偏向锁失效时,Jvm将类(class对象)的epoch的值+1.</span><br><span class="line">  为了保持已持有偏向锁并且还加锁的线程不会丢锁,</span><br><span class="line">  在安全点时候,jvm会遍历引用锁对象的所有线程,并将那些线程引用的锁对象的epoch都+1.</span><br><span class="line">3.重偏向.</span><br><span class="line">  查看锁对象与锁class对象的epoch是否相等,若不相等,则可以重偏向.</span><br></pre></td></tr></table></figure>
<h4 id="小作业-5"><a href="#小作业-5" class="headerlink" title="小作业"></a>小作业</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.验证调用object.hashCode()是否会关闭偏向锁</span><br><span class="line">   -XX:+PrintBiasedLockingStatistics -&gt; 打印各类锁的个数. -XX:TieredStopAtLevel&#x3D;1 -&gt;使用C1编译器 -XX:+UseBiasedLocking -&gt; 打开偏向锁 -XX:BiasedLockingStartupDelay&#x3D;0-&gt;关闭hotspot开机延迟</span><br><span class="line">    &#x2F;&#x2F; Run with -XX:+UnlockDiagnosticVMOptions -XX:+PrintBiasedLockingStatistics -XX:TieredStopAtLevel&#x3D;1 -XX:BiasedLockingStartupDelay&#x3D;0</span><br><span class="line">    public class SynchronizedTest &#123;</span><br><span class="line"></span><br><span class="line">      static Lock lock &#x3D; new Lock();</span><br><span class="line">      static int counter &#x3D; 0;</span><br><span class="line"></span><br><span class="line">      public static void foo() &#123;</span><br><span class="line">        synchronized (lock) &#123;</span><br><span class="line">          counter++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        &#x2F;&#x2F; lock.hashCode(); &#x2F;&#x2F; Step 2</span><br><span class="line">        &#x2F;&#x2F; System.identityHashCode(lock); &#x2F;&#x2F; Step 4</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 1_000_000; i++) &#123;</span><br><span class="line">          foo();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static class Lock &#123;</span><br><span class="line">        &#x2F;&#x2F; @Override public int hashCode() &#123; return 0; &#125; &#x2F;&#x2F; Step 3</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   java -XX:+UnlockDiagnosticVMOptions -XX:+PrintBiasedLockingStatistics -XX:TieredStopAtLevel&#x3D;1 -XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay&#x3D;0 SynchronizedTest</span><br><span class="line">taps:object.hashCode()并不会关闭偏向锁.</span><br></pre></td></tr></table></figure>
<h3 id="Java语法糖与Java编译器"><a href="#Java语法糖与Java编译器" class="headerlink" title="Java语法糖与Java编译器"></a>Java语法糖与Java编译器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.java语法糖由java编译器解糖衣操作解析》</span><br><span class="line">2.语法糖举例.</span><br><span class="line">  1.自动装箱&#x2F;拆箱.</span><br><span class="line">  2.泛型类型擦除.</span><br><span class="line">  3.桥接方法(方法重写).</span><br><span class="line">  4.变长参数.  ...-&gt;array.</span><br><span class="line">  5.try-catch-resources ... -&gt; Closeable.</span><br><span class="line">  6.foreach.</span><br><span class="line">  7.switch(str)  -&gt; switch(str.hashCode)</span><br></pre></td></tr></table></figure>
<h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.自动装箱&#x2F;拆箱场景.</span><br><span class="line">  1.数值容器类.</span><br><span class="line">    arrayList.add(0); &#x2F;&#x2F;自动装箱</span><br><span class="line">    int i&#x3D;arrayList.get(0);&#x2F;&#x2F;自动拆箱</span><br><span class="line">  2.显示转换.</span><br><span class="line">    Integer I&#x3D;new Integer(10);</span><br><span class="line">    int i&#x3D;I;</span><br><span class="line">    I&#x3D;i;</span><br><span class="line">2.自动装箱&#x2F;拆箱原理.</span><br><span class="line">  1.装箱 -&gt; Integer.valueOf.</span><br><span class="line">    taps: Integer.valueOf 对Integer 在IntegerCache.low(-128)与IntegerCache.high(127)之间存在缓存.</span><br><span class="line">  2.拆箱 -&gt; Integer.intValue.</span><br><span class="line">    集合对象的拆箱(int i&#x3D;arrayList.get(i))分为2步.</span><br><span class="line">        1.由于集合会泛型擦除,arrayList.get得到的是Object.</span><br><span class="line">          所以java编译器会额外的编译一条</span><br><span class="line">          checkcast java&#x2F;lang&#x2F;Integer -&gt;将Object转为Integer.</span><br><span class="line">        2.调用Integer.intValue方法.</span><br><span class="line">          Integer.intValue(obj)-&gt; 获取int.</span><br></pre></td></tr></table></figure>
<h4 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.泛型擦除的目的是为了兼容引入泛型之前的代码.</span><br><span class="line">  class GenericTest &lt;T extends Number&gt;&#123;</span><br><span class="line">      T foo(T t)&#123;</span><br><span class="line">          return t;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;对应的字节码</span><br><span class="line">    T foo(T);</span><br><span class="line">      &#x2F;&#x2F;方法描述符</span><br><span class="line">      descriptor: (Ljava&#x2F;lang&#x2F;Number;)Ljava&#x2F;lang&#x2F;Number;</span><br><span class="line">      flags: (0x0000)</span><br><span class="line">      Code:</span><br><span class="line">        stack&#x3D;1, locals&#x3D;2, args_size&#x3D;2</span><br><span class="line">           0: aload_1</span><br><span class="line">           1: areturn</span><br><span class="line">      &#x2F;&#x2F;方法签名</span><br><span class="line">      Signature: (TT;)TT;</span><br><span class="line">   &#x2F;&#x2F;方法描述符中泛型信息已被擦除,方法签名中仍然保留泛型信息.</span><br><span class="line">taps:泛型信息的检查是由Java Compiler完成的.</span><br></pre></td></tr></table></figure>
<h4 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.方法重写.</span><br><span class="line">  1.返回值不同的方法重写.</span><br><span class="line">  2.泛型的方法重写.</span><br><span class="line">    ForExample:</span><br><span class="line">        class Merchant&lt;T extends Customer&gt; &#123;</span><br><span class="line">          public double actionPrice(T customer) &#123; -&gt; (LCustomer;)D</span><br><span class="line">            return 0.0d;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        class VIPOnlyMerchant extends Merchant&lt;VIP&gt; &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public double actionPrice(VIP customer) &#123; -&gt; (LVIP;)D</span><br><span class="line">            return 0.0d;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    taps:Java编译器会在VIPOnlyMerchant中生成一个桥接方法-&gt;(LCustomer;)D调用子类的方法以适配父类的方法.</span><br><span class="line">    约等于:</span><br><span class="line">        public double actionPrice(Customer customer)&#123;</span><br><span class="line">            return actionPrice((VIP)customer);</span><br><span class="line">        &#125;</span><br><span class="line">2.生成的桥接方法 -&gt; acc_flags -&gt;ACC_BRIDGE,ACC_SYNTHETIC(表示由java编译器生成).</span><br><span class="line">3.可以通过反射&#x2F;方法句柄调用桥接的方法.</span><br><span class="line">    例如:</span><br><span class="line">       Customer cust&#x3D;new VIP();</span><br><span class="line">       VIPOnlyMerchant vm&#x3D;new VIPOnlyMerchant();</span><br><span class="line">       &#x2F;&#x2F;vm.actionPrice(cust); 编译不通过</span><br><span class="line">       &#x2F;&#x2F;反射可以调用</span><br><span class="line">       vm.getClass().getMethod(&quot;actionPrice&quot;,Customer.class).invoke(vm,cust);</span><br></pre></td></tr></table></figure>
<h4 id="其它语法糖"><a href="#其它语法糖" class="headerlink" title="其它语法糖"></a>其它语法糖</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.变长参数.  Object... -&gt; Object[]</span><br><span class="line">2.try-with-resources -&gt; Closeable</span><br><span class="line">  catch(AException a| BException b)</span><br><span class="line">3.foreach循环.</span><br><span class="line">    for(int item:array)&#123;                    for(int i&#x3D;0;i&lt;array.length;i++)&#123;</span><br><span class="line">                                    -&gt;          int item&#x3D;array[i];</span><br><span class="line">    &#125;                                       &#125;</span><br><span class="line">    for(Integer item:list)&#123;                 Iterator&lt;Integer&gt;iterator&#x3D;list.iterator();</span><br><span class="line">                                    -&gt;      while(iterator.hasNext())&#123;Integer item&#x3D;iterator.next();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">4.switch(str) -&gt; case所截获的字符串都是常量值,java编译器根据字符串的hashcode将switch(str)转为switch(int).</span><br></pre></td></tr></table></figure>
<h3 id="即时编译"><a href="#即时编译" class="headerlink" title="即时编译"></a>即时编译</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.c1 Vs c2</span><br><span class="line">  c1 -&gt; 编译快.</span><br><span class="line">  c2 -&gt; 代码执行快.</span><br><span class="line">2.java8分层编译.</span><br><span class="line">  0层 -&gt; 解释执行</span><br><span class="line">  1层 -&gt; c1(without profiling)</span><br><span class="line">  2层 -&gt; c1(with some profiling)</span><br><span class="line">  3层 -&gt; c1(with full profiling)</span><br><span class="line">  4层 -&gt; c2</span><br><span class="line">3.即时编译器触发.</span><br><span class="line">   方法调用计数器&#x2F;循环回边计数器.</span><br><span class="line">  java8后,即时编译触发阈值动态确定.</span><br><span class="line">4.OSR 是一种能够在非方法入口处进行解释执行和编译后代码之间切换的技术。OSR 编译可以用来解决单次调用方法包含热循环的性能优化问题。</span><br></pre></td></tr></table></figure>
<h4 id="分层编译模式"><a href="#分层编译模式" class="headerlink" title="分层编译模式"></a>分层编译模式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.HotSpot虚拟机-&gt;c1,c2,Graal. </span><br><span class="line">  taps:Graal是实验性的即时编译器,可以通过参数 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMClCompiler开启以替换c2.</span><br><span class="line">2.java7之前.</span><br><span class="line">  -client  -&gt;  启动性能有要求且执行时间短的程序,采用编译效率较快的C1,对应参数-client.</span><br><span class="line">  -server  -&gt;  峰值性能有要求，执行时间较长，采用代码执行效率较快的C2,对应参数-server.</span><br><span class="line">3.java7之后 - 分层编译.  -&gt;  -XX:+TieredCompilation -&gt; 综合了C1的启动性能与C2的峰值性能.</span><br><span class="line">    1.解释执行. ByteCode</span><br><span class="line">    2.执行不带profiling的c1代码. 机器码</span><br><span class="line">    3.执行仅带有方法调用次数以及循环回边执行次数profiling的c1代码.</span><br><span class="line">    4.执行带所有profiling的c1代码.</span><br><span class="line">    5.执行c2代码.</span><br><span class="line"> taps: profiling在程序执行过程中,收集反映程序执行状态的数据.</span><br><span class="line"> taps: 当c1生成的代码携带越多的profiling,执行速度将会减慢.</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/30/java-virtual-machine/JITCompiler.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">taps: 图中由full profiling -&gt; no profiling 是因为发现profiling没有数据,因此采用1层的c1效率更高.</span><br><span class="line">taps: c1编译器busy ,直接由c2编译.</span><br><span class="line">4.java8默认开启分层编译,关闭分层编译将会使用c2编译器,若想使用c1编译器,则通过jvm参数. -XX:TieredStopAtLevel&#x3D;1.</span><br></pre></td></tr></table></figure>
<h4 id="即时编译的触发"><a href="#即时编译的触发" class="headerlink" title="即时编译的触发"></a>即时编译的触发</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.JIT编译器触发 -&gt; 方法调用次数+循环回边的执行次数.</span><br><span class="line">  taps: profiling记录方法调用次数&#x2F;循环回边次数.</span><br><span class="line">2.不启用分层编译的情况下.</span><br><span class="line">   方法调用次数+循环回边次数 &gt; -XX:CompileThreshold(c1为1500,c2为10000) -&gt;触发即时编译.</span><br><span class="line">3.分层编译.</span><br><span class="line">  阈值的大小是动态调整的.</span><br><span class="line">  阈值&#x3D;阈值* s</span><br><span class="line">  s &#x3D; queue_size_X &#x2F; (TierXLoadFeedback * compiler_count_X) + 1</span><br><span class="line">  1.其中X是执行层次，可取3或者4；</span><br><span class="line">  2.queue_size_X是执行层次为X的待编译方法的数目；</span><br><span class="line">  3.TierXLoadFeedback是预设好的参数，其中Tier3LoadFeedback为5，Tier4LoadFeedback为3；</span><br><span class="line">  4.compiler_count_X是层次X的编译线程数目。</span><br><span class="line">  taps:编译线程数量越多的时候,即使方法&#x2F;回边调用次数少,也会触发即时编译.</span><br><span class="line">  taps:编译线程数目: -XX:+CICompilerCountPerCPU&#x3D;true(编译线程与cpu对应) 或-XX:+CICompilerCount&#x3D;N(自定义数量)</span><br><span class="line">  taps:编译线程会按照1:2的比例分配给C1和C2.</span><br></pre></td></tr></table></figure>
<h4 id="小作业-6"><a href="#小作业-6" class="headerlink" title="小作业"></a>小作业</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCompilation -&gt; 打印项目中即时编译情况.</span><br><span class="line">截取部分..</span><br><span class="line">  时间 id  标识 编译器层数</span><br><span class="line"> 165   45 %     3       JITTest::main @ 15 (105 bytes)                                          %-&gt;OSR,@-&gt;循环所在字节码</span><br><span class="line"> 1427   54  s    3       java.io.BufferedInputStream::read (49 bytes)                           s-&gt;synchronized</span><br><span class="line">  1433   68   !   3       java.io.BufferedReader::readLine (304 bytes)                          !-&gt;有catch</span><br></pre></td></tr></table></figure>
<h3 id="字节码基础篇"><a href="#字节码基础篇" class="headerlink" title="字节码基础篇"></a>字节码基础篇</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.栈帧-&gt;操作数栈&#x2F;局部变量表</span><br><span class="line">  long&#x2F;double占两个单位.</span><br><span class="line">  操作数栈 -&gt; 指令运算参数存储,指令运算结果存储.</span><br><span class="line">  局部变量表 -&gt; 局部变量表存储.</span><br><span class="line">2.java常用指令.</span><br><span class="line">    1.加载常量指令.</span><br><span class="line">        iconst,ldc..</span><br><span class="line">    2.操作数栈指令.</span><br><span class="line">      dup&#x2F;pop&#x2F;swap</span><br><span class="line">    3.局部变量表指令.</span><br><span class="line">     istore&#x2F;astore</span><br><span class="line">    4.java相关指令.</span><br><span class="line">      new &#x2F;checkcast&#x2F;instanceof</span><br><span class="line">    5.方法调用指令.</span><br><span class="line">      invokevirtual&#x2F;invokedynamic ...</span><br><span class="line">    6.数组相关指令.</span><br><span class="line">      iastore,iaload,aastore,aaload...</span><br><span class="line">    7.控制流指令.</span><br><span class="line">      goto,ifgt,iflt,return...</span><br></pre></td></tr></table></figure>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.操作数栈  -&gt;  存放计算的操作数及返回结果(指令的操作数(参数)都是从栈中获取的,指令的运算结果会放入栈中).</span><br><span class="line">2.dup与pop.</span><br><span class="line">    dup -&gt; 复制栈顶元素</span><br><span class="line">    pop -&gt; 舍弃栈顶元素</span><br><span class="line">    dup2&#x2F;pop2 -&gt; long&#x2F;double的处理</span><br><span class="line">   例如:  Object o&#x3D;new Object();  --&gt;  </span><br><span class="line">              dup</span><br><span class="line">              invokespecial java.lang.Object()</span><br><span class="line">              astore_1 [o]</span><br><span class="line">        taps:dup的原因是invokespecial将会消耗操作栈的一个元素,dup后即时被消耗一个,仍然剩余一个元素放在栈中.</span><br><span class="line">   例如:</span><br><span class="line">        &#x2F;&#x2F;invokestatic 会将返回值也压入操作数栈中</span><br><span class="line">         public static boolean bar() &#123;</span><br><span class="line">           return false;</span><br><span class="line">         &#125;</span><br><span class="line">       </span><br><span class="line">         public void foo() &#123;</span><br><span class="line">           bar();</span><br><span class="line">         &#125;</span><br><span class="line">         &#x2F;&#x2F; foo方法对应的字节码如下：</span><br><span class="line">         public void foo();</span><br><span class="line">           0  invokestatic FooTest.bar() : boolean [24]</span><br><span class="line">           3  pop</span><br><span class="line">           4  return</span><br><span class="line">    taps:jvm执行额外的pop指令将 invokestatic的返回值boolean移除出栈   </span><br><span class="line">3.swap -&gt; 交换栈顶的两个元素.</span><br><span class="line">4.常量入栈</span><br><span class="line">  iconst -&gt; -1~5的常量入栈</span><br><span class="line">  bipush&#x2F;sipush -&gt; 将一个字节、二个字节能代表的int值入栈.</span><br><span class="line">  bipush -&gt; -128~127</span><br><span class="line">  sipush -&gt; -32768~32767</span><br><span class="line">  lconst -&gt; 0,1</span><br><span class="line">  fconst -&gt; 0,1,2</span><br><span class="line">  dconst -&gt; 0,1</span><br><span class="line">  aconst -&gt; null</span><br><span class="line">  ldc    -&gt; 常量池字面量(任意数值,String literal,Class literal)</span><br><span class="line">taps:发送异常时候,会清空操作数栈,并将异常实例压入操作数栈.</span><br></pre></td></tr></table></figure>
<h4 id="局部变量区"><a href="#局部变量区" class="headerlink" title="局部变量区"></a>局部变量区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1.局部变量区 -&gt; 数组,依次存放着this指针,所传入的参数,字节码中的局部变量.</span><br><span class="line">  long&#x2F;double占2个单元,其它数值&#x2F;reference占一个单元.</span><br><span class="line">2.局部变量表 &lt;-&gt; 操作数栈.</span><br><span class="line">  iload     &lt;-&gt;   istore</span><br><span class="line">  lload     &lt;-&gt;   lstore</span><br><span class="line">  fload     &lt;-&gt;   fstore</span><br><span class="line">  dload     &lt;-&gt;   dstore</span><br><span class="line">  aload     &lt;-&gt;   astore</span><br><span class="line">3.特征的指令.</span><br><span class="line">  iinc M N  -&gt; 将局部变量表数值的第M个单元中的int值加N.</span><br><span class="line">  iinc不借助于操作数栈,直接作用于局部变量表.</span><br><span class="line">举个例子:</span><br><span class="line"></span><br><span class="line">    public static int bar(int i) &#123;</span><br><span class="line">      return ((i + 1) - 2) * 3 &#x2F; 4;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 对应的字节码如下：</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: iload_0  #静态方法,局部变量表0位置为i</span><br><span class="line">         1: iconst_1</span><br><span class="line">         2: iadd</span><br><span class="line">         3: iconst_2</span><br><span class="line">         4: isub</span><br><span class="line">         5: iconst_3</span><br><span class="line">         6: imul</span><br><span class="line">         7: iconst_4</span><br><span class="line">         8: idiv</span><br><span class="line">         9: ireturn</span><br></pre></td></tr></table></figure>
<h4 id="Java字节码简介"><a href="#Java字节码简介" class="headerlink" title="Java字节码简介"></a>Java字节码简介</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.java相关指令.</span><br><span class="line">   new  -&gt; invokespecial 构造方法</span><br><span class="line">   instanceof -&gt; 判断栈顶元素是否是目标类&#x2F;接口的实例.</span><br><span class="line">   checkcast -&gt; 判断栈顶元素是否是目标类&#x2F;接口的实例.</span><br><span class="line">   athrow    -&gt; 将栈顶异常抛出</span><br><span class="line">   monitorenter -&gt; 为栈顶对象加锁</span><br><span class="line">   monitorexit -&gt; 为栈顶对象解锁</span><br><span class="line">2.字段操作</span><br><span class="line">   getstatic</span><br><span class="line">   putstatic</span><br><span class="line">   getfield</span><br><span class="line">   putfield</span><br><span class="line">3.方法调用</span><br><span class="line">   invokestatic</span><br><span class="line">   invokespecial</span><br><span class="line">   invokevirtual</span><br><span class="line">   invokeinterface</span><br><span class="line">   taps:消耗操作栈顶部元素,根据其类型和方法描述符调用.</span><br><span class="line">   invokedynamic    #特殊</span><br><span class="line">4.数组相关指令.</span><br><span class="line">    baload,bastore</span><br><span class="line">    caload,castore</span><br><span class="line">    ....</span><br><span class="line">    aaload,aastore</span><br><span class="line">5.控制流指令.</span><br><span class="line">    goto</span><br><span class="line">    iflt  -&gt;if(..&gt;..)</span><br><span class="line">    tableswitch</span><br><span class="line">    lookupswitch</span><br><span class="line">    cases</span><br><span class="line">    jsr,ret</span><br><span class="line">    ireturn,....areturn</span><br></pre></td></tr></table></figure>
<h3 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.方法内联 -&gt; 在编译过程中,遇到方法调用时,将目标方法的方法体纳入编译范围之中,并取代原方法调用的优化手段.</span><br><span class="line">2.即时编译器既可以在解析过程中替换方法调用字节码，也可以在 IR 图中替换方法调用 IR 节点。这两者都需要将目标方法的参数以及返回值映射到当前方法来。</span><br><span class="line">3.JIT去虚化的几种方法.</span><br><span class="line">  去虚化-&gt;可以对指定的虚方法进行方法内联.</span><br><span class="line">  1.完全去虚化通过类型推导或者类层次分析，将虚方法调用转换为直接调用。它的关键在于证明虚方法调用的目标方法是唯一的。</span><br><span class="line">  2.条件去虚化通过向代码中增添类型比较，将虚方法调用转换为一个个的类型测试以及对应该类型的直接调用。它将借助 Java 虚拟机所收集的类型 Profile。</span><br></pre></td></tr></table></figure>
<h3 id="HotSpot虚拟机的intrinsic"><a href="#HotSpot虚拟机的intrinsic" class="headerlink" title="HotSpot虚拟机的intrinsic"></a>HotSpot虚拟机的intrinsic</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在hotspot虚拟机中,所有被@HotSpotIntrinsicCandidate标注的方法都是HotSpot intrinsic.</span><br><span class="line">  被注解标注的方法,对方法的调用会被虚拟机替换成高效的指令序列.</span><br></pre></td></tr></table></figure>
<h4 id="intrinsic与CPU指令"><a href="#intrinsic与CPU指令" class="headerlink" title="intrinsic与CPU指令"></a>intrinsic与CPU指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.x86_64体系架构的SSE4.2指令集包含一条PCMPESTRI,其能够在16字节以下的字符串中,查找另一个16字节以下的字符串,并返回命中时的索引值.</span><br><span class="line">  PCMPESTRI 可以替换String.indexOf方法.</span><br><span class="line">2.Math.addExact </span><br><span class="line">  java判断两个int相加是否溢出,需要判断两个int值与它的和的符号是否不同.</span><br><span class="line">  可以查看更新状态寄存器(FLAGS register)的溢出标识位(overflow flag).</span><br><span class="line">   伪代码逻辑</span><br><span class="line">    public static int addExact(int x, int y) &#123;</span><br><span class="line">        int r &#x3D; x + y;</span><br><span class="line">        jo LABEL_OVERFLOW; &#x2F;&#x2F; jump if overflow flag set</span><br><span class="line">        return r;</span><br><span class="line">        LABEL_OVERFLOW:</span><br><span class="line">          throw new ArithmeticException(&quot;integer overflow&quot;);</span><br><span class="line">          &#x2F;&#x2F; or deoptimize</span><br><span class="line">    &#125;</span><br><span class="line">3.Integer.bitCount &lt;-&gt; popcnt.</span><br></pre></td></tr></table></figure>
<h4 id="小作业-7"><a href="#小作业-7" class="headerlink" title="小作业"></a>小作业</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.体验一下intrinsic带来的性能提升.</span><br><span class="line">    &#x2F;&#x2F; time java Foo </span><br><span class="line">    public class Foo &#123;</span><br><span class="line">      public static int bitCount(int i) &#123;</span><br><span class="line">        &#x2F;&#x2F; HD, Figure 5-2</span><br><span class="line">        i &#x3D; i - ((i &gt;&gt;&gt; 1) &amp; 0x55555555);</span><br><span class="line">        i &#x3D; (i &amp; 0x33333333) + ((i &gt;&gt;&gt; 2) &amp; 0x33333333);</span><br><span class="line">        i &#x3D; (i + (i &gt;&gt;&gt; 4)) &amp; 0x0f0f0f0f;</span><br><span class="line">        i &#x3D; i + (i &gt;&gt;&gt; 8);</span><br><span class="line">        i &#x3D; i + (i &gt;&gt;&gt; 16);</span><br><span class="line">        return i &amp; 0x3f;</span><br><span class="line">      &#125;</span><br><span class="line">      public static void main(String[] args) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; Integer.MIN_VALUE; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">          sum +&#x3D; bitCount(i); &#x2F;&#x2F; In a second run, replace with Integer.bitCount</span><br><span class="line">            &#x2F;&#x2F;sum+&#x3D;Integer.bitCount(i); &#x2F;&#x2F;popcnt</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">taps: 使用Integer.bitCount速度大约快了7倍左右.</span><br></pre></td></tr></table></figure>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.逃逸分析判断对象是否逃逸的两个依据.</span><br><span class="line">    1.对象是否存入堆中.</span><br><span class="line">    2.对象是否作为方法调用的调用者或参数.</span><br><span class="line">2.逃逸分析优化.</span><br><span class="line">    1.锁消除.</span><br><span class="line">    2.标量替换(栈上分配).</span><br></pre></td></tr></table></figure>
<h4 id="逃逸分析-1"><a href="#逃逸分析-1" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.逃逸分析 -&gt; 确定指针动态范围的静态分析,可以分析在程序的哪些地方可以访问到指针.</span><br><span class="line">2.Java虚拟机判断新建的对象是否逃逸-&gt;</span><br><span class="line">       1.对象是否放在堆中(不能放在堆中,最好OSA).</span><br><span class="line">       2.对象是否被传入未知代码中.(不调用其它非内联方法)</span><br><span class="line">         未知代码:  JIT Compiler以方法为单位,对于方法中未内联的其它方法调用,即时编译器会将其当作未知代码.</span><br><span class="line">       taps:所以,逃逸分析一般放在方法内联之后,消除未知代码入口.</span><br><span class="line">例:</span><br><span class="line">   for(Integer integer:arrayList)&#123;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">   若ArrayList$Iterator构造器,iterator.hasNext,iterator.next,checkForComodification都能内联,那么</span><br><span class="line">   forEach语法糖解开创建的iterator对象是不逃逸的.</span><br></pre></td></tr></table></figure>
<h4 id="基于逃逸分析的优化"><a href="#基于逃逸分析的优化" class="headerlink" title="基于逃逸分析的优化"></a>基于逃逸分析的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1.基于逃逸分析的优化 -&gt; 锁消除、栈上分配、标量替换的优化.</span><br><span class="line">  锁消除:</span><br><span class="line">        synchronized(new Object())&#123;&#125;</span><br><span class="line">        void fun()&#123;String str&#x3D;&quot;abc&quot;;str+&#x3D;&quot;a&quot;;str+&#x3D;&quot;b&quot;;&#125;</span><br><span class="line">  栈上分配: </span><br><span class="line">       逃逸分析若能证明新建的对象不逃逸,Java虚拟机完全将其分配在栈上,并在方法栈帧弹出时候,自动回收所分配的内存.</span><br><span class="line">  标量替换:</span><br><span class="line">       将原本对象的字段访问,替换为一个个局部变量的访问.</span><br><span class="line">2.举个例子.</span><br><span class="line">    &#x2F;&#x2F;原代码</span><br><span class="line">    public void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) &#123;</span><br><span class="line">      for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        f.accept(list.get(i));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;解糖衣+方法内联</span><br><span class="line">    public void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) &#123;</span><br><span class="line">      Itr iter &#x3D; new Itr; &#x2F;&#x2F; 注意这里是new指令</span><br><span class="line">      iter.cursor &#x3D; 0;</span><br><span class="line">      iter.lastRet &#x3D; -1;</span><br><span class="line">      iter.expectedModCount &#x3D; list.modCount;</span><br><span class="line">      while (iter.cursor &lt; list.size) &#123;</span><br><span class="line">        &#x2F;&#x2F;方法内联 -&gt;ConcurrentModificationException</span><br><span class="line">        if (list.modCount !&#x3D; iter.expectedModCount)</span><br><span class="line">          throw new ConcurrentModificationException();</span><br><span class="line">        int i &#x3D; iter.cursor;</span><br><span class="line">        if (i &gt;&#x3D; list.size)</span><br><span class="line">          throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData &#x3D; list.elementData;</span><br><span class="line">        if (i &gt;&#x3D; elementData.length)</span><br><span class="line">          throw new ConcurrentModificationException();</span><br><span class="line">        iter.cursor &#x3D; i + 1;</span><br><span class="line">        iter.lastRet &#x3D; i;</span><br><span class="line">        Object obj &#x3D; elementData[i];</span><br><span class="line">        f.accept(obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;标量替换</span><br><span class="line">    public void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) &#123;</span><br><span class="line">      &#x2F;&#x2F; Itr iter &#x3D; new Itr; &#x2F;&#x2F; 经过标量替换后该分配无意义，可以被优化掉</span><br><span class="line">      int cursor &#x3D; 0;     &#x2F;&#x2F; 标量替换</span><br><span class="line">      int lastRet &#x3D; -1;   &#x2F;&#x2F; 标量替换</span><br><span class="line">      int expectedModCount &#x3D; list.modCount; &#x2F;&#x2F; 标量替换</span><br><span class="line">      while (cursor &lt; list.size) &#123;</span><br><span class="line">        if (list.modCount !&#x3D; expectedModCount)</span><br><span class="line">          throw new ConcurrentModificationException();</span><br><span class="line">        int i &#x3D; cursor;</span><br><span class="line">        if (i &gt;&#x3D; list.size)</span><br><span class="line">          throw new NoSuchElementException();</span><br><span class="line">        Object[] elementData &#x3D; list.elementData;</span><br><span class="line">        if (i &gt;&#x3D; elementData.length)</span><br><span class="line">          throw new ConcurrentModificationException();</span><br><span class="line">        cursor &#x3D; i + 1;</span><br><span class="line">        lastRet &#x3D; i;</span><br><span class="line">        Object obj &#x3D; elementData[i];</span><br><span class="line">        f.accept(obj);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="小作业-8"><a href="#小作业-8" class="headerlink" title="小作业"></a>小作业</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">验证foreach中新建的ArrayList.iterator对象是否被逃逸分析优化.</span><br><span class="line">-XX:-DoEscapeAnalysis -&gt; 关闭默认开启的逃逸分析.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Run with</span><br><span class="line">&#x2F;&#x2F; java -XX:+PrintGC -XX:+DoEscapeAnalysis EscapeTest</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class EscapeTest &#123;</span><br><span class="line"></span><br><span class="line">  public static void forEach(ArrayList&lt;Object&gt; list, Consumer&lt;Object&gt; f) &#123;</span><br><span class="line">    for (Object obj : list) &#123;</span><br><span class="line">      f.accept(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">      list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 400_000_000; i++) &#123;</span><br><span class="line">      forEach(list, obj -&gt; &#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">taps: 开启逃逸分析, obj-&gt;&#123;&#125;这个Consumer会栈上分配,然后优化掉.不会造成GC.</span><br><span class="line">      关闭逃逸分析,会造成GC,回收Consumer对象.</span><br></pre></td></tr></table></figure>
<h2 id="模块优化"><a href="#模块优化" class="headerlink" title="模块优化"></a>模块优化</h2><h3 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.注解（annotation）是 Java 5 引入的，用来为类、方法、字段、参数等 Java 结构提供额外信息的机制.</span><br><span class="line">2.元注解 -&gt; @Target、@Retention、@Documented、@Inherited.</span><br><span class="line">3.注解处理器的三个用途.</span><br><span class="line">  1.定义新的编译规则.</span><br><span class="line">  2.修改源代码.</span><br><span class="line">  3.生成新的源代码.</span><br><span class="line">4.JavaCompiler的编译过程分为三个步骤.</span><br><span class="line">  1.解析源文件生成抽象语法树.</span><br><span class="line">  2.调用注解处理器.</span><br><span class="line">  3.生成字节码.</span><br><span class="line">taps: 若注解处理器修改了抽象语法树,则会重新执行整个操作.</span><br></pre></td></tr></table></figure>
<h4 id="注解处理器的原理"><a href="#注解处理器的原理" class="headerlink" title="注解处理器的原理"></a>注解处理器的原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.Javac编译器的工作流程.</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/30/java-virtual-machine/javacompile.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">    1.将源文件解析为抽象语法树.</span><br><span class="line">    2.调用已注册的注解处理器.</span><br><span class="line">    3.生成字节码.</span><br><span class="line">    taps: 若在第二步注解处理器生成了新的源文件,编译器会重复第1、2步.</span><br><span class="line">2.Processor接口 - 所有的注解处理器类都需要实现接口Processor.</span><br><span class="line">    public interface Processor &#123;</span><br><span class="line">        void init(ProcessingEnvironment processingEnv);</span><br><span class="line">        Set&lt;String&gt; getSupportedOptions();</span><br><span class="line">        Set&lt;String&gt; getSupportedAnnotationTypes();</span><br><span class="line">        SourceVersion getSupportedSourceVersion();</span><br><span class="line">        boolean process(Set&lt;? extends TypeElement&gt; annotations,</span><br><span class="line">                        RoundEnvironment roundEnv);</span><br><span class="line">        Iterable&lt;? extends Completion&gt; getCompletions(Element element,</span><br><span class="line">                                                      AnnotationMirror annotation,</span><br><span class="line">                                                      ExecutableElement member,</span><br><span class="line">                                                      String userText);</span><br><span class="line">    &#125;</span><br><span class="line">    init  -&gt;  注解处理器初始化代码</span><br><span class="line">    getSupportedAnnotationTypes -&gt; 返回需要注解处理器处理的注解.</span><br><span class="line">    getSupportedSourceVersion  -&gt;  返回注解处理器所支持的Java版本.</span><br><span class="line">    process  -&gt;  注解处理方法.</span><br><span class="line">3.举个例子.</span><br><span class="line"> 0.Foo.java</span><br><span class="line">     package foo;     &#x2F;&#x2F; PackageElement</span><br><span class="line">     class Foo &#123;      &#x2F;&#x2F; TypeElement</span><br><span class="line">       int a;           &#x2F;&#x2F; VariableElement</span><br><span class="line">       static int b;    &#x2F;&#x2F; VariableElement</span><br><span class="line">       Foo () &#123;&#125;        &#x2F;&#x2F; ExecutableElement</span><br><span class="line">       void setA (      &#x2F;&#x2F; ExecutableElement</span><br><span class="line">         int newA         &#x2F;&#x2F; VariableElement</span><br><span class="line">       ) &#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line"> 1.自定义注解.</span><br><span class="line">    &#x2F;&#x2F;处理类是否有get&#x2F;set方法.</span><br><span class="line">    package foo;</span><br><span class="line">    import java.lang.annotation.*;</span><br><span class="line">    @Target(&#123; ElementType.TYPE, ElementType.FIELD &#125;)</span><br><span class="line">    @Retention(RetentionPolicy.SOURCE)</span><br><span class="line">    public @interface CheckGetter &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> 2.@CheckGetter对应的注解处理器.</span><br><span class="line">    package bar;</span><br><span class="line"></span><br><span class="line">    import java.util.Set;</span><br><span class="line"></span><br><span class="line">    import javax.annotation.processing.*;</span><br><span class="line">    import javax.lang.model.SourceVersion;</span><br><span class="line">    import javax.lang.model.element.*;</span><br><span class="line">    import javax.lang.model.util.ElementFilter;</span><br><span class="line">    import javax.tools.Diagnostic.Kind;</span><br><span class="line"></span><br><span class="line">    import foo.CheckGetter;</span><br><span class="line"></span><br><span class="line">    @SupportedAnnotationTypes(&quot;foo.CheckGetter&quot;) &#x2F;&#x2F;支持的注解</span><br><span class="line">    @SupportedSourceVersion(SourceVersion.RELEASE_10) &#x2F;&#x2F;支持的java版本</span><br><span class="line">    public class CheckGetterProcessor extends AbstractProcessor &#123;</span><br><span class="line">      &#x2F;**</span><br><span class="line">       * 核心处理逻辑</span><br><span class="line">       * RoundEnvironment -&gt;  囊括前轮生成的语法树</span><br><span class="line">       *&#x2F;</span><br><span class="line">      @Override</span><br><span class="line">      public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123;</span><br><span class="line">        &#x2F;&#x2F; TODO: annotated ElementKind.FIELD</span><br><span class="line">        &#x2F;&#x2F;roundEnv.getElementsAnnotatedWith(CheckGetter.class)获取拥有CheckGetter注解的类</span><br><span class="line">        for (TypeElement annotatedClass : ElementFilter.typesIn(roundEnv.getElementsAnnotatedWith(CheckGetter.class))) &#123;</span><br><span class="line">          &#x2F;&#x2F;annotatedClass.getEnclosedElements()获取拥有CheckGetter注解的类的字段</span><br><span class="line">          for (VariableElement field : ElementFilter.fieldsIn(annotatedClass.getEnclosedElements())) &#123;</span><br><span class="line">            if (!containsGetter(annotatedClass, field.getSimpleName().toString())) &#123;</span><br><span class="line">              processingEnv.getMessager().printMessage(Kind.ERROR,</span><br><span class="line">                  String.format(&quot;getter not found for &#39;%s.%s&#39;.&quot;, annotatedClass.getSimpleName(), field.getSimpleName()));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      private static boolean containsGetter(TypeElement typeElement, String name) &#123;</span><br><span class="line">        String getter &#x3D; &quot;get&quot; + name.substring(0, 1).toUpperCase() + name.substring(1).toLowerCase();</span><br><span class="line">        for (ExecutableElement executableElement : ElementFilter.methodsIn(typeElement.getEnclosedElements())) &#123;</span><br><span class="line">          if (!executableElement.getModifiers().contains(Modifier.STATIC)</span><br><span class="line">              &amp;&amp; executableElement.getSimpleName().toString().equals(getter)</span><br><span class="line">              &amp;&amp; executableElement.getParameters().isEmpty()) &#123;</span><br><span class="line">            return true;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> 3.插件(注解处理器)的使用.</span><br><span class="line">   $ javac -cp &#x2F;CLASSPATH&#x2F;TO&#x2F;CheckGetterProcessor -processor bar.CheckGetterProcessor Foo.java</span><br><span class="line">   或</span><br><span class="line">   1.将注解处理器编译生成的class文件压缩放入jar包中,在jar包的配置文件中记录注解处理器的包名与类名.</span><br><span class="line">      META-INF&#x2F;services&#x2F;javax.annotation.processing.Processor -&gt; bar.CheckGetterProcessor</span><br><span class="line">   2.$ javac -cp &#x2F;PATH&#x2F;TO&#x2F;CheckGetterProcessor.jar Foo.java</span><br></pre></td></tr></table></figure>
<h4 id="利用注解处理器修改源代码"><a href="#利用注解处理器修改源代码" class="headerlink" title="利用注解处理器修改源代码"></a>利用注解处理器修改源代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.通过修改Java源代码对应的抽象语法树,来实现修改源代码.</span><br><span class="line">2.可以参考著名的lombok项目.</span><br><span class="line">  @Getter,@Setter,@Data等注解.</span><br></pre></td></tr></table></figure>
<h3 id="JNI的运行机制"><a href="#JNI的运行机制" class="headerlink" title="JNI的运行机制"></a>JNI的运行机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Java 中的 native 方法的链接方式主要有两种。一是按照 JNI 的默认规范命名所要链接的 C 函数，并依赖于 Java 虚拟机自动链接。另一种则是在 C 代码中主动链接。</span><br><span class="line">2.JNI 提供了一系列 API 来允许 C 代码使用 Java 语言特性。这些 API 不仅使用了特殊的数据结构来表示 Java 类，还拥有特殊的异常处理模式。</span><br><span class="line">3.JNI 中的引用可分为局部引用和全局引用。这两者都可以阻止垃圾回收器回收被引用的 Java 对象。不同的是，局部引用在 native 方法调用返回之后便会失效。传入参数以及大部分 JNI API 函数的返回值都属于局部引用。</span><br></pre></td></tr></table></figure>
<h4 id="native方法的链接"><a href="#native方法的链接" class="headerlink" title="native方法的链接"></a>native方法的链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java虚拟机查找符合默认命名规范的C函数,并链接起来.</span><br><span class="line"> 或者 javac -h 可以根据java程序中的native方法声明,自动生成符合命名规范的C函数的头文件.</span><br></pre></td></tr></table></figure>
<h4 id="JNI的API"><a href="#JNI的API" class="headerlink" title="JNI的API"></a>JNI的API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.Java 虚拟机会将所有 JNI 函数的函数指针聚合到一个名为JNIEnv的数据结构之中.</span><br><span class="line">2.Java 虚拟机会为每个线程创建一个JNIEnv，并规定 C 代码不能将当前线程的JNIEnv共享给其他线程，否则 JNI 函数的正确性将无法保证。</span><br><span class="line">3.JNI 会将 Java 层面的基本类型以及引用类型映射为另一套可供 C 代码使用的数据结构.</span><br><span class="line">  boolean -&gt;jboolean</span><br><span class="line">  byte -&gt;jbyte</span><br><span class="line">  ...</span><br><span class="line">  void -&gt;void</span><br><span class="line">4.当调用 JNI 函数时，Java 虚拟机便已生成异常实例，并缓存在内存中的某个位置。与 Java 编程不一样的是，它并不会显式地跳转至异常处理器或者调用者中，而是继续执行接下来的 C 代码。</span><br><span class="line">  当从可能触发异常的 JNI 函数返回时，我们需要通过 JNI 函数ExceptionOccurred检查是否发生了异常，并且作出相应的处理.</span><br><span class="line">  如果无须抛出该异常，那么我们需要通过 JNI 函数ExceptionClear显式地清空已缓存的异常。</span><br></pre></td></tr></table></figure>
    </div>

    
    
    
		<div>
			
				<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

			
		</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/jvm/" rel="tag"># jvm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/05/27/spring-security/" rel="prev" title="spring-security">
      <i class="fa fa-chevron-left"></i> spring-security
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/13/alibaba-development-manual/" rel="next" title="alibaba-development-manual">
      alibaba-development-manual <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA虚拟机基本原理"><span class="nav-number">1.</span> <span class="nav-text">JAVA虚拟机基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JAVA代码如何运行"><span class="nav-number">1.1.</span> <span class="nav-text">JAVA代码如何运行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVA语言与C语言运行方式"><span class="nav-number">1.1.1.</span> <span class="nav-text">JAVA语言与C语言运行方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-虚拟机具体运行JAVA字节码"><span class="nav-number">1.1.2.</span> <span class="nav-text">Java 虚拟机具体运行JAVA字节码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java虚拟机的运行效率"><span class="nav-number">1.1.3.</span> <span class="nav-text">Java虚拟机的运行效率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小作业"><span class="nav-number">1.1.4.</span> <span class="nav-text">小作业</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java的基本类型"><span class="nav-number">1.2.</span> <span class="nav-text">Java的基本类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java虚拟机的boolean"><span class="nav-number">1.2.1.</span> <span class="nav-text">Java虚拟机的boolean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它的基本数据类型"><span class="nav-number">1.2.2.</span> <span class="nav-text">其它的基本数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java基本类型的大小"><span class="nav-number">1.2.3.</span> <span class="nav-text">Java基本类型的大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小作业-1"><span class="nav-number">1.2.4.</span> <span class="nav-text">小作业</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java虚拟机是如何加载Java类"><span class="nav-number">1.3.</span> <span class="nav-text">Java虚拟机是如何加载Java类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加载"><span class="nav-number">1.3.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#链接"><span class="nav-number">1.3.2.</span> <span class="nav-text">链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">1.3.3.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM如何执行方法调用-上"><span class="nav-number">1.4.</span> <span class="nav-text">JVM如何执行方法调用(上)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重载与重写"><span class="nav-number">1.4.1.</span> <span class="nav-text">重载与重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小例子"><span class="nav-number">1.4.2.</span> <span class="nav-text">小例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM的静态绑定与动态绑定"><span class="nav-number">1.4.3.</span> <span class="nav-text">JVM的静态绑定与动态绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调用指令的符号引用"><span class="nav-number">1.4.4.</span> <span class="nav-text">调用指令的符号引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小例子-1"><span class="nav-number">1.4.5.</span> <span class="nav-text">小例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小作业-2"><span class="nav-number">1.4.6.</span> <span class="nav-text">小作业</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM如何执行方法调用-下"><span class="nav-number">1.5.</span> <span class="nav-text">JVM如何执行方法调用(下)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法表"><span class="nav-number">1.5.1.</span> <span class="nav-text">方法表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内联缓存"><span class="nav-number">1.5.2.</span> <span class="nav-text">内联缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小作业-3"><span class="nav-number">1.5.3.</span> <span class="nav-text">小作业</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM是如何处理异常的"><span class="nav-number">1.6.</span> <span class="nav-text">JVM是如何处理异常的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#异常基本概念"><span class="nav-number">1.6.1.</span> <span class="nav-text">异常基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-虚拟机是如何捕获异常的"><span class="nav-number">1.6.2.</span> <span class="nav-text">Java 虚拟机是如何捕获异常的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java7-Suppressed异常以及语法糖"><span class="nav-number">1.6.3.</span> <span class="nav-text">Java7 Suppressed异常以及语法糖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM时如何实现反射的"><span class="nav-number">1.7.</span> <span class="nav-text">JVM时如何实现反射的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反射API简介"><span class="nav-number">1.7.1.</span> <span class="nav-text">反射API简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法的反射调用"><span class="nav-number">1.7.2.</span> <span class="nav-text">方法的反射调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反射调用的开销"><span class="nav-number">1.7.3.</span> <span class="nav-text">反射调用的开销</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM如何实现invokedynamic-上"><span class="nav-number">1.8.</span> <span class="nav-text">JVM如何实现invokedynamic(上)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法句柄概念"><span class="nav-number">1.8.1.</span> <span class="nav-text">方法句柄概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法句柄的操作"><span class="nav-number">1.8.2.</span> <span class="nav-text">方法句柄的操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法句柄的实现"><span class="nav-number">1.8.3.</span> <span class="nav-text">方法句柄的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM如何实现invokedynamic-下"><span class="nav-number">1.9.</span> <span class="nav-text">JVM如何实现invokedynamic(下)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#invokedynamic指令"><span class="nav-number">1.9.1.</span> <span class="nav-text">invokedynamic指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java8的lambda表达式"><span class="nav-number">1.9.2.</span> <span class="nav-text">Java8的lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java对象的内存布局"><span class="nav-number">1.10.</span> <span class="nav-text">Java对象的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#对象创建"><span class="nav-number">1.10.1.</span> <span class="nav-text">对象创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#压缩指针"><span class="nav-number">1.10.2.</span> <span class="nav-text">压缩指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字段重排列"><span class="nav-number">1.10.3.</span> <span class="nav-text">字段重排列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收-上"><span class="nav-number">1.11.</span> <span class="nav-text">垃圾回收(上)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数法与可达性分析"><span class="nav-number">1.11.1.</span> <span class="nav-text">引用计数法与可达性分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stop-the-world-及-安全点"><span class="nav-number">1.11.2.</span> <span class="nav-text">stop the world 及 安全点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾回收的三种方式"><span class="nav-number">1.11.3.</span> <span class="nav-text">垃圾回收的三种方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收-下"><span class="nav-number">1.12.</span> <span class="nav-text">垃圾回收(下)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java虚拟机的堆划分"><span class="nav-number">1.12.1.</span> <span class="nav-text">Java虚拟机的堆划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java虚拟机的垃圾回收器"><span class="nav-number">1.12.2.</span> <span class="nav-text">Java虚拟机的垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#卡表"><span class="nav-number">1.12.3.</span> <span class="nav-text">卡表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小作业-4"><span class="nav-number">1.12.4.</span> <span class="nav-text">小作业</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高效编译"><span class="nav-number">2.</span> <span class="nav-text">高效编译</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用工具介绍"><span class="nav-number">2.1.</span> <span class="nav-text">常用工具介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#javap-查阅Java字节码"><span class="nav-number">2.1.1.</span> <span class="nav-text">javap:查阅Java字节码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OpenJDK项目Code-Tools-实用小工具集"><span class="nav-number">2.1.2.</span> <span class="nav-text">OpenJDK项目Code Tools: 实用小工具集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ASM-java字节码框架"><span class="nav-number">2.1.3.</span> <span class="nav-text">ASM: java字节码框架</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java内存模型"><span class="nav-number">2.2.</span> <span class="nav-text">Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#小例子-2"><span class="nav-number">2.2.1.</span> <span class="nav-text">小例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-内存模型-与-happens-before-关系"><span class="nav-number">2.2.2.</span> <span class="nav-text">Java 内存模型 与 happens-before 关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java内存模型的底层实现"><span class="nav-number">2.2.3.</span> <span class="nav-text">Java内存模型的底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁-volatilez字段-final字段与安全发布"><span class="nav-number">2.2.4.</span> <span class="nav-text">锁,volatilez字段,final字段与安全发布</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java虚拟机是如何实现synchronized"><span class="nav-number">2.3.</span> <span class="nav-text">Java虚拟机是如何实现synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">2.3.1.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重量级锁"><span class="nav-number">2.3.2.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轻量级锁"><span class="nav-number">2.3.3.</span> <span class="nav-text">轻量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁"><span class="nav-number">2.3.4.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小作业-5"><span class="nav-number">2.3.5.</span> <span class="nav-text">小作业</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java语法糖与Java编译器"><span class="nav-number">2.4.</span> <span class="nav-text">Java语法糖与Java编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动装箱与拆箱"><span class="nav-number">2.4.1.</span> <span class="nav-text">自动装箱与拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型与类型擦除"><span class="nav-number">2.4.2.</span> <span class="nav-text">泛型与类型擦除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#桥接方法"><span class="nav-number">2.4.3.</span> <span class="nav-text">桥接方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其它语法糖"><span class="nav-number">2.4.4.</span> <span class="nav-text">其它语法糖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#即时编译"><span class="nav-number">2.5.</span> <span class="nav-text">即时编译</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分层编译模式"><span class="nav-number">2.5.1.</span> <span class="nav-text">分层编译模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#即时编译的触发"><span class="nav-number">2.5.2.</span> <span class="nav-text">即时编译的触发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小作业-6"><span class="nav-number">2.5.3.</span> <span class="nav-text">小作业</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节码基础篇"><span class="nav-number">2.6.</span> <span class="nav-text">字节码基础篇</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作数栈"><span class="nav-number">2.6.1.</span> <span class="nav-text">操作数栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部变量区"><span class="nav-number">2.6.2.</span> <span class="nav-text">局部变量区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java字节码简介"><span class="nav-number">2.6.3.</span> <span class="nav-text">Java字节码简介</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法内联"><span class="nav-number">2.7.</span> <span class="nav-text">方法内联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot虚拟机的intrinsic"><span class="nav-number">2.8.</span> <span class="nav-text">HotSpot虚拟机的intrinsic</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#intrinsic与CPU指令"><span class="nav-number">2.8.1.</span> <span class="nav-text">intrinsic与CPU指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小作业-7"><span class="nav-number">2.8.2.</span> <span class="nav-text">小作业</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逃逸分析"><span class="nav-number">2.9.</span> <span class="nav-text">逃逸分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逃逸分析-1"><span class="nav-number">2.9.1.</span> <span class="nav-text">逃逸分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于逃逸分析的优化"><span class="nav-number">2.9.2.</span> <span class="nav-text">基于逃逸分析的优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小作业-8"><span class="nav-number">2.9.3.</span> <span class="nav-text">小作业</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块优化"><span class="nav-number">3.</span> <span class="nav-text">模块优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注解处理器"><span class="nav-number">3.1.</span> <span class="nav-text">注解处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注解处理器的原理"><span class="nav-number">3.1.1.</span> <span class="nav-text">注解处理器的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用注解处理器修改源代码"><span class="nav-number">3.1.2.</span> <span class="nav-text">利用注解处理器修改源代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JNI的运行机制"><span class="nav-number">3.2.</span> <span class="nav-text">JNI的运行机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#native方法的链接"><span class="nav-number">3.2.1.</span> <span class="nav-text">native方法的链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JNI的API"><span class="nav-number">3.2.2.</span> <span class="nav-text">JNI的API</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vicyor"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">vicyor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">61</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">54</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vicyor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vicyor" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2457569580@qq.com" title="E-Mail → mailto:2457569580@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vicyor</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">16:21</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=m9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'm9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz',
            'X-LC-Key': 'g7WSuE6aDmunoX4rgyBN7SJa',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'qQhr9rNGJh6YalJA0mfaaurx-gzGzoHsz',
    appKey: 'kJy8NJeOTMPnxQ3zLihOcnw3',
    placeholder: "请留下您的宝贵评论",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

	
		 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
		 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
		 <script type="text/javascript" src="/js/src/fireworks.js"></script>
	
</body>
</html>
