<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://vicyor.gitee.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="redis - 高性能key-value数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://vicyor.gitee.io/2020/08/18/redis/index.html">
<meta property="og:site_name" content="Vicyor">
<meta property="og:description" content="redis - 高性能key-value数据库">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://vicyor.gitee.io/2020/08/18/redis/redis-sentinel.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/08/18/redis/raft.jpg">
<meta property="og:image" content="http://vicyor.gitee.io/2020/08/18/redis/redis-cluster.jpg">
<meta property="og:image" content="http://vicyor.gitee.io/2020/08/18/redis/client-route.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/08/18/redis/ask-exception.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/08/18/redis/jedis-cluster-execute-command.png">
<meta property="article:published_time" content="2020-08-18T13:07:28.000Z">
<meta property="article:modified_time" content="2020-12-15T15:56:38.637Z">
<meta property="article:author" content="vicyor">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://vicyor.gitee.io/2020/08/18/redis/redis-sentinel.png">

<link rel="canonical" href="http://vicyor.gitee.io/2020/08/18/redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>redis | Vicyor</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vicyor</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">51</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">59</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vicyor.gitee.io/2020/08/18/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="vicyor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vicyor">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-18 21:07:28" itemprop="dateCreated datePublished" datetime="2020-08-18T21:07:28+08:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-15 23:56:38" itemprop="dateModified" datetime="2020-12-15T23:56:38+08:00">2020-12-15</time>
              </span>

          
            <span id="/2020/08/18/redis/" class="post-meta-item leancloud_visitors" data-flag-title="redis" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/08/18/redis/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/08/18/redis/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>redis - 高性能key-value数据库</p>
<a id="more"></a>
<h2 id="初始redis"><a href="#初始redis" class="headerlink" title="初始redis"></a>初始redis</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1.高性能key-value服务器.</span><br><span class="line">   qps  -&gt;  10万，速度快 -&gt; 数据存储在RAM中,</span><br><span class="line">                          C语言 - 编译型语言(编译成字节码),</span><br><span class="line">                          单线程.</span><br><span class="line">2.多种数据结构.</span><br><span class="line">  String,Hash Tables,Linked Lists(跳表),Sets,Sorted Sets.</span><br><span class="line">  BitMaps,HyperLogLog(超小内存唯一值计数).GEO(地理信息定位).</span><br><span class="line">3.丰富的功能.</span><br><span class="line">    pipeline,pub&#x2F;sub,事务,Lua脚本.</span><br><span class="line">4.高可用分布式支持.</span><br><span class="line">    高可用 -&gt; redis sentinel. -&gt; 冗余</span><br><span class="line">    分布式 -&gt; redis cluster.  -&gt; 伸缩+冗余</span><br><span class="line">5.数据持久化(断电不丢失数据).</span><br><span class="line">  Aof,Rdb -&gt; 数据更新会异步保存到磁盘上.</span><br><span class="line">6.主从复制.</span><br><span class="line">7.Redis典型应用场景.</span><br><span class="line">    1.缓存系统.   -&gt;  CacheAside.</span><br><span class="line">    2.计数器.     -&gt;  incr.</span><br><span class="line">    3.消息队列系统. -&gt; list,deque + redis cli &#39;s poll()</span><br><span class="line">    4.排行榜.      -&gt; score list</span><br><span class="line">    5.社交网络.    -&gt; 如微博.  </span><br><span class="line">      1.微博消息体.  &lt;messageId,message&gt;</span><br><span class="line">      2.微博信息流.  &lt;userId,zset&lt;messageId&gt;&gt;    zset -&gt;timestamp为score</span><br><span class="line">      3.关注和粉丝.  </span><br><span class="line">           following  -  &lt;userId,zset&lt;userId&gt;&gt;  </span><br><span class="line">           follower   -  &lt;userId,zset&lt;userId&gt;&gt;</span><br><span class="line">    6.实时系统.</span><br><span class="line">    7.分布式锁.</span><br><span class="line">    8.分布式id生成器.   incr生成自增id.</span><br><span class="line">8.Redis自带的可执行文件.</span><br><span class="line">    1.redis-check-aof   -&gt;  AOF文件修复工具.</span><br><span class="line">    2.redis-check-dump  -&gt;  RDB文件检查工具.</span><br><span class="line">    3.redis-sentinel    -&gt;  启动Sentinel服务器.</span><br><span class="line">      redis-cli -p &#123;sentinel-server-port&#125; # 可以进入sentinel服务器.</span><br><span class="line">9.Redis三种启动方式.</span><br><span class="line">    1.最简启动      -&gt;   redis-server.</span><br><span class="line">        ps -ef | grep redis</span><br><span class="line">        netstat -antp | grep redis</span><br><span class="line">        redis-cli -h ip -p port ping</span><br><span class="line">    2.动态参数启动</span><br><span class="line">        redis-server --port 6379</span><br><span class="line">    3.配置文件启动</span><br><span class="line">        redis-server redis.conf</span><br><span class="line">10.Redis 常用配置.</span><br><span class="line">    daemonize  -&gt;  是否是守护进程(no|yes)</span><br><span class="line">    port       -&gt;  Redis对外端口号</span><br><span class="line">    logfile    -&gt;  Redis系统日志,redis执行的输出日志.</span><br><span class="line">    dir        -&gt;  Redis工作目录 ,rdb、aof日志文件.</span><br><span class="line">11.Redis key过期删除.</span><br><span class="line">  1.惰性删除. 获取key时,若发现key过期则删除.</span><br><span class="line">  2.定时任务. 定时随机采样,对过期的数据进行删除.</span><br><span class="line">12.Redis内存淘汰机制.</span><br><span class="line">    noeviction       当内存不足时,新写入操作会报错.++</span><br><span class="line">    allkeys-lru(LRU least-recently Used) 当内存不足时,移除最近最少使用的key(最常用).</span><br><span class="line">    allkeys-random   当内存不足时,随机移除某个key.</span><br><span class="line">    volatile-lru     当内存不足时,在设置了过期时间的键空间中,移除最近最少使用的key.</span><br><span class="line">    volatile-random  当内存不足时,在设置了过期时间的键空间中,随机删除某个key.</span><br><span class="line">    volatile-tll     当内存不足时,在设置过期时间的键空间中,删除最早的key.</span><br></pre></td></tr></table></figure>
<h2 id="API的理解和使用"><a href="#API的理解和使用" class="headerlink" title="API的理解和使用"></a>API的理解和使用</h2><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">通用命令   +  单线程架构  +  数据结构和内部编码</span><br><span class="line">通用命令:</span><br><span class="line">    keys:  -&gt; 大数据量可能出现卡死现象,推荐使用scan(游标).   o(n)</span><br><span class="line">    dbsize:                                             o(1)</span><br><span class="line">    exists key:                                         o(1)</span><br><span class="line">    del key [key ...]:                                  o(1)</span><br><span class="line">    expire key seconds:                                 o(1)</span><br><span class="line">    ttl:    -1 代表key存在,并且没有过期时间.        </span><br><span class="line">    persist key:                                  </span><br><span class="line">    type key: 返回key的类型. none 表示key不存在.</span><br><span class="line">    incr,decr,incrby,decyby,incrbyfloat</span><br><span class="line">    getrange,setrange -&gt; getrange key start end  | setrange key index value</span><br><span class="line">    mget,mset</span><br><span class="line">    append,strlen</span><br></pre></td></tr></table></figure>
<h3 id="数据结构和内部编码"><a href="#数据结构和内部编码" class="headerlink" title="数据结构和内部编码"></a>数据结构和内部编码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">String -&gt;sds -&gt; raw,int,embstr</span><br><span class="line">    阈值 - 512MB</span><br><span class="line">    1.sds.</span><br><span class="line">      数据结构.</span><br><span class="line">        struct  sdsher&#123;</span><br><span class="line">            &#x2F;&#x2F;记录buf中已保存字符的长度</span><br><span class="line">            &#x2F;&#x2F;等于SDS所保存的字符串的长度</span><br><span class="line">            int  len;</span><br><span class="line">            &#x2F;&#x2F;记录buf数组中未使用字节的数量</span><br><span class="line">            int free;</span><br><span class="line">            &#x2F;&#x2F;字节数组，用于保存字符串</span><br><span class="line">            char buf[];</span><br><span class="line">        &#125;;</span><br><span class="line">     优点.</span><br><span class="line">        1.获取字符串长度O(1),非O(N).</span><br><span class="line">        2.原生str缓冲区溢出.</span><br><span class="line">          c语言字符串未记录长度,append操作可能出现缓冲区溢出情况.</span><br><span class="line">        3.原生str内存泄漏.</span><br><span class="line">          c语言字符串未记录长度,trim操作可能出现内存泄漏现象(未截取到的字符串可能没有回收).    </span><br><span class="line">        4.空间预分配.</span><br><span class="line">          if(length&lt;1MB) length*&#x3D;2;</span><br><span class="line">          if(length&gt;1MB) length&#x3D;length+1MB+1(末尾字符).</span><br><span class="line">hash   -&gt; hashtable,ziplist</span><br><span class="line">          ziplist  -&gt;  并不是压缩的意思,意思是将所有的元素的二进制紧凑的联系在一起(list-length(byte)、last entry offset、entry(content,entry-size)).</span><br><span class="line">          ziplist 有点像请求报文,极致压缩.空间换取时间.</span><br><span class="line">list   -&gt; linkedlist,ziplist</span><br><span class="line">set    -&gt; hashtable,intset</span><br><span class="line">  intset  -&gt;元素有序，不可重复.</span><br><span class="line">zset   -&gt; skiplist,ziplist</span><br><span class="line">  skiplist -&gt; 索引为zset的score,value为zset的member.</span><br><span class="line">                            数据结构有点像B+树.</span><br></pre></td></tr></table></figure>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.发送到redis的指令将会被放入到一个队列中,redis单线程执行队列中的指令.</span><br><span class="line">  1.纯内存.(主要原因)</span><br><span class="line">  2.非阻塞IO.  I&#x2F;O Multiplexing</span><br><span class="line">  3.避免线程切换和竞态消耗.</span><br><span class="line">2.拒绝长命令.</span><br><span class="line">  keys,flushall,flushdb,slow lua script,mutil&#x2F;exec,operate big value(collection).</span><br></pre></td></tr></table></figure>
<h2 id="redis其他功能"><a href="#redis其他功能" class="headerlink" title="redis其他功能"></a>redis其他功能</h2><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.生命周期.</span><br><span class="line">  client -&gt; send command -&gt; command 在Redis 服务器中排队(队列),排队后执行命令 -&gt; 返回命令执行结果 -&gt; client 处理结果.</span><br><span class="line">2.两个配置.</span><br><span class="line">  慢查询数据结构  -&gt;  先进先出队列+固定长度+保存在内存中.</span><br><span class="line">  slowlog-log-slower-than (1ms)   -&gt;   command 执行 阈值.</span><br><span class="line">  slowlog-max-len   (1000)        -&gt;   先进先出队列长度.</span><br><span class="line">3.慢查询命令.</span><br><span class="line">  slowlog  get[n]           -&gt;   获取慢查询队列.</span><br><span class="line">  slowlog  len              -&gt;   获取慢查询队列长度.</span><br><span class="line">  slowlog  reset            -&gt;   清空慢查询队列.</span><br><span class="line">4.慢查询只监控命令执行消耗时间,不包含排队,网络时间.</span><br></pre></td></tr></table></figure>
<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.生命周期.</span><br><span class="line">  client -&gt; send pipeline ( command 1,command  2...commandn)    </span><br><span class="line">         -&gt; redis server 计算n次</span><br><span class="line">         -&gt; redis server 返回结果(res 1,res 2... resn)</span><br><span class="line">   一次网络时间 + n次命令时间</span><br><span class="line">          毫秒级别          微秒级别</span><br><span class="line">2.原生的m操作.</span><br><span class="line">  如:mset,mget.</span><br><span class="line">3.m操作与pipeline操作对比.</span><br><span class="line">  m操作 -&gt; 原子性,原语(执行一组指令,不会被中断).</span><br><span class="line">  pipeline -&gt; 非原子</span><br><span class="line">  pipeline 会拆分成 pipeline子命令.与其他的命令穿插在一起执行.</span><br><span class="line">4.pipeline使用注意点.</span><br><span class="line">    1.每次pipeline携带数据量.</span><br><span class="line">    2.pipeline每次只能作用在一个Redis节点上.</span><br><span class="line">    3.M操作与pipeline区别.</span><br><span class="line">5.发布订阅.</span><br><span class="line">    角色    -&gt;   发布者(publisher)、订阅者(subscriber)、频道(channel)。</span><br><span class="line">  API: </span><br><span class="line">      publish&#x2F;subscribe&#x2F;unsubscribe.</span><br><span class="line">    发布: publish  channel message</span><br><span class="line">       unsubscribe</span><br><span class="line">       psubscribe [pattern]</span><br><span class="line">       punsubscribe [pattern]</span><br><span class="line">       pubsub   channels    # 列出至少有一个订阅者的频道</span><br><span class="line">       pubsub   numsub  [channel..] # 列出channel的订阅者数量</span><br><span class="line">6.消息队列. -&gt; 消息只有一个消息订阅者消费.</span><br><span class="line">    消息发布者               -&gt;  (发布消息)  -&gt;       Redis Server</span><br><span class="line">  redis cli                                  |(抢)      </span><br><span class="line">                                      消息订阅者、消息订阅者、消息订阅者。          </span><br><span class="line">                                      redis-cli  redis-cli  redis-cli</span><br><span class="line">  redis本身未实现消息队列,redis是通过 list数据结构和客户端阻塞poll操作实现。</span><br><span class="line">  taps: 抢红包可以用消息队列.</span><br></pre></td></tr></table></figure>
<h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">getbit key index  获取key对应index上的character.</span><br><span class="line">setbit key offset value</span><br><span class="line">bitcount key start end</span><br><span class="line">bitop  [op]  destkey [key,key] 将多个bitmap的and,or,not,xor操作结果保存在destkey中.</span><br><span class="line">  如 bitop and a-b a b</span><br><span class="line">bitpos key [targetbit] [start] [end]  计算位图start - end中,第一个偏移量对应的值等于targetBit的位置.</span><br><span class="line">1.位图的好处.</span><br><span class="line">    降低存储空间.</span><br><span class="line">    场景: 枚举 转换成位图.</span><br><span class="line">2.位图使用注意点.</span><br><span class="line">    1.type&#x3D;string -&gt; 最大512MB.</span><br><span class="line">    2.注意setbit的偏移量,可能有较大耗时.</span><br><span class="line">    3.位图不是绝对好.</span><br></pre></td></tr></table></figure>
<h3 id="hyperloglog"><a href="#hyperloglog" class="headerlink" title="hyperloglog"></a>hyperloglog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hyperloglog算法  -  极小空间完成独立数量统计.</span><br><span class="line">数据结构    -  字符串</span><br><span class="line">pfadd  key  element [element]   -&gt;  向hyperloglog添加元素</span><br><span class="line">pfcount key [key]   -&gt;  计算hyperloglog的独立总数</span><br><span class="line">pfmerge destkey  sourcekey [sourcekey..]  -&gt;  合并多个hyperloglog</span><br><span class="line"></span><br><span class="line">tips: 用于计数,内存消耗特别小.</span><br><span class="line">            缺点:  错误率: 0.81%</span><br><span class="line">                        不能获取单条数据(单条数据根本没存)</span><br></pre></td></tr></table></figure>
<h3 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GEO (地理信息定位):  存储经纬度,计算两地距离,范围计算.</span><br><span class="line">geoadd  key     longitude   latitude    member  [longitude  latituvcde member] ...</span><br><span class="line">geopos  key     member      [member ...]</span><br><span class="line">获取指定范围内的地理位置信息集合</span><br><span class="line"> georadis key    longitude   latitude    radiusm|km|ft [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</span><br><span class="line">    withcoord   -&gt; 结果包含经纬度</span><br><span class="line">    withdist    -&gt; 结果包含距离中心节点位置</span><br><span class="line">    </span><br><span class="line">例: geoadd cities:locations  116.28  39.55  beijing</span><br><span class="line">    geoadd cities:locations  xx      yy     shanghai</span><br><span class="line">    geodist cities:locations  beijing  tianjin  km</span><br><span class="line">说明: GEO -&gt; zset</span><br><span class="line">    zrem key member 进行删除</span><br></pre></td></tr></table></figure>
<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.bgsave过程中新插入的值会不会持久化?</span><br><span class="line">    不会,因为bgsave是copy-on-write机制,子进程会在一开始复制父进程的快照.</span><br><span class="line"><span class="number">2</span>.aof append操作流程.</span><br><span class="line">  command -&gt; aof_buf -&gt; 将aof_buf中的内容写入和保存到AOF文件中. </span><br><span class="line">  appendfsync -&gt; aof_buf同步到文件策略</span><br><span class="line">        always -&gt; </span><br><span class="line">        everysec -&gt;间隔<span class="number">1</span>s同步缓存到文件</span><br><span class="line">  若同步时候有新插入的值,会将新插入的值放入aof_buf中.</span><br><span class="line"><span class="number">3</span>.aof rewrite过程中新插入的值会不会持久化?</span><br><span class="line">  会,aof rewrite时,父进程在写aof_buf的时候同时会写aof_rewrite_buf,在子进程写完aof文件时候 ,父进程会将aof_rewrite_buf发到子进程,子进程会将其写入aof文件.</span><br><span class="line"><span class="number">4</span>.AOF append 阻塞.</span><br><span class="line">   主线程写command到aof buf,若对比上次fsync时间大于<span class="number">2</span>s,则会阻塞.</span><br></pre></td></tr></table></figure>
<h3 id="持久化作用"><a href="#持久化作用" class="headerlink" title="持久化作用"></a>持久化作用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis 持久化  -&gt; 异步地将对数据的更新保存到磁盘上.</span><br><span class="line">持久化方式 </span><br><span class="line">    -&gt; 快照 &#x2F; 写日志</span><br><span class="line">     快照  -&gt;  MySQL Dump,Redis RDB</span><br><span class="line">  写日志 -&gt;  MySQL Binlog,Hbase Hlog,Redis AOF.</span><br></pre></td></tr></table></figure>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.RDB触发三种方式.</span><br><span class="line">  1.save(同步).</span><br><span class="line">  2.bgsave(异步).</span><br><span class="line">    fork -&gt; createRDB, </span><br><span class="line">            copy on write&#x3D;&gt;若父进程内存空间未改变,则子进程在写rdb文件时候,虚拟空间指向父进程的虚拟空间指向的物理空间.</span><br><span class="line">  3.自动(配置).</span><br><span class="line">     save  time changes</span><br><span class="line">     dbfilename dump.db</span><br><span class="line">     dir .&#x2F;</span><br><span class="line">     stop-writes-on-bgsave-error yes</span><br><span class="line">     rdbcompression yes #压缩,开启压缩主从赋值 </span><br><span class="line">     rdbcheckssum   yes</span><br><span class="line">2.其他触发方式.</span><br><span class="line">  1.全量复制.</span><br><span class="line">        主从复制,主会进行rdb.</span><br><span class="line">  2.debug reload.</span><br><span class="line">  3.shutdown.</span><br><span class="line">3.缺点.</span><br><span class="line">  1.O(n)数据:耗时.</span><br><span class="line">  2.fork()创建子进程,消耗内存.</span><br><span class="line">  3.Disk I&#x2F;O: IO性能.</span><br><span class="line">  4.不可控,丢失数据(rdb配置的间隔内宕机,则会丢失数据).</span><br><span class="line">4.RDB生成流程.</span><br><span class="line">  bgsave</span><br><span class="line">        子进程生成RDB文件,父进程继续响应其他指令(新数据不会在生成的rdb文件中),子进程将原有RDB文件进行替换.</span><br></pre></td></tr></table></figure>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">1.AOF -&gt; 用于数据恢复,数据不丢失.</span><br><span class="line">2.AOF三种策略.</span><br><span class="line">  always    -&gt;      每条命令,fsync到硬盘. IO开销较大.</span><br><span class="line">  everysec  -&gt;      每秒把缓冲区fsync到硬盘.丢一秒数据.</span><br><span class="line">  no        -&gt;      os决定fsync.</span><br><span class="line">3.AOF流程.</span><br><span class="line">    命令  append AOF缓冲  sync AOF文件.</span><br><span class="line">      aof可配1s策略,1s可是10万qps,所以缓冲批处理性能很优秀.</span><br><span class="line">3.AOF重写.</span><br><span class="line">  AOF rewrite -&gt; 将当前内存中的数据变成指令写到日志中.</span><br><span class="line">      rewirte优点:  减少磁盘占用量.加速数据恢复速度.</span><br><span class="line">  AOF重写两种实现方式.</span><br><span class="line">   1. bgrewriteaof -&gt; fork</span><br><span class="line">   2. AOF重写配置</span><br><span class="line">      auto-aof-rewrite-min-size</span><br><span class="line">      auto-aof-rewrite-percentage 增长率</span><br><span class="line">  统计项.</span><br><span class="line">   1.aof_current_size  AOF当前尺寸</span><br><span class="line">   2.aof_base_size     AOF上次启动和重写的尺寸</span><br><span class="line">4.AOF重写流程.</span><br><span class="line">  bgrewriteaof </span><br><span class="line">     -&gt; fork</span><br><span class="line">   父进程 执行 command,将结果放到aof_buf文件和aof_rewrite_buf缓存中.</span><br><span class="line">   子进程 写aof文件.</span><br><span class="line">   父进程 将aof_rewrite_buf合并到aof文件中.</span><br><span class="line">   子进程 用新aof文件替换旧aof文件.</span><br><span class="line">5.aof配置.</span><br><span class="line">  appendonly yes</span><br><span class="line">  appendfilename &quot;appendonly-$&#123;port&#125;.aof&quot;</span><br><span class="line">  appendfsync   everysync</span><br><span class="line">  dir &#x2F;bigdiskpath</span><br><span class="line">  no-appendfsync-on-rewrite yes  #aof重写时,不执行其他命令.</span><br><span class="line">  auto-aof-rewrite-percentage 100</span><br><span class="line">  auto-aof-rewrite-min-size 64mb</span><br><span class="line">  aof-load-truncated yes #aof出现错误则不加载.</span><br></pre></td></tr></table></figure>
<h3 id="RDB和AOF抉择"><a href="#RDB和AOF抉择" class="headerlink" title="RDB和AOF抉择"></a>RDB和AOF抉择</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动优先级: AOF &gt; RDB</span><br><span class="line">体积:      AOF &gt; RDB  AOF重写有可能变小</span><br><span class="line">恢复速度:   RDB&gt;AOF   AOF要执行命令</span><br><span class="line">数据安全性    AOF&gt;RDB   AOF可能丢失1s</span><br><span class="line">轻重              AOF&lt;RDB   AOF只是追加日志</span><br><span class="line">AOF -&gt; 数据恢复</span><br><span class="line">RDB -&gt; 主从同步</span><br></pre></td></tr></table></figure>
<h3 id="持久化常见的运维问题"><a href="#持久化常见的运维问题" class="headerlink" title="持久化常见的运维问题"></a>持久化常见的运维问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.fork.</span><br><span class="line">  1.同步操作，内存页拷贝.</span><br><span class="line">  2.与内存，机器类型有关.</span><br><span class="line">  3.info: latest_fork_usec. 查看持久化执行时间.</span><br><span class="line">  4.改善.</span><br><span class="line">    1.使用物理机或高效支持fork操作的虚拟化技术.</span><br><span class="line">    2.redis最大可用内存:maxmemory.</span><br><span class="line">    3.合理配置Linux内存分配策略: vm.overcommit_memory&#x3D;1.</span><br><span class="line">    4.降低AOF重写的自动触发时机.</span><br><span class="line">  5.开销.</span><br><span class="line">    1.RDB和AOF文件生成,属于CPU密集型.</span><br><span class="line">    2.内存: copy-on-write,父子进程共享内存页(父进程改变则复制).</span><br><span class="line">    3.硬盘: AOF和RDB文件开销,结合iostat,iotop工具分析.推荐ssd磁盘.</span><br><span class="line">2.AOF追加阻塞.</span><br><span class="line">    主线程 往  aof buf 写数据, 对比上次fsync时间,若大于2秒则阻塞主线程,直到同步线程将数据同步到硬盘中.</span><br></pre></td></tr></table></figure>
<h2 id="Redis复制的原理与优化"><a href="#Redis复制的原理与优化" class="headerlink" title="Redis复制的原理与优化"></a>Redis复制的原理与优化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.通过RDB进行主从复制时候,新写入的数据会不会同步过去?</span><br><span class="line">    虽然单机RDB基于copy on write，新写的数据不会在rdb文件，但是</span><br><span class="line">    在进行主从同步时候,RDB会将新写入的数据放入缓存通道中，然后再根据缓存生成二进程文件传递给从服务器.</span><br></pre></td></tr></table></figure>
<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">一主多从,高可用</span><br><span class="line">                -   redis slave (copy)</span><br><span class="line">    master      -   redis slave (copy)</span><br><span class="line">                -   redis slave (copy)</span><br><span class="line">读写分离,数据流向是单向的,master到slave.</span><br><span class="line">1.实现方式.</span><br><span class="line">  1.命令.  </span><br><span class="line">    slaveof masterIp port</span><br><span class="line">    slaveof on one</span><br><span class="line">  2.配置.  </span><br><span class="line">    slaveof ip port</span><br><span class="line">    slave-read-only yes</span><br><span class="line">    info replication -&gt; 查看节点状态</span><br><span class="line">2.runid和复制偏移量.</span><br><span class="line">    runid  -&gt; 标识 </span><br><span class="line">        $&gt;redis-cli -p  6379 info server | grep run</span><br><span class="line">          run_id: .....</span><br><span class="line">    偏移量   -&gt; master 与 slave 偏移量 一致,则说明数据已同步.</span><br><span class="line">        $&gt;redis-cli -p  6379 info replication |  grep offset</span><br><span class="line">          master_repl_offset:1950</span><br><span class="line">        $&gt;redis-cli -p  6380 info replication |  grep offset</span><br><span class="line">          slave_repl_offset:1978</span><br><span class="line">3.全量复制.</span><br><span class="line">   master                       slave</span><br><span class="line">        1.slave执行</span><br><span class="line">          psync ? -1  ?是runid,-1是offset</span><br><span class="line">        2.master</span><br><span class="line">                    返回master的&#123;runId&#125; &#123;offset&#125;</span><br><span class="line">        3.slave</span><br><span class="line">          save masterInfo</span><br><span class="line">        4.master</span><br><span class="line">          bgsave 生成rdb + send rdb</span><br><span class="line">        5.master </span><br><span class="line">          write send buffer(新数据) -&gt;  repl_back_buffer</span><br><span class="line">        6.master</span><br><span class="line">          send buffer(新数据)</span><br><span class="line">        7.slave</span><br><span class="line">          flush old data 清空老数据(不属于master的数据)</span><br><span class="line">        8.slave</span><br><span class="line">          load rdb.</span><br><span class="line">4.部分复制.</span><br><span class="line">       1.slave</span><br><span class="line">         connection loss或宕机</span><br><span class="line">       2.master</span><br><span class="line">         write send buffer repl_back_buffer (复制积压缓冲区)</span><br><span class="line">       3.slave</span><br><span class="line">         connection to master</span><br><span class="line">       4.slave</span><br><span class="line">         psync &#123;offset&#125; &#123;runId&#125;</span><br><span class="line">       5.master</span><br><span class="line">         continue</span><br><span class="line">       6.master</span><br><span class="line">         send partial data</span><br><span class="line">5.故障处理.</span><br><span class="line">   slave  挂了,连接slave的client连接其他slave</span><br><span class="line">   master 挂了,找一个slave,执行 slaveof no one成为新master,其他slave成为新master的slave.</span><br><span class="line">  自动处理.</span><br><span class="line">   sentinel</span><br><span class="line">6.开发与运维中的问题.</span><br><span class="line">  1.读写分离.</span><br><span class="line">        读流量分摊到从节点.</span><br><span class="line">        问题:</span><br><span class="line">       1.复制数据延迟.</span><br><span class="line">                  复制慢,读到老数据.</span><br><span class="line">       2.读到过期数据.</span><br><span class="line">         redis删除过期数据.</span><br><span class="line">           1.懒惰形: 操作key是查看key是否过期.</span><br><span class="line">           2.定时任务: 对key进行采样,判断key是否过期.</span><br><span class="line">         由于slave不能执行写操作,所以不能删除过期的数据.</span><br><span class="line">       3.从节点故障.</span><br><span class="line">  2.主从配置不一致.</span><br><span class="line">    1.maxmemory.</span><br><span class="line">      master -&gt; 4GB</span><br><span class="line">      slave  -&gt; 2GB</span><br><span class="line">      这时候slave写数据若内存不足,将会执行内存淘汰策略.</span><br><span class="line">    2.数据结果优化参数(hash-max-ziplist-entries):内存不一致.</span><br><span class="line">  3.规避全量复制.</span><br><span class="line">    1.第一次全量复制.</span><br><span class="line">       slave第一次挂到master上.</span><br><span class="line">    2.节点runID不匹配.</span><br><span class="line">            主节点重启.</span><br><span class="line">            故障转移主节点变更.</span><br><span class="line">            从节点保留主节点的runid,若从节点发现与主节点的runid不一致时候,则会触发全量复制.</span><br><span class="line">    3.复制积压缓冲区. </span><br><span class="line">            复制积压缓冲区   -&gt;  缓存缺失的命令.</span><br><span class="line">            缓冲区大小可以设置为  -&gt;  掉线的秒数*每秒的写命令数 *2(*2比较保险)</span><br><span class="line">  4.规避复制风暴.</span><br><span class="line">            复制风暴:</span><br><span class="line">                master宕机，master重启后runid变化,所有slave需要全量复制.</span><br><span class="line">            解决方式:</span><br><span class="line">                更改TOPO结构.  </span><br><span class="line">                master -&gt; slave1,...slaven</span><br><span class="line">                改 maste -&gt; slave1 -&gt; slave11....slave1n</span><br></pre></td></tr></table></figure>
<h2 id="Redis-Sentinal"><a href="#Redis-Sentinal" class="headerlink" title="Redis Sentinal"></a>Redis Sentinal</h2><h3 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis Sentinel"></a>Redis Sentinel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.问题?</span><br><span class="line">    1.手动故障转移.        -&gt;  master故障,slave故障.</span><br><span class="line">    2.写能力和存储能力受限. -&gt;  master写</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/18/redis/redis-sentinel.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Redis Sentinel故障转移.</span><br><span class="line">  1.多个sentinel发现并确认master有问题.</span><br><span class="line">  2.选举一个sentinel作为领导.</span><br><span class="line">  3.选举一个slave作为master.</span><br><span class="line">  4.通知剩余的slave成为新master的slave.</span><br><span class="line">  5.通知客户端主从变化.</span><br><span class="line">  6.等待老的master复活成为新master的slave.</span><br></pre></td></tr></table></figure>
<h3 id="Redis-Sentinel-安装和配置"><a href="#Redis-Sentinel-安装和配置" class="headerlink" title="Redis Sentinel 安装和配置"></a>Redis Sentinel 安装和配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.配置开启主从节点.</span><br><span class="line">2.配置开启sentinel监控主节点.(sentinel是特殊的redis).</span><br><span class="line">  sentinel主要配置.</span><br><span class="line">  port $&#123;port&#125;</span><br><span class="line">  dir &quot;&#x2F;opt&#x2F;soft&#x2F;redis&#x2F;data&quot;</span><br><span class="line">  logfile &quot;$&#123;port&#125;.log&quot;</span><br><span class="line">  sentinel monitor mymaster 127.0.0.1 7000 2    # 2 -&gt; 2个sentinel发现master出故障了,开始故障转移.</span><br><span class="line">  sentinel down-after-millseconds mymaster 30000    # 30000 30秒后 ping 不同则说明master故障了.</span><br><span class="line">  sentinel paraller-syncs mycluster 1               # 新master同时向slave复制数据的机器数</span><br><span class="line">  sentinel failover-timeout mycluster 180000        # 故障转移时间</span><br><span class="line">3.客户端连接sentinel.</span><br><span class="line">  tps:客户端是连接sentinel而不是master和slave.sentinel可以调用api获取master和slaves.</span><br><span class="line">  redis-cli -p 26379</span><br></pre></td></tr></table></figure>
<h3 id="Redis-Sentinel-Java-Client使用"><a href="#Redis-Sentinel-Java-Client使用" class="headerlink" title="Redis Sentinel Java Client使用"></a>Redis Sentinel Java Client使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">客户端实现基本原理:</span><br><span class="line">  1.初始化. </span><br><span class="line">       1. client   (Sentinel节点集合 + masterName )   -&gt;  sentinel-1,sentinel-2....sentinel-N</span><br><span class="line">                   client 遍历 sentinel节点集合,获取一个可用的sentinel节点.</span><br><span class="line">       2.  client                  sentinel-k</span><br><span class="line">            1.client &#x3D;&gt; sentinel get-master-addr-by-name masterName</span><br><span class="line">            2.sentinel-k &#x3D;&gt; 返回redis的master节点</span><br><span class="line">       3.  client                   master</span><br><span class="line">            1.role &#x2F; role replication </span><br><span class="line">            2.master 返回节点角色.</span><br><span class="line">  2.master变更.</span><br><span class="line">      client  &lt;&#x3D;&gt;  sentinel </span><br><span class="line">        publish&#x2F;subscribe</span><br><span class="line">      client sub sentinel的一个通道，当master变更时候,sentinel会发送master变更的原理.</span><br><span class="line">  3.非代理模式.</span><br><span class="line">    redis client 从 sentinel 获取master信息,</span><br><span class="line">        之后直接根据master去请求redis server.</span><br></pre></td></tr></table></figure>
<h3 id="Redis-Sentinel-三个定时任务"><a href="#Redis-Sentinel-三个定时任务" class="headerlink" title="Redis Sentinel 三个定时任务"></a>Redis Sentinel 三个定时任务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.每10s每个sentinel对master和slave进行info.</span><br><span class="line">  1.发现slave节点.</span><br><span class="line">  2.确认主从关系.</span><br><span class="line">2.每2秒,每个sentinel通过master节点的channel进行交换信息(pub&#x2F;sub).</span><br><span class="line">  sentinel 与sentinel之间进行信息交换.</span><br><span class="line">    频道: __sentinel__:hello</span><br><span class="line">3.每1秒,每个sentinel对其他sentinel和redis执行ping.</span><br><span class="line">  心跳检测-&gt;故障检测.</span><br></pre></td></tr></table></figure>
<h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; quorum -&gt; 法定人数</span><br><span class="line">sentinel  monitor  &lt;masterName&gt;  &lt;ip&gt; &lt;port&gt; &lt;quorum&gt;</span><br><span class="line">主观下线  sentinel 对 redis 节点ping后失败,再ping一次</span><br><span class="line">sentinel  down-after-milliseconds &lt;mastername&gt; &lt;timeout&gt;</span><br><span class="line"></span><br><span class="line">客观下线  -&gt;  所有的sentinel节点对Redis节点失败达成共识(通过quorum同意). sentinel is-master-down-by-addr</span><br></pre></td></tr></table></figure>
<h3 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">原因: 只需要一个sentinel就能完成故障转移.</span><br><span class="line">选举: sentinel is-master-down-byaddr命令都希望成为领导者.</span><br><span class="line">    raft算法.</span><br><span class="line">    1.每个做主观下线的Sentinel节点向其他sentinel节点发送命令,要求设置它为领导者.</span><br><span class="line">    2.收到命令的Sentinel节点如果没有同意通过其他Sentinel节点发送的命令,那么将同意该请求,否则将拒绝.</span><br><span class="line">    3.如果该sentinel节点发现自己的票数已经超过quorum,则它会成为领导者.</span><br><span class="line">    4.如果此过程有多个Sentinel节点成为了领导者,那么将等待一段时间重新进行选举.</span><br></pre></td></tr></table></figure>
<h4 id="raft算法"><a href="#raft算法" class="headerlink" title="raft算法"></a>raft算法</h4><p><img src="/2020/08/18/redis/raft.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">raft -&gt; 分布式系统一致性协议</span><br><span class="line">1.角色 -&gt; leader,follower(投票者),candidate(候选者)</span><br><span class="line">2.follower 有一个倒计时器  -&gt;  Election Timeout(150ms-300ms),若timeout为0,则follower会变为candidate.</span><br><span class="line">  Election Timeout 重设的两种情况.</span><br><span class="line">      1.follower收到leader的heartbeat.</span><br><span class="line">      2.follower收到candidate的RequestVote.</span><br><span class="line">3.leader选举的过程.</span><br><span class="line">   简易流程: follower election timeout 计时器为0,follower成为Candidate,发起投票,当自己收到majority的票后成为leader.</span><br><span class="line">   特点:majority+first-come-first-served+timeout(投票超时)</span><br><span class="line">4.选举流程细节.</span><br><span class="line">  1.term(任期) -&gt; election + normal operation</span><br><span class="line">         当新的election发生时候,term会更新.</span><br><span class="line">  2.candidate处理其他节点的信息,可能出现的三种结果.</span><br><span class="line">    1.收到majority的投票,则赢得选举,成为leader.</span><br><span class="line">    2.被告知其他人已当选,则切换到follower.</span><br><span class="line">    3.若在指定时候未收到majority的投票也没告知其他人已当选,则发起新一轮选举.</span><br><span class="line">    情况3主要是平票的情况(概率低).</span><br></pre></td></tr></table></figure>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.故障转移的整个过程.</span><br><span class="line">    1.从slave节点中选出一个合适的节点作为新的master节点.</span><br><span class="line">    2.对上面的slave节点执行slaveof no one 命令让其成为master节点.</span><br><span class="line">    3.向剩余的slave节点发送命令,让它们成为新master节点的slave节点,复制规则和parallel-syncs参数有关.</span><br><span class="line">      parallel-syncs -&gt; 并发复制的slave数,若为1,则master将会串行的将rdb文件一个一个发给slave.</span><br><span class="line">    4.更新对原来的master节点配置为slave,并保持着对齐关注,当其恢复后命令它去复制新的master节点.</span><br><span class="line">2.发生故障时候,如何选择合适的slave节点？</span><br><span class="line">  1.选择slave-priority(slave节点优先级)最高的slave节点,如果存在则返回,不存在则继续.</span><br><span class="line">  2.选择复制偏移量最大的slave节点(复制的最完整),如果存在则返回,不存在则继续.</span><br><span class="line">  3.选择runId最小的节点(启动最早的节点).</span><br></pre></td></tr></table></figure>
<h3 id="开发运维问题"><a href="#开发运维问题" class="headerlink" title="开发运维问题"></a>开发运维问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.节点运维.</span><br><span class="line">  1.主节点,从节点,sentinel节点.</span><br><span class="line">        机器下线: 例如过保问题.</span><br><span class="line">    机器性能不足: 例如CPU、内存、硬盘、网络.</span><br><span class="line">    节点自身故障: 例如服务不稳定等.</span><br><span class="line">2.高可用读写分离.</span><br><span class="line">  1.redis client 会订阅+switch-master频道(masterListener)感知主从切换(从生主).</span><br><span class="line">    若主从切换,则对redis连接池进行重新初始化.</span><br><span class="line">  2.redis client 会订阅+convert-to-slave:切换从节点(原主降从).</span><br><span class="line">  3.+sdown:主观下线.</span><br></pre></td></tr></table></figure>
<h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><h3 id="呼唤集群"><a href="#呼唤集群" class="headerlink" title="呼唤集群"></a>呼唤集群</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.并发量.</span><br><span class="line">2.数据量.</span><br></pre></td></tr></table></figure>
<h3 id="数据分布概论"><a href="#数据分布概论" class="headerlink" title="数据分布概论"></a>数据分布概论</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.顺序分布.</span><br><span class="line">   1.数据关联性高,可顺序访问.</span><br><span class="line">   2.BigTable、Hbase.</span><br><span class="line">2.哈希分布.</span><br><span class="line">   1.数据较分散.</span><br><span class="line">   2.Memcache,Redis Cluster.</span><br><span class="line">   3.节点取余分区,一致性哈希分区,虚拟槽分区.</span><br><span class="line">     1.节点取余分区  -&gt; hash(key) % nodeSize</span><br><span class="line">             缺点: 节点伸缩后，要对所有的key重新分区.</span><br><span class="line">             改善: 翻倍扩容,只有一半的数据迁移.</span><br><span class="line">     2.一致性hash. -&gt; hash(key) + 顺时针(不是取余,是顺时针找比key大的node).</span><br><span class="line">         token &#x3D; 0~2^32</span><br><span class="line">      优点: 当节点比较多时候,节点伸缩时候影响的范围相对较小.</span><br><span class="line">      缺点: 若一个节点存在大量热点数据导致宕机,由于数据迁移可能导致整个环沿着顺时针挂掉.</span><br><span class="line">      解决方式: 将真实节点计算多个hash形成多个虚拟节点并放置到hash环上(真实节点不会放在hash环上,会多一步虚拟节点到真实节点的映射过程).</span><br><span class="line">     3.虚拟槽分区. -&gt; CRC16(key) &amp; 16383 &#x3D;&gt; &amp; 操作比取余操作更快</span><br><span class="line">      预设虚拟槽: 每个槽(slot)映射一个数据子集,一般比节点数大.</span><br></pre></td></tr></table></figure>
<h3 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h3><p><img src="/2020/08/18/redis/redis-cluster.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Redis Cluster</span><br><span class="line">1.服务端每个节点都可以读写(分片).</span><br><span class="line">2.服务端每个节点进行通信. &#x3D;&gt; meet操作.</span><br><span class="line">3.指派槽(slot),每个节点都会被指派多个槽.</span><br><span class="line">4.复制,高可用. 每个主节点都会有从节点,当主节点挂了之后,从节点就会补上来.     </span><br><span class="line">tips: 一个节点对应多个槽,一个槽对应一个data块.</span><br><span class="line">    添加一个节点,只需要将其他服务器的槽移动到新增的服务器上.</span><br><span class="line">    删除一个节点,只需要将删除服务器的槽移动到其他服务器上.</span><br></pre></td></tr></table></figure>
<h4 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.cluster-enabled: yes</span><br></pre></td></tr></table></figure>
<h3 id="原生安装"><a href="#原生安装" class="headerlink" title="原生安装"></a>原生安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">1.配置开启节点.</span><br><span class="line">  port $&#123;port&#125;</span><br><span class="line">  daemonize yes</span><br><span class="line">  dir &quot;&#x2F;opt&#x2F;redis&#x2F;redis&#x2F;data&#x2F;&quot;</span><br><span class="line">  dbfilename &quot;dump-$&#123;port&#125;.rdb&quot;</span><br><span class="line">  logfile &quot;$&#123;port&#125;.log&quot;</span><br><span class="line">  cluster-enabled yes</span><br><span class="line">  cluster-config-file nodes-$&#123;port&#125;.conf</span><br><span class="line">  cluster-node-timeout 15000 #故障转移(主观下线),节点超时(ping操作).</span><br><span class="line">  cluster-require-full-coverage yes #集群内所有节点提供服务,才认为集群是正常的</span><br><span class="line"> 开启:</span><br><span class="line">  redis-server redis-7000.cnf</span><br><span class="line">  redis-server redis-7001.cnf</span><br><span class="line">  ...</span><br><span class="line">  redis-server redis-7005.cnf</span><br><span class="line">2.meet.</span><br><span class="line">  redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7001</span><br><span class="line">  redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7002</span><br><span class="line">  ......</span><br><span class="line">  redis-cli -h 127.0.0.1 -p 7000 cluster meet 127.0.0.1 7005</span><br><span class="line">  两个不同的节点之间只需要一次握手操作.</span><br><span class="line">3.指配槽.</span><br><span class="line">  redis-cli -h 127.0.0.1 -p 7000 cluster addlots &#123;0...5461&#125;</span><br><span class="line">  redis-cli -h 127.0.0.1 -p 7001 cluster addlots &#123;5462...10922&#125;</span><br><span class="line">  ....</span><br><span class="line">4.主从.</span><br><span class="line">  redis-cli -h 127.0.0.1 -p 7003 cluster replicate $&#123;node-id-7000&#125;</span><br><span class="line">  .......</span><br><span class="line">  可以设置topo结构.</span><br><span class="line">  10.0.0.1:7000   10.0.0.2:7003</span><br><span class="line">  10.0.0.2:7001   10.0.0.3:7004</span><br><span class="line">  10.0.0.3:7002   10.0.0.1:7005</span><br></pre></td></tr></table></figure>
<h3 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1.伸缩原理.</span><br><span class="line">  槽和数据在节点之间的移动.</span><br><span class="line">2.集群扩容.</span><br><span class="line">  1.准备新节点.</span><br><span class="line">    配置:</span><br><span class="line">    1.开启集群模式.</span><br><span class="line">      cluster-enabled yes</span><br><span class="line">  2.加入集群.   </span><br><span class="line">    主节点: 迁移槽和数据实现扩容(伸缩)</span><br><span class="line">    从节点: 作为备份节点负责故障转移(冗余)</span><br><span class="line">    实现方式:</span><br><span class="line">       方式1: cluster meet</span><br><span class="line">       方式2(推荐方式): redis-trib.rb add-node  ip:port</span><br><span class="line">       $&gt;cluster nodes #观察集群配置</span><br><span class="line">  3.迁移槽和数据.</span><br><span class="line">  原理:</span><br><span class="line">    1.槽迁移计划.</span><br><span class="line">      根据节点的变化确定迁移槽计划(手动计算确立).</span><br><span class="line">    2.迁移数据.</span><br><span class="line">     1.target节点准备导入槽的数据.</span><br><span class="line">       cluster setslot &#123;slot&#125; importing &#123;sourceNodeId&#125;</span><br><span class="line">     2.src节点准备迁出槽的数据.</span><br><span class="line">       cluster setslot &#123;slot&#125; migrating &#123;targetNodeId&#125;</span><br><span class="line">    3.src节点循环执行cluster getkeysinslot &#123;slot&#125; &#123;count&#125;命令,获取count个属于槽的key.</span><br><span class="line">      槽有10000个数据,使用count为100的维度进行迁移,可以执行100次.</span><br><span class="line">    4.src节点执行migrate &#123;targetIp&#125; &#123;targetPort&#125; key 0 &#123;timeout&#125; </span><br><span class="line">      0 -&gt; 数据库,redis cluster 默认使用0号数据库</span><br><span class="line">      timeout -&gt;超时</span><br><span class="line">      对指定的key进行迁移.</span><br><span class="line">      tips: redis 3.2.8版本出现了pipeline migrate功能.</span><br><span class="line">    5.重复3,4操作,直到槽下所有的键数据都迁移到目标节点.</span><br><span class="line">    6.向集群所有主节点发送cluster setslot &#123;slot&#125; node &#123;targetNodeId&#125;,通知槽已分配到目标节点.</span><br><span class="line">  快捷操作:</span><br><span class="line">    有点像fdisk那种操作.</span><br><span class="line">    $&gt;redis-trib.rb reshard 127.0.0.1:7000 </span><br><span class="line">      4096 (迁移槽数)</span><br><span class="line">      a72....ebb(receiverID)</span><br><span class="line">      all(使用所有的非receiverID作为sourceId)</span><br><span class="line">   查看执行结果.</span><br><span class="line">    $&gt;redis-cli -p 7000 cluster slots</span><br><span class="line">3.集群缩容.</span><br><span class="line">    1.下线迁移槽.</span><br><span class="line">      redis-trib.rb reshard 127.0.0.1:7006</span><br><span class="line">    2.忘记节点.</span><br><span class="line">      tips:先忘记从节点,再忘记主节点,顺序颠倒会触发故障自动转移.</span><br><span class="line">      $&gt;redis-cli -p 7000 cluster forget &#123;6379&#125;</span><br><span class="line">      或者</span><br><span class="line">      $&gt;redis-trib.rb del-node 127.0.0.1:7000 &#123;7006的runid&#125;</span><br><span class="line">    3.关闭节点.</span><br></pre></td></tr></table></figure>
<h3 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h3><p><img src="/2020/08/18/redis/client-route.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.moved重定向.</span><br><span class="line">    1.客户端向redis cluster节点发送键命令到任意节点.</span><br><span class="line">    2.节点计算key的对应槽以及槽的对应节点.</span><br><span class="line">      crc16(key)%16383 -&gt; slot(int) -&gt; Connection</span><br><span class="line">    3.若key在当前节点所具有的槽中,则节点会执行命令.</span><br><span class="line">    4.若key不在当前节点所具有的槽中,则节点会返回moved异常(包含槽和目标节点信息).</span><br><span class="line">    5.客户端发送命令到目标节点.</span><br><span class="line"> tips: -c 指令会启动集群模式,在收到moved异常后会自动将key设置到目标节点.</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/18/redis/ask-exception.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2.ask重定向.(move是迁移完成结束,ask是正在迁移过程)</span><br><span class="line">   当redis节点发生slot迁移时候,由于redis 客户端存在node与slot的缓存,会导致数据一致性问题.</span><br><span class="line">   此时客户端获取key时候,源节点发现key正在被迁走,原节点会回复ask转向.</span><br><span class="line">   客户端执行asking命令,并发送命令到target节点</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如何解决客户端随机访问redis cluster引发的性能问题?</span><br><span class="line">3.smart客户端.</span><br><span class="line">   目标: 追求性能.</span><br><span class="line">  1.连接集群的任意一个节点,执行cluster slots获取所有槽和节点的映射并存储在本地.</span><br><span class="line">  2.对每个redis node创建JedisPool.</span><br><span class="line">  3.执行命令,若执行命令遇到数据槽迁移,具体流程如下.</span><br><span class="line">    收到moved异常后会刷新slot-&gt;node缓存.</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/18/redis/jedis-cluster-execute-command.png" alt></p>
<h3 id="JedisCluster使用"><a href="#JedisCluster使用" class="headerlink" title="JedisCluster使用"></a>JedisCluster使用</h3><h4 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;HostAndPort&gt;nodeList=<span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line">nodeList.add(<span class="keyword">new</span> HostAndPort(host1,port1));</span><br><span class="line">...</span><br><span class="line">JedisCluster jedisCluster = <span class="keyword">new</span> JedisCluster(nodeList,timeout,poolConfig);</span><br><span class="line">jedisCluster.command...</span><br></pre></td></tr></table></figure>
<h4 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.单例: JedisCluster内置了所有节点的连接池.</span><br><span class="line"><span class="number">2</span>.整合spring.</span><br><span class="line">JedisClusterFactory.</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisClusterFactory</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> JedisCluster jedisCluster;</span><br><span class="line">      <span class="keyword">private</span> List&lt;String&gt; hostPortList;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">      <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(JedisClusterFactory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">         JedisPoolConfig jedisPoolConfig=<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">         Set&lt;HostAndPort&gt;nodeSet=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">         <span class="keyword">for</span>(String hostPort: nodeSet)&#123;</span><br><span class="line">           String []arr=hostPort.split(<span class="string">":"</span>);</span><br><span class="line">           <span class="keyword">if</span>(arr.length!=<span class="number">2</span>)&#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           nodeSet.add(<span class="keyword">new</span> HostAndPort(arr[<span class="number">0</span>],Integer.parseInt(arr[<span class="number">1</span>])));</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span>&#123;</span><br><span class="line">           jedisCluster=<span class="keyword">new</span> JedisCluster(nodeSet,timeout,jedisPoolConfig);</span><br><span class="line">         &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">           logger.error(e.getMessage(),e);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jedisCluster!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">            jedisCLuster.close();</span><br><span class="line">          &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">spring-application.xml</span><br><span class="line">  &lt;bean id=<span class="string">"jedisClusterFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.....JedisClusterFactory"</span> init-method=<span class="string">"init"</span> destory-method=<span class="string">"destory"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"hostPortList"</span>&gt;</span><br><span class="line">      &lt;list&gt;</span><br><span class="line">        &lt;value&gt;127.0.0.1:7000&lt;/value&gt;</span><br><span class="line">      &lt;/list&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"timeout"</span> value=<span class="string">"1000"</span>&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">  &lt;/bean&gt;</span><br><span class="line">  &lt;bean id=<span class="string">"jedisCluster"</span> factory-bean=<span class="string">"jedisClusterFactory"</span> fatory-method=<span class="string">"getJedisCluster"</span>/&gt;</span><br><span class="line"><span class="number">3</span>.多节点命令使用.</span><br><span class="line">  Map&lt;String,JedisPool&gt; jedisPoolMap=jedisCluster.getClusterNodes();</span><br><span class="line">  <span class="keyword">for</span>(Entry&lt;String,JedisPool&gt;entry:jedisPoolMap.entrySet())&#123;</span><br><span class="line">    Jedis jedis=entry.getValue().getResource();</span><br><span class="line">    <span class="keyword">if</span>(!isMaster(jedis))&#123;<span class="comment">// cluster nodes </span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line"><span class="number">4</span>.批量操作.</span><br><span class="line">  tips: hmset,hmget的key是一个,不需要做额外处理.这里指的是mget,mset操作.</span><br><span class="line">  方式<span class="number">1</span>.串行mset.</span><br><span class="line">    <span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">      jedisCluster.set(key,map.get(key));</span><br><span class="line">    &#125;</span><br><span class="line">  方式<span class="number">2</span>.串行IO.</span><br><span class="line">    Map&lt;Jedis,List&lt;Key&gt;&gt;jedisKeyMap;</span><br><span class="line">    Map&lt;Slot,Jedis&gt;jedisSlotMap;</span><br><span class="line">    <span class="keyword">for</span>(String key:map.keySet())&#123;</span><br><span class="line">        Slot slot=CRC16(key)%<span class="number">16383</span>;</span><br><span class="line">        Jedis jedis= jedisSlotMap.get(slot);</span><br><span class="line">        jedisKeyMap.get(jedis).add(key);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(Jedis jedis:jedisKeyMap)&#123;</span><br><span class="line">        jedis.pipeline(jedisKeyMap.get(jedis));</span><br><span class="line">    &#125;</span><br><span class="line">  方式<span class="number">3</span>.并行IO.</span><br><span class="line">    <span class="keyword">for</span>(Jedis jedis:jedisKeyMap)&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">          jedis.pipeline(jedisKeyMap.get(jedis));</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">  方式<span class="number">4</span>.hash_tag.</span><br><span class="line">    key -&gt; hash_tag(key) -&gt; 让key每次都落到一个节点.</span><br></pre></td></tr></table></figure>
<h3 id="故障转移-1"><a href="#故障转移-1" class="headerlink" title="故障转移"></a>故障转移</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.故障发现.</span><br><span class="line">  1.ping &#x2F; pong ,无需依赖 redis sentinel.</span><br><span class="line">  2.主观下线,客观下线.</span><br><span class="line">    主观下线: cron定时任务,节点1与节点2的通信时间超过node-timeout标记的pfail状态.</span><br><span class="line">    tips: cron定时任务还可以删除过期的key.</span><br><span class="line">2.故障恢复.</span><br><span class="line">  1.资格检查. -&gt;  找slave,若slave的断线时间超过cluster-node-timeout * cluster-slave-validity-factor则取消资格.</span><br><span class="line">  2.准备选举时间. -&gt; 偏移量最大,优先级最高的节点选举延迟时间最小(先选举).</span><br><span class="line">  3.选举投票.     -&gt; 收集majority票数的slave节点可替换主节点.</span><br><span class="line">  4.替换主节点.   </span><br><span class="line">    1.slaveof no one    -&gt; 从变主</span><br><span class="line">    2.clusterDelSlot    -&gt; 撤销故障主节点负责的slot,并执行clusterAddSlot将那些故障的槽分给给自己.</span><br><span class="line">    3.向集群广播pong消息,表示已经替换了故障从节点.</span><br></pre></td></tr></table></figure>
<h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.client在redis server执行publish操作,其它的redis server都会收到消息,随即pub消息到sub的客户端.</span><br><span class="line">2.带宽会受到很大影响.</span><br></pre></td></tr></table></figure>
<h3 id="数据倾斜"><a href="#数据倾斜" class="headerlink" title="数据倾斜"></a>数据倾斜</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.节点和槽分配不均匀.</span><br><span class="line">  redis-trib.rb info ip:port 查看节点,槽,键值分布.</span><br><span class="line">2.不同槽对应的键值数量差异较大.</span><br><span class="line">  客户端搞hash_tag</span><br><span class="line">  cluster countkeysinslot &#123;slot&#125;</span><br><span class="line">3.包含bigkey.  bigkey是指key的value大,例如一个hash结构,value有10000个entry</span><br><span class="line">  redis-cli --bigkeys</span><br><span class="line">4.内存相关配置不一致. 如:ziplist,intset等每个节点配置不同.</span><br><span class="line">  配置:</span><br><span class="line">    hash-max-ziplist-value</span><br><span class="line">    set-max-intset-entries</span><br></pre></td></tr></table></figure>
<h3 id="集群vs单机"><a href="#集群vs单机" class="headerlink" title="集群vs单机"></a>集群vs单机</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.api改变</span><br><span class="line">  key批量操作: mset,mget</span><br><span class="line">  key事务和lua支持有限: 操作的key必须在一个节点.</span><br><span class="line">  key是数据分区最小粒度,不支持bigkey分区.</span><br><span class="line">  不支持多数据库: 集群模式下只有一个db 0.</span><br><span class="line">  复制只支持1层:不支持树形复制结构.</span><br><span class="line">2.性能改变.</span><br><span class="line">  1.redis cluster -&gt; 容量和性能高,但是很多应用不需要这个高的性能.</span><br><span class="line">    大多数时客户端性能会降低(没有单机和sentinel快).</span><br><span class="line">    跨节点命令无法使用 -&gt; mget,keys,scan,flush,sinter</span><br><span class="line">    lua和事务无法跨节点使用.</span><br><span class="line">    sdk和应用本身消耗(例如要对每个node建立连接池).</span><br><span class="line">  2.很多场景redis sentinel已经足够好.</span><br></pre></td></tr></table></figure>
<h2 id="缓存设计和优化"><a href="#缓存设计和优化" class="headerlink" title="缓存设计和优化"></a>缓存设计和优化</h2><h3 id="缓存的受益与成本"><a href="#缓存的受益与成本" class="headerlink" title="缓存的受益与成本"></a>缓存的受益与成本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.受益.</span><br><span class="line">  1.加速读写,读写快,类似CPU cache,Linux page cache加速硬盘读写,浏览器缓存,Ehcache缓存数据库.</span><br><span class="line">  2.降低后端缓存.  业务方通过redis降低后端mysql负载.</span><br><span class="line">2.成本.</span><br><span class="line">  1.数据一致性.  缓存存在时间窗口.</span><br><span class="line">  2.代码维护成本较高.</span><br><span class="line">  3.运维成本.</span><br><span class="line">3.使用场景.</span><br><span class="line">  1.高消耗的sql: join结果集&#x2F;分组统计结果缓存.</span><br><span class="line">  2.响应速度要求快.</span><br><span class="line">  3.大量写合并为批量写(缓冲).</span><br></pre></td></tr></table></figure>
<h3 id="缓冲更新策略"><a href="#缓冲更新策略" class="headerlink" title="缓冲更新策略"></a>缓冲更新策略</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.缓存置换算法.</span><br><span class="line">  LRU&#x2F;LFU&#x2F;FIFO</span><br><span class="line">  LRU  -&gt; 最少最久未使用</span><br><span class="line">2.超时剔除.</span><br><span class="line">3.主动更新: 开发控制生命周期.</span><br><span class="line">  cache-aside.</span><br><span class="line">建议: 超时剔除和主动更新结合,最大内存和淘汰策略兜底.</span><br></pre></td></tr></table></figure>
<h3 id="缓存穿透问题"><a href="#缓存穿透问题" class="headerlink" title="缓存穿透问题"></a>缓存穿透问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">缓存穿透 -&gt; 大量请求不命中(数据库中根本不存在)</span><br><span class="line">解法一: 缓存 key &lt; - &gt; null</span><br><span class="line">public String getPassThrough(String key)&#123;</span><br><span class="line">  String cacheValue&#x3D;cache.get(key);</span><br><span class="line">  if(StringUtils.isBlank(cacheValue))&#123;</span><br><span class="line">    String storageValue&#x3D;storage.get(key);</span><br><span class="line">    if(StringUtils.isBlank(storageValue))&#123;</span><br><span class="line">      cache.expire(key,60*5);</span><br><span class="line">    &#125;</span><br><span class="line">    return storageValue;</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return cacheValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">解法二: 布隆过滤器</span><br><span class="line">  布隆过滤器 -&gt; 相对于把全部数据缓存而言,空间很小,可以将全部的key映射到布隆过滤器上.</span><br></pre></td></tr></table></figure>
<h3 id="无底洞问题"><a href="#无底洞问题" class="headerlink" title="无底洞问题"></a>无底洞问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">墨菲定律: 硬件上达到一定程度,性能没有上去.</span><br><span class="line">优化:</span><br><span class="line">  1.命令本身优化 -&gt; keys,hgetall bigkey.</span><br><span class="line">  2.减少网络通信次数.</span><br><span class="line">  3.降低接入成本:例如客户端长连接,连接池,NIO等.</span><br></pre></td></tr></table></figure>
<h3 id="热点key的重建优化"><a href="#热点key的重建优化" class="headerlink" title="热点key的重建优化"></a>热点key的重建优化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">大量Thread 更新热点key,导致db击穿.</span><br><span class="line">解决方式: 加互斥锁.</span><br><span class="line">  String get(String key)&#123;</span><br><span class="line">    String value&#x3D;redis.get(key);</span><br><span class="line">    if(value&#x3D;&#x3D;null)&#123;</span><br><span class="line">      String mutexKey&#x3D;&quot;mutex:key:&quot;+key;</span><br><span class="line">      if(redis.set(mutexKey,&quot;1&quot;,&quot;ex 180&quot;,&quot;nx&quot;))&#123;</span><br><span class="line">        value&#x3D;db.get(key);</span><br><span class="line">        redis.set(key,value);</span><br><span class="line">        redis.delete(mutexKey);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        Thread.sleep(50);</span><br><span class="line">        get(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">优化:</span><br><span class="line">1.为value添加逻辑过期时间,当发现过期后会使用单独的线程构建缓存,其它线程无需sleep等待.</span><br><span class="line">String get(final String key)&#123;</span><br><span class="line">  </span><br><span class="line">  V v&#x3D;redis.get(key);</span><br><span class="line">  String value&#x3D;v.getValue();</span><br><span class="line">  long logicTimeout&#x3D;v.getLogicTimeout();</span><br><span class="line">  if(logicTimeout&gt;&#x3D;System.currentTimeMillis())&#123;</span><br><span class="line">    String mutexKey&#x3D;&quot;mutex:key:&quot;+key;</span><br><span class="line">    if(redis.set(mutexKey,&quot;1&quot;,&quot;ex 180&quot;,&quot;nx&quot;))&#123;</span><br><span class="line">      threadPool.execute(new Runnable()&#123;</span><br><span class="line">        public void run()&#123;</span><br><span class="line">          String dbValue&#x3D;db.get(key);</span><br><span class="line">          redis.set(key,(dbValue,newLogicTimeout));</span><br><span class="line">          redis.delete(keyMutex);</span><br><span class="line">          3</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>












    </div>

    
    
    
		<div>
			
				<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

			
		</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/12/quartz/" rel="prev" title="quartz">
      <i class="fa fa-chevron-left"></i> quartz
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/29/apollo-deploy/" rel="next" title="apollo-deploy">
      apollo-deploy <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#初始redis"><span class="nav-number">1.</span> <span class="nav-text">初始redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简介"><span class="nav-number">1.1.</span> <span class="nav-text">简介</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#API的理解和使用"><span class="nav-number">2.</span> <span class="nav-text">API的理解和使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通用命令"><span class="nav-number">2.1.</span> <span class="nav-text">通用命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构和内部编码"><span class="nav-number">2.2.</span> <span class="nav-text">数据结构和内部编码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单线程"><span class="nav-number">2.3.</span> <span class="nav-text">单线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redis其他功能"><span class="nav-number">3.</span> <span class="nav-text">redis其他功能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#慢查询"><span class="nav-number">3.1.</span> <span class="nav-text">慢查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pipeline"><span class="nav-number">3.2.</span> <span class="nav-text">pipeline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitmap"><span class="nav-number">3.3.</span> <span class="nav-text">bitmap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hyperloglog"><span class="nav-number">3.4.</span> <span class="nav-text">hyperloglog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Geo"><span class="nav-number">3.5.</span> <span class="nav-text">Geo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis持久化"><span class="nav-number">4.</span> <span class="nav-text">Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化作用"><span class="nav-number">4.1.</span> <span class="nav-text">持久化作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB"><span class="nav-number">4.2.</span> <span class="nav-text">RDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-number">4.3.</span> <span class="nav-text">AOF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB和AOF抉择"><span class="nav-number">4.4.</span> <span class="nav-text">RDB和AOF抉择</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化常见的运维问题"><span class="nav-number">4.5.</span> <span class="nav-text">持久化常见的运维问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis复制的原理与优化"><span class="nav-number">5.</span> <span class="nav-text">Redis复制的原理与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis主从复制"><span class="nav-number">5.1.</span> <span class="nav-text">Redis主从复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-Sentinal"><span class="nav-number">6.</span> <span class="nav-text">Redis Sentinal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Sentinel"><span class="nav-number">6.1.</span> <span class="nav-text">Redis Sentinel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Sentinel-安装和配置"><span class="nav-number">6.2.</span> <span class="nav-text">Redis Sentinel 安装和配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Sentinel-Java-Client使用"><span class="nav-number">6.3.</span> <span class="nav-text">Redis Sentinel Java Client使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Sentinel-三个定时任务"><span class="nav-number">6.4.</span> <span class="nav-text">Redis Sentinel 三个定时任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主观下线和客观下线"><span class="nav-number">6.5.</span> <span class="nav-text">主观下线和客观下线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#领导者选举"><span class="nav-number">6.6.</span> <span class="nav-text">领导者选举</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#raft算法"><span class="nav-number">6.6.1.</span> <span class="nav-text">raft算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移"><span class="nav-number">6.7.</span> <span class="nav-text">故障转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开发运维问题"><span class="nav-number">6.8.</span> <span class="nav-text">开发运维问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-Cluster"><span class="nav-number">7.</span> <span class="nav-text">Redis Cluster</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#呼唤集群"><span class="nav-number">7.1.</span> <span class="nav-text">呼唤集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据分布概论"><span class="nav-number">7.2.</span> <span class="nav-text">数据分布概论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本架构"><span class="nav-number">7.3.</span> <span class="nav-text">基本架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安装配置"><span class="nav-number">7.3.1.</span> <span class="nav-text">安装配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原生安装"><span class="nav-number">7.4.</span> <span class="nav-text">原生安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群伸缩"><span class="nav-number">7.5.</span> <span class="nav-text">集群伸缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端路由"><span class="nav-number">7.6.</span> <span class="nav-text">客户端路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JedisCluster使用"><span class="nav-number">7.7.</span> <span class="nav-text">JedisCluster使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java-API"><span class="nav-number">7.7.1.</span> <span class="nav-text">Java API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用技巧"><span class="nav-number">7.7.2.</span> <span class="nav-text">使用技巧</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移-1"><span class="nav-number">7.8.</span> <span class="nav-text">故障转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pub-sub"><span class="nav-number">7.9.</span> <span class="nav-text">pub&#x2F;sub</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据倾斜"><span class="nav-number">7.10.</span> <span class="nav-text">数据倾斜</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群vs单机"><span class="nav-number">7.11.</span> <span class="nav-text">集群vs单机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓存设计和优化"><span class="nav-number">8.</span> <span class="nav-text">缓存设计和优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存的受益与成本"><span class="nav-number">8.1.</span> <span class="nav-text">缓存的受益与成本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓冲更新策略"><span class="nav-number">8.2.</span> <span class="nav-text">缓冲更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存穿透问题"><span class="nav-number">8.3.</span> <span class="nav-text">缓存穿透问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无底洞问题"><span class="nav-number">8.4.</span> <span class="nav-text">无底洞问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#热点key的重建优化"><span class="nav-number">8.5.</span> <span class="nav-text">热点key的重建优化</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vicyor"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">vicyor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vicyor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vicyor" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2457569580@qq.com" title="E-Mail → mailto:2457569580@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vicyor</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">915k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:52</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=m9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'm9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz',
            'X-LC-Key': 'g7WSuE6aDmunoX4rgyBN7SJa',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'qQhr9rNGJh6YalJA0mfaaurx-gzGzoHsz',
    appKey: 'kJy8NJeOTMPnxQ3zLihOcnw3',
    placeholder: "请留下您的宝贵评论",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

	
		 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
		 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
		 <script type="text/javascript" src="/js/src/fireworks.js"></script>
	
</body>
</html>
