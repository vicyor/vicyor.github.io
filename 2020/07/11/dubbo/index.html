<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://vicyor.gitee.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="这是根据&lt;&lt;深入理解Dubbo与实战&gt;&gt;这本书做的笔记,受益匪浅.">
<meta property="og:type" content="article">
<meta property="og:title" content="dubbo">
<meta property="og:url" content="http://vicyor.gitee.io/2020/07/11/dubbo/index.html">
<meta property="og:site_name" content="Vicyor">
<meta property="og:description" content="这是根据&lt;&lt;深入理解Dubbo与实战&gt;&gt;这本书做的笔记,受益匪浅.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo-framework.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo-invoke-process.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo-registry.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo-registry-template.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo-spi-process.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo-service-export.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo-service-reference.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/Dubbo%E7%BC%96%E7%A0%81%E5%99%A8%E6%A8%A1%E6%9D%BF.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/Dubbo%E7%BC%96%E7%A0%81%E5%99%A8%E6%A8%A1%E6%9D%BF.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/netty-channel.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/netty-nio.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/channelHandler.png">
<meta property="article:published_time" content="2020-07-11T01:00:41.316Z">
<meta property="article:modified_time" content="2020-08-10T15:32:28.630Z">
<meta property="article:author" content="vicyor">
<meta property="article:tag" content="dubbo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://vicyor.gitee.io/2020/07/11/dubbo/dubbo-framework.png">

<link rel="canonical" href="http://vicyor.gitee.io/2020/07/11/dubbo/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>dubbo | Vicyor</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vicyor</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">49</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">55</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vicyor.gitee.io/2020/07/11/dubbo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="vicyor">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vicyor">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          dubbo
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-11 09:00:41" itemprop="dateCreated datePublished" datetime="2020-07-11T09:00:41+08:00">2020-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-10 23:32:28" itemprop="dateModified" datetime="2020-08-10T23:32:28+08:00">2020-08-10</time>
              </span>

          
            <span id="/2020/07/11/dubbo/" class="post-meta-item leancloud_visitors" data-flag-title="dubbo" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/07/11/dubbo/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/07/11/dubbo/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>84k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:16</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>这是根据&lt;&lt;深入理解Dubbo与实战&gt;&gt;这本书做的笔记,受益匪浅.</p>
<a id="more"></a>
<h2 id="第一章-Dubbo—高性能RPC通信框架"><a href="#第一章-Dubbo—高性能RPC通信框架" class="headerlink" title="第一章 Dubbo—高性能RPC通信框架"></a>第一章 Dubbo—高性能RPC通信框架</h2><h3 id="应用架构演变"><a href="#应用架构演变" class="headerlink" title="应用架构演变"></a>应用架构演变</h3><h4 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.JEE时期,三层架构,数据访问层,业务逻辑层,展示层</span><br><span class="line">    优点:</span><br><span class="line">        1.实时性高(单应用).</span><br><span class="line">        2.事务处理简单(事务只需依赖应用的数据库).</span><br><span class="line">        3.开发简单(单体).</span><br><span class="line">    缺点:</span><br><span class="line">        1.随着应用增大,性能会逐渐下降,只能纵向扩展.吞吐量,响应性能等.</span><br><span class="line">        2.业务之间耦合严重.</span><br><span class="line">2.mvc框架,垂直架构.</span><br><span class="line">      m---&gt;model          指渲染到view的数据,vue的mvvm的m亦是此意.</span><br><span class="line">      v---&gt;view           动态模板语言.</span><br><span class="line">      c---&gt;controller 请求接口层.</span><br><span class="line">     优点:</span><br><span class="line">         1.耦合度降低,使用spring,mybatis,hiberate等框架简化开发.</span><br><span class="line">         2.使用spring,框架更加轻量级.</span><br><span class="line">     缺点:</span><br><span class="line">         1.每个应用之间无法通信联系.</span><br></pre></td></tr></table></figure>
<h4 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.早期SOA  ESB和WebService.</span><br><span class="line">   SOA:面向服务的架构,每一个应用服务可以通过统一的接口和协议联系起来.</span><br><span class="line">      1.通信协议确定. 2.通信接口确定.</span><br><span class="line">   优点:</span><br><span class="line">       1.吞吐量更大,qps更多.</span><br><span class="line">       2.分布式 高可用,高并发,高性能...</span><br><span class="line">2.微服务化</span><br><span class="line">   微服务拆分的粒度更细,每一个应用是独立,可配置,可运行的服务.微服务框架会将其编排,路由,治理,监控等操作.</span><br><span class="line">   优点:</span><br><span class="line">       敏捷开发和敏捷部署.</span><br><span class="line">3.云原生</span><br><span class="line">  1.资源的动态规划 ----&gt;容器        docker.</span><br><span class="line">  2.服务的治理下沉 ----&gt;服务网格    keberate.</span><br><span class="line">  3.声明式API,函数式接口.</span><br></pre></td></tr></table></figure>
<h3 id="dubbo简介"><a href="#dubbo简介" class="headerlink" title="dubbo简介"></a>dubbo简介</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.dubbo是soa服务治理方案的核心框架.</span><br><span class="line">2.dubbo的特性.</span><br><span class="line">  1.面向接口代理的高性能rpc调用.</span><br><span class="line">  2.组件高度可扩展.</span><br><span class="line">  3.服务的自注册与发现.</span><br><span class="line">  4.流量调度.</span><br><span class="line">3.服务治理与服务编排.</span><br><span class="line">  服务编排: 编排强调协作,每个应用通过消息交互控制各资源交互(就是用一根线将一次调用中的应用穿起来).</span><br><span class="line">  服务治理: 治理确保每一个应用的正确调用关系(就是挑选出调用过程中每一步对应的最适合的应用).</span><br></pre></td></tr></table></figure>
<h4 id="dubbo的总体分层"><a href="#dubbo的总体分层" class="headerlink" title="dubbo的总体分层"></a>dubbo的总体分层</h4><p><img src="/2020/07/11/dubbo/dubbo-framework.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.dubbo总体分为biz(业务)层,RPC层,Remoting层.</span><br><span class="line">  RPC层(!!) ---&gt;通信协议Protocol,注册中心Registry,集群容错Cluster...</span><br><span class="line">  Remoting层---&gt;具体的通信层,在RPC协议之下，RPC是会话层,而这Remoting则主要在网络层.</span><br><span class="line">                exchange(信息交换层)</span><br><span class="line">                transport(网络传输层)</span><br><span class="line">                Serialize(序列化层)</span><br><span class="line">2.组件的介绍</span><br><span class="line">Service       业务层.包括业务代码的接口与实现,即开发者实现的业务代码.</span><br><span class="line">Config        配置层.主要围绕ServiceConfig(暴露的服务配置)和ReferenceConfig(引用的服务配置)两个实现类展开,初始化配置信息.</span><br><span class="line">proxy         服务代理层.在Dubbo中,无论生产者还是消费,框架都会生成一个代理类.</span><br><span class="line">registry      注册层.负责dubbo框架的注册与发现.当服务上线或下线时候,注册中心会感知并通知所有订阅方.</span><br><span class="line">cluster       集群容错层.(路由容错负载)远程调用失败时的容错策略(如fail-fast,fail-back).调用具体节点的负载均衡策略(随机,一致性hash).特殊调用路径的路由策略(指定ip).</span><br><span class="line">monitor       监控层.这一层主要负责监控统计调用次数和调用时间差.</span><br><span class="line">protocol      远程调用层。封装RPC调用具体过程.Protocol是Invoker暴露(发布一个服务让别人可以调用)和引用(引用一个远程服务到本地)的主要功能入口,负责管理Invoker的整个生命周期.</span><br><span class="line">              Invoker是Dubbo的核心模型,框架的所有其它模型都向它靠拢,或者转换成它,它代表一个可执行体.</span><br><span class="line">exchange      信息交换层.建立Request-Response模型.封装请求响应模式,如把同步请求转为异步请求.</span><br><span class="line">transport     网络传输层.把网络传输层抽象成统一的接口,如Mina和Netty虽然接口不一样,但是dubbo在它们上面又封装了统一的接口.</span><br><span class="line">serialize     序列化层.如果数据要通过网络进行发送,则需要先做序列化,变成二进制流.序列化负责管理整个框架网络传输时的序列化&#x2F;反序列化操作.</span><br></pre></td></tr></table></figure>
<h4 id="dubbo的整体调用过程"><a href="#dubbo的整体调用过程" class="headerlink" title="dubbo的整体调用过程"></a>dubbo的整体调用过程</h4><p><img src="/2020/07/11/dubbo/dubbo-invoke-process.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.dubbo的整体调用过程.</span><br><span class="line"> 消费端逻辑</span><br><span class="line">   Poxy(消费端生成的代理)---&gt;Invoker</span><br><span class="line">   ---&gt;Cluster(获取Directory中的该服务列表,根据Router选出List&lt;Invoker&gt;)</span><br><span class="line">   ---&gt;LoadBalancer(负载均衡器选出一个Invoker)---&gt;Filter(可以计数,限流操作(就是没响应的次数达到阈值就不能继续调了).)</span><br><span class="line">   ---&gt;Codec(私有协议构造)---&gt;Serialization(序列化)</span><br><span class="line">   ---&gt;服务提供端</span><br><span class="line">   ---&gt;ThreadPool---&gt;Server()---&gt;Exporter---&gt;Filter(计数..)---&gt;Invoker(proxy)---&gt;ref(接口返回结果).</span><br></pre></td></tr></table></figure>
<h2 id="第二章-开发第一款Dubbo应用程序"><a href="#第二章-开发第一款Dubbo应用程序" class="headerlink" title="第二章 开发第一款Dubbo应用程序"></a>第二章 开发第一款Dubbo应用程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EchoService</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">echo</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServiceImpl</span> <span class="keyword">implements</span> <span class="title">EchoService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        String now=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Data());</span><br><span class="line">        System.out.println(<span class="string">"["</span>+now+<span class="string">"] Hello "</span>+message+<span class="string">", request from consumer: "</span>+RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于xml配置"><a href="#基于xml配置" class="headerlink" title="基于xml配置"></a>基于xml配置</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">echo-provider.xml</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xis</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://dubbo.apache.org/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://dubbo.apache.org/scham/dubbo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务提供方应用名称,方便于依赖的跟踪--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"echo-provider"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用本地的zookeeper作为注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 只使用dubbo协议并且指定监听20880端口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20800"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过xml方式把实现配置为bean，让spring托管和实例化--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"echoService"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.dubbo.samples.echo.impl.EchoServiceImpl"</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 声明式暴露的接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.samples.echo.api.EchoService"</span> <span class="attr">ref</span>=<span class="string">"echoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span>       </span><br><span class="line"></span><br><span class="line">echo-consumer.xml</span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://dubbo.apache.org/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schame/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://dubbo.apache.org/schema/dubbo/dubbo.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       "</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 服务消费方应用名称，方便用于依赖跟踪--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"echo-consumer"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用本地的zookeeper作为注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定要消费的服务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"echoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"com.alibab.dubbo.samples.echo.api.EchoService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="基于注解配置"><a href="#基于注解配置" class="headerlink" title="基于注解配置"></a>基于注解配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">服务提供方</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServiceImpl</span> <span class="keyword">implements</span> <span class="title">EchoService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        String now=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">        System.out.println(<span class="string">"["</span>+now+<span class="string">"] Hello "</span>+message+<span class="string">", request from consumer: "</span>+RpcContext.getContext().getRemoteAddress());</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationProvider</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context=<span class="keyword">new</span> AnnotationConfigApplicationContext(ProviderConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages=<span class="string">"com.alibaba.dubbo.samples.echo"</span>)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">providerConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProviderConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig=<span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"echo-annotation-provider"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RegistryConfig registryConfig=<span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</span><br><span class="line">        registryConfig.setAddress(<span class="string">"localhost"</span>);</span><br><span class="line">        registryConfig.setPort(<span class="number">2181</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocolConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ProtocolConfig protocolConfig=<span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        protocolConfig.setName(<span class="string">"dubbo"</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">20880</span>);</span><br><span class="line">        <span class="keyword">return</span> protocolConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">编写echo客户端</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoConsumer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> EchoService echoService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> echoService.echo(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConsumer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context=<span class="keyword">new</span> AnnotationConfigApplicationContext(ConsumerConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        context.start();</span><br><span class="line">        EchoConsumer echoService=context.getBean(EchoConsumer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String hello=echoService.echo(<span class="string">"Hello,world!"</span>);</span><br><span class="line">        System.out.println(<span class="string">"result: "</span>+hello);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages=<span class="string">"com.alibab.dubbo.samples.echo"</span>)</span><br><span class="line"><span class="meta">@ComponentScan</span>(value=&#123;<span class="string">"com.alibaba.dubbo.samples.echo"</span>&#125;)</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig=<span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConifg.setName(<span class="string">"echo-annotation-consumer"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConifg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumberConfig <span class="title">consumerConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConsumerConfig();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RegistryConfig registryConfig=<span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</span><br><span class="line">        registryConfig.setAddress(<span class="string">"localhost"</span>);</span><br><span class="line">        registryConfig.setPort(<span class="number">2181</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="硬编码方式-ServiceConfig和ReferenceConfig"><a href="#硬编码方式-ServiceConfig和ReferenceConfig" class="headerlink" title="硬编码方式 ServiceConfig和ReferenceConfig"></a>硬编码方式 ServiceConfig和ReferenceConfig</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoProvider</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span><span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      ServiceConfig&lt;EchoService&gt;service=<span class="keyword">new</span> ServiceConfig&lt;&gt;();</span><br><span class="line">      service.setApplication(<span class="keyword">new</span> ApplicationConfig(<span class="string">"java-echo-provider"</span>));</span><br><span class="line">      service.setRegistry(<span class="keyword">new</span> RegistryConfig(<span class="string">"zookeepr://127.0.0.1:2181"</span>));</span><br><span class="line">      service.setInterface(EchoService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      service.setRef(<span class="keyword">new</span> EchoServiceImpl());</span><br><span class="line">      service.export();</span><br><span class="line">      System.out.println(<span class="string">"java-echo-provider is running"</span>);</span><br><span class="line">      System.in.read();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoConsumer</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">      ReferenceConfig&lt;EchoService&gt;reference=<span class="keyword">new</span> ReferenceConfig&lt;&gt;();</span><br><span class="line">      reference.setApplication(<span class="keyword">new</span> ApplicatonConfig(<span class="string">"java-echo-consumer"</span>));</span><br><span class="line">      reference.setRegistry(<span class="keyword">new</span> RegistryConfig(<span class="string">"zookeeper://127.0.0.1:2181"</span>));</span><br><span class="line">      reference.setInterface(EchoService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      EchoService greetingService=reference.get();</span><br><span class="line">      String message=greetingService.echo(<span class="string">"hello world!"</span>);</span><br><span class="line">      System.out.println(message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三章-Dubbo注册中心"><a href="#第三章-Dubbo注册中心" class="headerlink" title="第三章 Dubbo注册中心"></a>第三章 Dubbo注册中心</h2><h3 id="注册中心概述"><a href="#注册中心概述" class="headerlink" title="注册中心概述"></a>注册中心概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.注册中心的用途</span><br><span class="line">  1.动态加入.</span><br><span class="line">  2.动态发现.</span><br><span class="line">  3.动态调整.</span><br><span class="line">  4.统一配置.</span><br><span class="line">2.dubbo的注册中心模块</span><br><span class="line">  dubbo-registry-api                          api模板类.</span><br><span class="line">  dubbo-registry-zookeeper                 zookeeper注册中心.</span><br><span class="line">  dubbo-registry-redis          redis注册中心.</span><br><span class="line">  dubbo-registry-default                内存注册中心.</span><br><span class="line">  dubbo-registry-multicast                 广播.</span><br></pre></td></tr></table></figure>
<h3 id="注册中心工作流程"><a href="#注册中心工作流程" class="headerlink" title="注册中心工作流程"></a>注册中心工作流程</h3><p><img src="/2020/07/11/dubbo/dubbo-registry.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.provider启动后.</span><br><span class="line">  1.会根据自己暴露的服务,将provider信息加到配置中心对应service的provider目录下.</span><br><span class="line">  2.初始拉取拉取暴露服务的configurer(全量订阅).</span><br><span class="line">  3.订阅注册中心中对应暴露的服务的动态配置configurer目录.</span><br><span class="line">2.consumer启动后.</span><br><span class="line">  1.会根据自己订阅的服务,将consumer信息加到配置中心对应的service的consumer目录下.</span><br><span class="line">  2.初始拉取消费服务的privoder,configurer,route(全量订阅).</span><br><span class="line">  3.订阅了注册中心对应消费的服务的provider目录,configurer目录,route目录.</span><br><span class="line">3.服务治理中心启动后.</span><br><span class="line">  1.初始拉取所有服务的privoder,configurer,route(全量订阅).</span><br><span class="line">  2.会订阅所有服务消费者,所有服务提供者,所有服务路由,所有服务动态配置的信息.</span><br></pre></td></tr></table></figure>
<h3 id="Zookeeper注册中心原理概述"><a href="#Zookeeper注册中心原理概述" class="headerlink" title="Zookeeper注册中心原理概述"></a>Zookeeper注册中心原理概述</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">zookeeper---&gt;分布式过程协同中间件,数据结构类似文件系统.</span><br><span class="line">+   &#x2F;dubbo</span><br><span class="line">  +-- $&#123;service&#125;</span><br><span class="line">        +-- providers</span><br><span class="line">              $&#123;providerRpcProtocol&#125;:&#x2F;&#x2F;$&#123;providerIp&#125;:20880&#x2F;$&#123;service&#125;?category&#x3D;provider&amp;$&#123;providerAttachment&#125;</span><br><span class="line">        +-- consumers</span><br><span class="line">              consumer:&#x2F;&#x2F;$&#123;consumerIp&#125;&#x2F;$&#123;service&#125;?category&#x3D;consumers&amp;$&#123;consumerAttachment&#125;</span><br><span class="line">        +-- routers </span><br><span class="line">             (补充:条件路由)</span><br><span class="line">             condition:&#x2F;&#x2F;0.0.0.0&#x2F;$&#123;service&#125;?category&#x3D;router&amp;dynamic&#x3D;false&amp;rule&#x3D;URL.encode(&quot;host&#x3D;192.168.1.107&#x3D;&gt;host&#x3D;192.168.1.107&quot;) </span><br><span class="line">        +-- configurators</span><br><span class="line">             (补充:动态配置,enabled是强制,dynamic是持久化)</span><br><span class="line">             override:&#x2F;&#x2F;0.0.0.0&#x2F;$&#123;sevice&#125;?category&#x3D;configurators&amp;dynamic&#x3D;false&amp;enabled&#x3D;true&amp;timeout&#x3D;1000..</span><br><span class="line">  +-- config             </span><br><span class="line">            (补充:配置中心,支持zookeeper,Apollo,Nacos）</span><br><span class="line">        +--dubbo</span><br><span class="line">            dubbo.properties(在zookeeper中是dubbo.properties这个节点,注意zookeeper节点大小阈值默认为1MB)</span><br><span class="line">                dubbo.application.name&#x3D;HelloWorldServiceProvider</span><br><span class="line">       ......</span><br></pre></td></tr></table></figure>
<h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.订阅的2种方式.</span><br><span class="line">  推模式:服务器将所有数据推向客户端.</span><br><span class="line">  拉模式:服务器通知事件,客户端根据事件类型,去拉取对应的服务器信息.</span><br><span class="line">2.zk注册中心.</span><br><span class="line">  1.zk订阅模式是基于拉模式.</span><br><span class="line">  2.Watcher是基于Node的版本号变化响应事件.</span><br><span class="line">  3.zk的超时是从未客户端未发送心跳那一刻算起的.超时后会自动删除客户端创建的临时节点.</span><br><span class="line">  4.zk会在订阅的节点上注册一个Watcher,客户端与服务器保持TCP长连接.</span><br><span class="line">3.zk的事务操作.</span><br><span class="line">  1.客户端任何新增,删除,修改,会话创建和会话失效都是事务操作.</span><br><span class="line">  2.事务操作由zookeeper集群的leader节点执行.即使客户端连接的是非leader节点,事务请求也会转发给leader执行.</span><br><span class="line">    主从结构,确保所有事务操作的全局时序性.</span><br><span class="line">  3.每个节点都存在唯一的版本号,可以通过cas操作保证事务的节点事务操作的原子性.</span><br><span class="line">4.dubbo对zk的四种Category的数据变更的处理.</span><br><span class="line">  prividers     ---&gt;更新Directory中的Invoker服务列表.</span><br><span class="line">  routers       ---&gt;更新本地的路由规则表.</span><br><span class="line">  configurators ---&gt;更新本地动态参数表.</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">Zookeeper全量订阅服务.</span><br><span class="line">ZookeeperRegistry#doSubscribe</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSubscribe</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> NotifyListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//ANY_VALUE&lt;-&gt;* 表示全量订阅</span></span><br><span class="line">          <span class="keyword">if</span> (ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">              String root = toRootPath();</span><br><span class="line">              <span class="comment">//ConcurrentMap&lt;URL,ConcurrentMap&lt;NotifyListener,ChildListener&gt;&gt; zkListeners</span></span><br><span class="line">              ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line">              <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">              zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">              listeners = zkListeners.get(url);</span><br><span class="line">          &#125;</span><br><span class="line">          ChildListener zkListener = listeners.get(listener);</span><br><span class="line">          <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//设置Root的ChildListener</span></span><br><span class="line">              listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; &#123;</span><br><span class="line">              <span class="keyword">for</span> (String child : currentChilds) &#123;</span><br><span class="line">                  child = URL.decode(child);</span><br><span class="line">                  <span class="keyword">if</span> (!anyServices.contains(child)) &#123;</span><br><span class="line">                      anyServices.add(child);</span><br><span class="line">                      <span class="comment">//递归,走elsa分支</span></span><br><span class="line">                      subscribe(url.setPath(child).addParameters(INTERFACE_KEY, child,</span><br><span class="line">                      Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">                  &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">              zkListener = listeners.get(listener);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//创建持久节点(root),接下来订阅持久节点的直接子节点</span></span><br><span class="line">          zkClient.create(root, <span class="keyword">false</span>);</span><br><span class="line">          <span class="comment">//订阅持久节点 ChildListener</span></span><br><span class="line">          List&lt;String&gt; services = zkClient.addChildListener(root, zkListener);</span><br><span class="line">          <span class="keyword">if</span> (CollectionUtils.isNotEmpty(services)) &#123;</span><br><span class="line">              <span class="comment">//遍历所有子节点,并进行订阅. 递归 subscribe ---&gt; doSubscrible</span></span><br><span class="line">              <span class="keyword">for</span> (String service : services) &#123;</span><br><span class="line">                  service = URL.decode(service);</span><br><span class="line">                  anyServices.add(service);</span><br><span class="line">                  <span class="comment">//有INTERFACE_KEY 这个key,会走到else逻辑</span></span><br><span class="line">                  subscribe(url.setPath(service).addParameters(INTERFACE_KEY, service,</span><br><span class="line">                  Constants.CHECK_KEY, String.valueOf(<span class="keyword">false</span>)), listener);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//providers,consumers,routers,configurators</span></span><br><span class="line">        <span class="keyword">for</span> (String path : toCategoriesPath(url)) &#123;</span><br><span class="line">             ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url);</span><br><span class="line">             <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zkListeners.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">                listeners = zkListeners.get(url);</span><br><span class="line">             &#125;</span><br><span class="line">             ChildListener zkListener = listeners.get(listener);</span><br><span class="line">             <span class="keyword">if</span> (zkListener == <span class="keyword">null</span>) &#123;</span><br><span class="line">                 <span class="comment">//设置service的childListener</span></span><br><span class="line">                 listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; ZookeeperRegistry.<span class="keyword">this</span>.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds)));</span><br><span class="line">                 zkListener = listeners.get(listener);</span><br><span class="line">              &#125;</span><br><span class="line">             zkClient.create(path, <span class="keyword">false</span>);</span><br><span class="line">             List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);</span><br><span class="line">             <span class="keyword">if</span> (children != <span class="keyword">null</span>) &#123;</span><br><span class="line">                urls.addAll(toUrlsWithEmpty(url, path, children));</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         notify(url, listener, urls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to subscribe "</span> + url + <span class="string">" to zookeeper "</span> + getUrl() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ZookeeperRegistry#notify</span><br><span class="line">AbstractRegistry#notify</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 放入本地缓存中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((CollectionUtils.isEmpty(urls))&amp;&amp; !ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Ignore empty notify urls for subscribe url "</span> + url);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Notify urls for subscribe url "</span> + url + <span class="string">", urls: "</span> + urls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// keep every provider's category.</span></span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                        String category = u.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY);</span><br><span class="line">                        List&lt;URL&gt; categoryList = result.computeIfAbsent(category, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                        categoryList.add(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.computeIfAbsent(url, u -&gt; <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">        String category = entry.getKey();</span><br><span class="line">        List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">        categoryNotified.put(category, categoryList);</span><br><span class="line">        listener.notify(categoryList);</span><br><span class="line">        <span class="comment">// We will update our cache file after each notification.</span></span><br><span class="line">        <span class="comment">// When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL.</span></span><br><span class="line">        saveProperties(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Redis注册中心原理概述"><a href="#Redis注册中心原理概述" class="headerlink" title="Redis注册中心原理概述"></a>Redis注册中心原理概述</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis ---&gt; 单线程,内存数据库 数据结构是kv键值对.</span><br><span class="line">    |--       Redis hash Key        --|  |--  url                             --|     |-- ttl --|</span><br><span class="line">   &#x2F;dubbo&#x2F;com.vicyor.service.XXService    dubbo:&#x2F;&#x2F;ip:port?category&#x3D;providers&amp;...        10000</span><br></pre></td></tr></table></figure>
<h4 id="发布订阅-1"><a href="#发布订阅-1" class="headerlink" title="发布订阅"></a>发布订阅</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.provider会通过一个定时任务去不断刷新service的ttl(续约).</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deferExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;String, JedisPool&gt; entry : jedisPools.entrySet()) &#123;</span><br><span class="line">     JedisPool jedisPool = entry.getValue();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> (Jedis jedis = jedisPool.getResource()) &#123;</span><br><span class="line">              <span class="keyword">for</span> (URL url : <span class="keyword">new</span> HashSet&lt;&gt;(getRegistered())) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (url.getParameter(DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                      String key = toCategoryPath(url);</span><br><span class="line">                      <span class="comment">//对key进行续期</span></span><br><span class="line">                      <span class="keyword">if</span> (jedis.hset(key, url.toFullString(), String.valueOf(System.currentTimeMillis() + expirePeriod)) == <span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="comment">//若续期返回1,说明key已被删除,重新发布key.</span></span><br><span class="line">                          jedis.publish(key, REGISTER);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (admin) &#123;</span><br><span class="line">                  clean(jedis);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (!replicate) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;<span class="comment">//  If the server side has synchronized data, just write a single machine</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">         logger.warn(<span class="string">"Failed to write provider heartbeat to redis registry. registry: "</span> + entry.getKey() + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>.服务治理中心的定时任务会对所有的服务key进行遍历,并对过期的key进行删除操作.</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line"> Set&lt;String&gt; keys = jedis.keys(root + ANY_VALUE);</span><br><span class="line"> <span class="keyword">if</span> (CollectionUtils.isNotEmpty(keys)) &#123;</span><br><span class="line">   <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">       Map&lt;String, String&gt; values = jedis.hgetAll(key);</span><br><span class="line">       <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(values)) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> delete = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">           <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : values.entrySet()) &#123;</span><br><span class="line">                URL url = URL.valueOf(entry.getKey());</span><br><span class="line">                <span class="keyword">if</span> (url.getParameter(DYNAMIC_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                    <span class="keyword">long</span> expire = Long.parseLong(entry.getValue());</span><br><span class="line">                    <span class="comment">//超时删除</span></span><br><span class="line">                    <span class="keyword">if</span> (expire &lt; now) &#123;</span><br><span class="line">                        jedis.hdel(key, entry.getKey());</span><br><span class="line">                        delete = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Delete expired key: "</span> + key + <span class="string">" -&gt; value: "</span> + entry.getKey() + <span class="string">", expire: "</span> + <span class="keyword">new</span> Date(expire) + <span class="string">", now: "</span> + <span class="keyword">new</span> Date(now));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;       </span><br><span class="line">        <span class="keyword">if</span> (delete) &#123;</span><br><span class="line">            jedis.publish(key, UNREGISTER);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓存的加载"><a href="#缓存的加载" class="headerlink" title="缓存的加载"></a>缓存的加载</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.缓存是通过更多的空间换取时间.</span><br><span class="line">2.消费者和服务治理中心获取注册信息后会做本地缓存.</span><br><span class="line">  本地缓存---&gt;内存(Properties)和文件(File).</span><br><span class="line">  像这样ConcurrentMap&lt;URL,Map&lt;Category,List&lt;URL&gt;&gt;.</span><br><span class="line">AbstractRegistry</span><br><span class="line">private final Properties properties&#x3D;new Properties();</span><br><span class="line">private File file;</span><br><span class="line">pirvate final ConcurrentMap&lt;URL,Map&lt;String,List&lt;URL&gt;&gt;&gt; notified&#x3D;new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">AbstratRegistry#notify</span><br></pre></td></tr></table></figure>
<h3 id="注册重试机制"><a href="#注册重试机制" class="headerlink" title="注册重试机制"></a>注册重试机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.FailbackRegistry有5个集合,进行与注册中心相关的操作抛出异常时候,会将其加入到对应得集合中.</span><br><span class="line">  Set failedRegistered;</span><br><span class="line">  Set failedUnregistered;</span><br><span class="line">  ConcurrentMap failedSubscribed;</span><br><span class="line">  ConcurrentMap failedUnsubscribed;</span><br><span class="line">  ConcurrentMap failedNotified;</span><br><span class="line">2.FailbackRegistry有一个线程池会不断得轮询那些注册集合,对失败的url进行重新操作.</span><br></pre></td></tr></table></figure>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><img src="/2020/07/11/dubbo/dubbo-registry-template.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.模板模式和策略模式.</span><br><span class="line">  模板模式: 整个算法流程不变,将某些特定的步骤的具体实现由自定义类完成.整体调用逻辑流程不变.</span><br><span class="line">  策略模式: 替换整个算法.</span><br><span class="line"> 2.dubbo注册中心的模板模式.</span><br><span class="line">   AbstractRegistry  ---&gt;  实现了磁盘文件持久化,对注册,订阅,查询,通知的实现,只是将对应的URL加到对应的集合中.</span><br><span class="line">   FailbackRegistry  ---&gt;  增强了AbstractRegistry类的注册,订阅,查询,通知.增强了重试机制.并添加了4个doXXX真正的注册方法.</span><br><span class="line">   RedisRegistry,ZookeeperRegistry ---&gt;实现了那4个doXXX方法.doRegister,doUnregister,doSubscribe,doUnsubscribe.</span><br><span class="line"> 3.工厂模式.</span><br><span class="line">   Registry实例是由RegistryFactory创建的.使用哪一个Facotry由dubbo spi根据注册url的protocol决定.</span><br></pre></td></tr></table></figure>
<h2 id="第四章-Dubbo扩展点加载机制"><a href="#第四章-Dubbo扩展点加载机制" class="headerlink" title="第四章 Dubbo扩展点加载机制"></a>第四章 Dubbo扩展点加载机制</h2><h3 id="Java的SPI机制"><a href="#Java的SPI机制" class="headerlink" title="Java的SPI机制"></a>Java的SPI机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.Java的SPI机制使用了策略模式.一般java暴露接口,具体的实现由厂商提供的实现决定.</span><br><span class="line">2.使用教程.</span><br><span class="line">   1.在classpath:META-INF&#x2F;services下创建接口,内容为具体的实现.</span><br><span class="line">   2.通过ServiceLoader去加载具体的实现. ServiceLoader.load(XXXService.class);</span><br><span class="line">     load方法返回的是ServiceLoader&lt;XXXService&gt; loader(实现了Iterable接口).</span><br><span class="line">3.Java SPI的缺点.</span><br><span class="line">  1.加载时会对文件种某个接口的所有实现都实例化.耗时,耗堆内存.</span><br><span class="line">  2.加载时若加载失败,会吞掉异常.</span><br></pre></td></tr></table></figure>
<h3 id="dubbo的spi机制"><a href="#dubbo的spi机制" class="headerlink" title="dubbo的spi机制"></a>dubbo的spi机制</h3><h4 id="dubbo-spi"><a href="#dubbo-spi" class="headerlink" title="dubbo spi"></a>dubbo spi</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.扩展点配置规范.</span><br><span class="line">  SPI配置文件路径                   META-INF&#x2F;services&#x2F;,META-INF&#x2F;dubbo&#x2F;,META-INF&#x2F;dubbo&#x2F;internal&#x2F;</span><br><span class="line">  SPI配置文件名称                   全路径名</span><br><span class="line">        文件格式类容                      key&#x3D;value方式,多个用换行符分割</span><br><span class="line">        扩展点加载:</span><br><span class="line">      PrintService service&#x3D;ExtensionLoader.getExtensionLoader(PrintService.class).getExtension(&quot;key1&quot;);</span><br><span class="line">2.dubbo spi 相对java spi优点.</span><br><span class="line">  1.dubbo spi会对所有扩展进行缓存.</span><br><span class="line">  2.dubbo spi可以根据URI参数动态调用,自适应扩展.</span><br><span class="line">  3.dubbo spi 可以抛出加载扩展失败的异常.</span><br></pre></td></tr></table></figure>
<h4 id="dubbo-spi扩展点缓存"><a href="#dubbo-spi扩展点缓存" class="headerlink" title="dubbo spi扩展点缓存"></a>dubbo spi扩展点缓存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.dubbo spi并不会对所有扩展类都实例化,及不实例化的会以Class的形式存在.</span><br><span class="line">2.一个接口对应于一个ExtensionLoader.</span><br><span class="line">3.缓存种类:Class缓存,实例(instance)缓存.</span><br><span class="line">ExtensionLoader.</span><br><span class="line">   Holder&lt;Map&lt;String,Class&lt;?&gt;&gt;&gt;cachedClasses;     普通扩展类缓存,不包括指定为@Adaptive的类.</span><br><span class="line">   Class&lt;?&gt;cachedAdaptiveClass;                   指定为@Adaptive的类.</span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;            Wrapper类缓存.</span><br><span class="line">   Holder&lt;Map&lt;String,Holder&lt;Object&gt;&gt;&gt;cachedInstance;    普通扩展类及其实例.</span><br><span class="line">   Holder&lt;Object&gt;cachedAdaptiveInstance;          @Adaptive的类实例.</span><br><span class="line">   ConcurrentMap&lt;Class&lt;?&gt;,String&gt;cachedNames;     扩展类与扩展名缓存.</span><br><span class="line">   ConcurrentMap&lt;Class&lt;?&gt;,ExtensionLoader&lt;?&gt;&gt;EXTENSION_LOADERS  扩展类与对应的扩展类加载器缓存.</span><br><span class="line">   ConcurrentMap&lt;Class&lt;?&gt;,Object&gt;EXTENSION_INSTANCES            扩展类与类实例化后的实例.</span><br><span class="line">   Map&lt;String,Activate&gt;cachedActivates                          扩展名与@Activate的缓存.</span><br></pre></td></tr></table></figure>
<h4 id="dubbo-spi扩展类四大特性"><a href="#dubbo-spi扩展类四大特性" class="headerlink" title="dubbo spi扩展类四大特性"></a>dubbo spi扩展类四大特性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">自动包装.  Wrapper.扩展类实例的构造函数有其它的扩展类实例作为依赖,此时会将那个依赖注入(IOC).并将扩展类当成Warpper.加入Warpper缓存.</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ProtocolFilterWrapper</span> <span class="keyword">implements</span> <span class="title">Protocol</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Protocol protocol;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ProtocolFilterWrapper</span><span class="params">(Protocol protocol)</span></span>&#123;    <span class="comment">//实现了Protocol,但构造函数中又传入了一个Protocol类型的参数,框架会自动注入.</span></span><br><span class="line">              <span class="keyword">if</span>(protocol==<span class="keyword">null</span>)  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"protocol == null"</span>);</span><br><span class="line">              <span class="keyword">this</span>.protocol=protocol;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">自动加载.  IOC,Wrapper类构造器注入,某通的Setter方法依赖注入,此时会调用ExtensionLoader去加载依赖,完成注入.</span><br><span class="line">自适应.    在方法上加<span class="meta">@Adaptive</span>注解,会根据注解的key获取URL的value,根据value去找实现.</span><br><span class="line">自动激活.  <span class="meta">@Activate</span>注解.可以设置注解的参数作为条件,设置扩展点在不同的情况下被激活.</span><br></pre></td></tr></table></figure>
<h3 id="dubbospi的实现"><a href="#dubbospi的实现" class="headerlink" title="dubbospi的实现"></a>dubbospi的实现</h3><p><img src="/2020/07/11/dubbo/dubbo-spi-process.png" alt></p>
<h4 id="基本的扩展加载方法"><a href="#基本的扩展加载方法" class="headerlink" title="基本的扩展加载方法"></a>基本的扩展加载方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.扩展注解</span><br><span class="line">  <span class="meta">@SPI</span>(value)    value对应的实现可以通过getDefaultExtension方法去加载它,会作为getAdaptiveExtension方法代理逻辑的备份key.</span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@interface</span> SPI &#123;</span><br><span class="line">    <span class="comment">//default extension name</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2</span>.getExtension方法   这个方法和java spi的ServiceLoader功能类似.</span><br><span class="line">  ExtensionLoader.getExtensionLoader(XXService<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">key</span>)</span>;</span><br><span class="line">  ExtensionLoader.getExtensionLoader(XXService<span class="class">.<span class="keyword">class</span>).<span class="title">getDefaultExtension</span>()</span>;<span class="comment">//@SPI的value</span></span><br><span class="line"><span class="number">3</span>.getExtension方法逻辑</span><br><span class="line">  <span class="number">1</span>.从cachedInstances中获取实例.</span><br><span class="line">  <span class="number">2</span>.获取不到调用createExtension根据key创建扩展类.</span><br><span class="line">     <span class="number">1</span>.去cachedClasses中获取name对应的<span class="class"><span class="keyword">class</span>.获取不到<span class="title">class</span>就去目录下加载.</span></span><br><span class="line"><span class="class">       将加载后的<span class="title">class</span>放入<span class="title">cachedClasses</span>中.</span></span><br><span class="line"><span class="class">     2.通过反射创建实例.<span class="title">clazz</span>.<span class="title">newInstance</span>()</span>; .</span><br><span class="line">     <span class="number">3</span>.将实例放入EXTENSION_INSTANCES中.</span><br><span class="line">  <span class="number">3</span>.injectExtension(instance).</span><br><span class="line">    对instance进行依赖注入.主要是setter的注入.</span><br><span class="line">  <span class="number">4</span>.如果有包装类(构造注入),则一直嵌套包装.(instance作为构造函数参数创建ServiceWarrper类)</span><br><span class="line">    返回最后一个包装类.</span><br></pre></td></tr></table></figure>
<h4 id="自适应扩展类"><a href="#自适应扩展类" class="headerlink" title="自适应扩展类"></a>自适应扩展类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    <span class="comment">//可以设置多个key,会按照顺序依次匹配</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span>.扩展点自适应注解  <span class="meta">@Adaptive</span></span><br><span class="line">  <span class="meta">@Adaptive</span>注解用在扩展类上会将扩展类作为getAdaptiveExtension的默认实现.</span><br><span class="line">  <span class="meta">@Adaptive</span>注解作用在方法上,会对Service接口生成动态代理,</span><br><span class="line">           动态生成的方法逻辑是从传入的URl获取<span class="meta">@Adaptiove</span>注解的value对应的value,</span><br><span class="line">           然后以value为key调用getExtension方法去加载扩展类.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.getAdaptiveExtention方法生成的代理类.</span><br><span class="line">  代理类主要是动态拼接代码,然后通过Compiler编译,最后通过类加载器加载到jvm的方法区来完成的.</span><br><span class="line">  编译器有JavaassistCompiler,JdkCompiler等等.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">扩展接口</span><br><span class="line"><span class="meta">@SPI</span>(<span class="string">"impl1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleExt</span></span>&#123;</span><br><span class="line">                <span class="meta">@Adaptive</span>(<span class="string">"protocol"</span>)</span><br><span class="line">                <span class="function">String <span class="title">echo</span><span class="params">(URL url,String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">配置文件</span><br><span class="line">    impl1=com.vicyor.service.impl.SimpleExtImpl1</span><br><span class="line">通过getAdaptiveExtension返回的自适应类代码. <span class="comment">//就是根据url去找的</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">SimpleExt</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">xxxxx</span>.<span class="title">SimpleExt</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(URL url,String s)</span></span>&#123;</span><br><span class="line">                    String defaultValue=<span class="string">"impl1"</span>; <span class="comment">//@SPI的值</span></span><br><span class="line">                    String extKey=url.getParameter(<span class="string">"protocol"</span>,defaultValue);</span><br><span class="line">                    SimpleExt extension=ExtensionLoader.getExtensionLoader(SimpleExt<span class="class">.<span class="keyword">class</span>).<span class="title">getExtension</span>(<span class="title">extKey</span>)</span>;</span><br><span class="line">                    <span class="keyword">return</span> extension.echo(url,s);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="激活类加载逻辑"><a href="#激活类加载逻辑" class="headerlink" title="激活类加载逻辑"></a>激活类加载逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.@Activate注解和getActivateExtension 激活注解.</span><br><span class="line">  1.@Activate注解.</span><br><span class="line">        public @interface Activate &#123;</span><br><span class="line">                &#x2F;&#x2F;url中分组如果匹配则激活(service的group)</span><br><span class="line">                String[] group() default &#123;&#125;;</span><br><span class="line">                &#x2F;&#x2F;url中含有该key则激活</span><br><span class="line">                String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 哪些扩展点要在该注解前</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                @Deprecated</span><br><span class="line">                String[] before() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                &#x2F;**</span><br><span class="line">                 *哪些扩展点要在当前扩展点后</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                @Deprecated</span><br><span class="line">                String[] after() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 顺序</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                int order() default 0;</span><br><span class="line">        &#125;</span><br><span class="line">2.getActivateExtension方法.</span><br><span class="line">    ExtensionLoader.getExtensionLoader(XXService.class)</span><br><span class="line">        .getActivateExtension(url,key,group)</span><br><span class="line">        &#x3D;&gt;getActivateExtension(url,values,group)  values&#x3D;&#x3D;&gt;扩展点名称.</span><br><span class="line">        &#x3D;&gt;getExtensionClasses(); 这个方法上面说过,就是扫描文件将class分类加入缓存.</span><br><span class="line">        &#x3D;&gt;遍历cachedActivates.  cachedActivates 是 扩展名 ----&gt;@Activate.</span><br><span class="line">          会对values(传入的)和cachedActivates中的@Activate的值与出入url的group和value匹配的扩展名</span><br><span class="line">          通过getExtension加载扩展并返回.</span><br></pre></td></tr></table></figure>
<h2 id="第五章-Dubbo-启停原理解析"><a href="#第五章-Dubbo-启停原理解析" class="headerlink" title="第五章 Dubbo 启停原理解析"></a>第五章 Dubbo 启停原理解析</h2><h3 id="基于xml配置原理解析"><a href="#基于xml配置原理解析" class="headerlink" title="基于xml配置原理解析"></a>基于xml配置原理解析</h3><h4 id="spring的xml解析简单调用流程"><a href="#spring的xml解析简单调用流程" class="headerlink" title="spring的xml解析简单调用流程."></a>spring的xml解析简单调用流程.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanFactory构造函数--&gt;</span><br><span class="line">  XmlBeanDefinitionReader --&gt; loadBeanDefinitions() 加载xml --&gt;</span><br><span class="line">  DocumentLoader--&gt;loadDocument 将xml通过sax方式转Document --&gt;</span><br><span class="line">  registryBeanDefinitions()--&gt;</span><br><span class="line">  DefaultBeanDefinitionDocumentReader --&gt; </span><br><span class="line">      parseBeanDefinitions(Element root,BeanDefinitionParserDelegate delegate)</span><br><span class="line">          --&gt;isDefaultNameSpace() --&gt; parseDefaultElement spring默认的命名空间,解析spring自带的标签.</span><br><span class="line">          --&gt;delegate.parseCustomElement 解析自定义的Namespace</span><br><span class="line">             --&gt;XmlReaderContext.getNamespaceHandlerResolver().resolve(namespaceUri) 获取NameSpaceHandler</span><br><span class="line">                NameSpaceHandler是模板模式,具体流程在抽象类NameSpaceHandlerSupport,</span><br><span class="line">                主要的parser和标签的关系在init方法里</span><br><span class="line">             --&gt;NameSpaceHandleSupport.findParserForElement解析默认标签</span><br></pre></td></tr></table></figure>
<h4 id="DubboNamspaceHandler的init方法"><a href="#DubboNamspaceHandler的init方法" class="headerlink" title="DubboNamspaceHandler的init方法"></a>DubboNamspaceHandler的init方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoked by the &#123;<span class="doctag">@link</span> DefaultBeanDefinitionDocumentReader&#125; after</span></span><br><span class="line"><span class="comment"> * construction but before any custom elements are parsed.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> NamespaceHandlerSupport#registerBeanDefinitionParser(String, BeanDefinitionParser)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"application"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"module"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        <span class="comment">//注册中心标签 registry标签 &lt;----&gt;RegistryConfig</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"registry"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"config-center"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConfigCenterBean<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"metadata-report"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MetadataReportConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"monitor"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"metrics"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MetricsConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"provider"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"consumer"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        <span class="comment">//rpc通信协议标签 protocol标签&lt;----&gt;ProtocolConfig</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"protocol"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        <span class="comment">//service标签    service标签&lt;----&gt;ServiceBean</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"service"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean<span class="class">.<span class="keyword">class</span>, <span class="title">true</span>))</span>;</span><br><span class="line">        <span class="comment">//reference标签        reference&lt;----&gt;ReferenceBean</span></span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"reference"</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>))</span>;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">"annotation"</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于注解的配置原理解析"><a href="#基于注解的配置原理解析" class="headerlink" title="基于注解的配置原理解析"></a>基于注解的配置原理解析</h3><h4 id="Spring基于注解的简单调用流程"><a href="#Spring基于注解的简单调用流程" class="headerlink" title="Spring基于注解的简单调用流程"></a>Spring基于注解的简单调用流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext</span><br><span class="line">        AnnotatedBeanDefinitionReader --&gt;将传入的annotationclasses封装为BeanDefinition.</span><br><span class="line">        ClassPathBeanDefinitionScanner --&gt;利用ASM字节码扫描(@ComponentScan)具有指定注解的类并将其封装为BeanDefinition.</span><br><span class="line">                                                                          指定注解:@Component,@Repository,@Service,@Controller.(注意@Configuration注解含有@Component子注解).</span><br><span class="line">AbstactApplicationContext模板的解析Bean流程.</span><br><span class="line">refresh --&gt; </span><br><span class="line">                obtainFreshBeanFactory --&gt; loadBeanDefinitions</span><br><span class="line">                invokeBeanFactoryPostProcessors--&gt; 主要处理BeanFactoryPostProcessor</span><br><span class="line">                        ConfigurationClassPostProcessor</span><br><span class="line">                                --&gt;resolve @EnableDubbo</span><br><span class="line">                                                --&gt; @Import -&gt;DubboComponentScanRegistrar -&gt; ServiceAnnotationBeanPostProcessor+ReferenceAnnotationBeanPostProcessor</span><br><span class="line">                                                                        -&gt;DubboConfigConfigurationRegistrar-&gt;DubboConfiCOnfiguration-&gt;@EnableConfigurationBeanBinding</span><br><span class="line">                        ServiceAnnotationBeanPostProcessor &#x2F;&#x2F;解析@Service注解</span><br><span class="line">                finishBeanFactoryInitialization--&gt;解析BeanDefinition</span><br><span class="line">                        getBean--&gt;doCreateBean</span><br><span class="line">                                                --&gt;createBeanInstance 实例化 instantiate</span><br><span class="line">                                                初始化 Initialize</span><br><span class="line">                                                --&gt;populateBean 依赖注入</span><br><span class="line">                                                --&gt;initalizeBean 初始化</span><br><span class="line">                                                .....</span><br><span class="line">                                                applyBeanPostProcessorsBeforeInitialization </span><br><span class="line">                                                        --&gt;调用ReferenceAnnotationBeanPostProcessor</span><br></pre></td></tr></table></figure>
<h3 id="服务暴露的实现原理"><a href="#服务暴露的实现原理" class="headerlink" title="服务暴露的实现原理"></a>服务暴露的实现原理</h3><h4 id="dubbo配置的优先级"><a href="#dubbo配置的优先级" class="headerlink" title="dubbo配置的优先级"></a>dubbo配置的优先级</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法级别&gt;类级别</span><br><span class="line">消费端&gt;生产端</span><br><span class="line">jvm &gt; xml &gt; properties(默认配置)</span><br><span class="line">reference:method &gt; service:method </span><br><span class="line">                 &gt;reference &gt;service</span><br><span class="line">                 &gt;consumer &gt; provider</span><br><span class="line">jvm  (-D) &gt; xml(dubbo.xml)&gt;Properties(dubbo.properties)</span><br></pre></td></tr></table></figure>
<h4 id="dubbo服务暴露整体机制"><a href="#dubbo服务暴露整体机制" class="headerlink" title="dubbo服务暴露整体机制"></a>dubbo服务暴露整体机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Dubbo框架做服务暴露分为两步.</span><br><span class="line">  第一步将持有的服务实例通过代理封装成Invoker.</span><br><span class="line">  第二步将Invoker通过具体的协议(Dubbo)封装成Exporter.</span><br></pre></td></tr></table></figure>
<h4 id="远程服务的暴露"><a href="#远程服务的暴露" class="headerlink" title="远程服务的暴露"></a>远程服务的暴露</h4><p><img src="/2020/07/11/dubbo/dubbo-service-export.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Service真正进行服务暴露的入口点在ServiceConfig的doExport中.</span><br><span class="line">  ServiceConfig.doExport--&gt;</span><br><span class="line">       ServiceConfig#doExportUrls                   多注册中心,多协议暴露                       </span><br><span class="line">         --&gt;ServiceConfig#doExportUrlsFor1Protocol </span><br><span class="line">             --&gt;exportLocal                         injvm协议暴露,主要用于本地消费者调用本地生产者</span><br><span class="line">             通过代理工厂生成代理类</span><br><span class="line">             --&gt;proxyFactory#getInvoker(ref,(Class)interfaceClass,registryURL,......)</span><br><span class="line">             主要看下RegistryProtocol,这个里面会调DubboProtocol</span><br><span class="line">             --&gt;exporter&#x3D;protocol.export(invoker);&#x2F;&#x2F;创建netty服务,监听端口,将exporter加入内存供消费者调用.</span><br></pre></td></tr></table></figure>
<h4 id="注册中心协议暴露"><a href="#注册中心协议暴露" class="headerlink" title="注册中心协议暴露"></a>注册中心协议暴露</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.RegistryProtocol.export(invoker)</span><br><span class="line">    1.委托具体的通信协议(Dubbo)进行服务暴露,创建NettyServer监听端口和保存服务实例.</span><br><span class="line">            doLocalExport(originInvoker);--&gt;DubboProtocol.export(invoker))</span><br><span class="line">    2.创建注册中心实例,与注册中心建立TCP连接.</span><br><span class="line">        Registry registry&#x3D;getRegistry(orignInvoker);</span><br><span class="line">&#x2F;&#x2F;参考第三章</span><br><span class="line">    3.注册服务元数据到服务注册中心.  </span><br><span class="line">      register(registryUrl,registedProviderUrl);</span><br><span class="line">    4.订阅configurators节点.监听事件的改变.</span><br><span class="line">      registry.subscribe(overrideSubscrbeUrl,overrideSubscribeListener);</span><br></pre></td></tr></table></figure>
<h4 id="DubboProtocol的export方法"><a href="#DubboProtocol的export方法" class="headerlink" title="DubboProtocol的export方法"></a>DubboProtocol的export方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DubboProtocol</span><br><span class="line">   --&gt;export</span><br><span class="line">     --&gt;new DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">     --&gt;openServer(url)&#x2F;&#x2F;创建Netty,暴露端口</span><br><span class="line">     --&gt;return exporter;</span><br></pre></td></tr></table></figure>
<h4 id="本地服务暴露-injvm"><a href="#本地服务暴露-injvm" class="headerlink" title="本地服务暴露 injvm"></a>本地服务暴露 injvm</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InJvm协议主要用于一个Jvm内部调用自身服务的情况.Dubbo默认把远程服务用InJvm协议暴露一份.</span><br><span class="line">InJvmProtocol</span><br><span class="line">    InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line">        super(invoker);</span><br><span class="line">        this.key &#x3D; key;</span><br><span class="line">        this.exporterMap &#x3D; exporterMap;</span><br><span class="line">        &#x2F;&#x2F;Injvm协议的exporterMap.</span><br><span class="line">        exporterMap.put(key, this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务消费的原理"><a href="#服务消费的原理" class="headerlink" title="服务消费的原理"></a>服务消费的原理</h3><p><img src="/2020/07/11/dubbo/dubbo-service-reference.png" alt></p>
<h4 id="dubbo服务整体消费逻辑"><a href="#dubbo服务整体消费逻辑" class="headerlink" title="dubbo服务整体消费逻辑"></a>dubbo服务整体消费逻辑</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.dubbo做服务消费分为两大步骤.</span><br><span class="line">  第一步通过持有远程服务实例生成Invoker.</span><br><span class="line">  第二步把Invoker通过动态代理转换成实现用户接口的动态代理引用.</span><br></pre></td></tr></table></figure>
<h4 id="远程服务的消费"><a href="#远程服务的消费" class="headerlink" title="远程服务的消费"></a>远程服务的消费</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">1.ReferenceConfig.createProxy是消费的入口</span><br><span class="line">private T createProxy(Map&lt;String, String&gt; map) &#123;</span><br><span class="line">    &#x2F;&#x2F;injvm 服务是本机的</span><br><span class="line">    if (shouldJvmRefer(map)) &#123;</span><br><span class="line">        &#x2F;&#x2F;injvm 协议</span><br><span class="line">        URL url &#x3D; new URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName()).addParameters(map);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;直接获取invoker</span><br><span class="line">        invoker &#x3D; REF_PROTOCOL.refer(interfaceClass, url); </span><br><span class="line">        </span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;Using injvm service &quot; + interfaceClass.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        urls.clear();</span><br><span class="line">        if (url !&#x3D; null &amp;&amp; url.length() &gt; 0) &#123; &#x2F;&#x2F; user specified URL, could be peer-to-peer address, or register center&#39;s address.</span><br><span class="line">            String[] us &#x3D; SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">            if (us !&#x3D; null &amp;&amp; us.length &gt; 0) &#123;</span><br><span class="line">                for (String u : us) &#123;</span><br><span class="line">                    URL url &#x3D; URL.valueOf(u);</span><br><span class="line">                    if (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                        url &#x3D; url.setPath(interfaceName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123; &#x2F;&#x2F; assemble URL from register center&#39;s configuration</span><br><span class="line">            &#x2F;&#x2F; if protocols not injvm checkRegistry</span><br><span class="line">            if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;</span><br><span class="line">                checkRegistry();</span><br><span class="line">                List&lt;URL&gt; us &#x3D; ConfigValidationUtils.loadRegistries(this, false);</span><br><span class="line">                if (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                    for (URL u : us) &#123;</span><br><span class="line">                        URL monitorUrl &#x3D; ConfigValidationUtils.loadMonitor(this, u);</span><br><span class="line">                        if (monitorUrl !&#x3D; null) &#123;</span><br><span class="line">                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F;注册中心添加refer存储服务消费元数据信息</span><br><span class="line">                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (urls.isEmpty()) &#123;</span><br><span class="line">                    throw new IllegalStateException(&quot;No such any registry to reference &quot; + interfaceName + &quot; on the consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, please config &lt;dubbo:registry address&#x3D;\&quot;...\&quot; &#x2F;&gt; to your spring config.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;PROTOCOL 看 RegistryProtocol</span><br><span class="line">        if (urls.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            &#x2F;&#x2F;单注册中心消费</span><br><span class="line">            invoker &#x3D; REF_PROTOCOL.refer(interfaceClass, urls.get(0));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            List&lt;Invoker&lt;?&gt;&gt; invokers &#x3D; new ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">            URL registryURL &#x3D; null;</span><br><span class="line">            for (URL url : urls) &#123;</span><br><span class="line">                &#x2F;&#x2F;将每个注册中心的服务添加到invokers列表</span><br><span class="line">                invokers.add(REF_PROTOCOL.refer(interfaceClass, url));</span><br><span class="line">                if (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                    &#x2F;&#x2F;使用最后一个注册中心url</span><br><span class="line">                    registryURL &#x3D; url; &#x2F;&#x2F; use last registry url</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (registryURL !&#x3D; null) &#123; &#x2F;&#x2F; registry url is available</span><br><span class="line">                &#x2F;&#x2F; for multi-subscription scenario, use &#39;zone-aware&#39; policy by default</span><br><span class="line">                &#x2F;&#x2F;默认使用区域感知策略</span><br><span class="line">                URL u &#x3D; registryURL.addParameterIfAbsent(CLUSTER_KEY, ZoneAwareCluster.NAME);</span><br><span class="line">                &#x2F;&#x2F; The invoker wrap relation would be like: ZoneAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, routing happens here) -&gt; Invoker</span><br><span class="line">                &#x2F;&#x2F;CLUSTER会根据路由和其它条件选出一个Invoker</span><br><span class="line">                invoker &#x3D; CLUSTER.join(new StaticDirectory(u, invokers));</span><br><span class="line">            &#125; else &#123; &#x2F;&#x2F; not a registry url, must be direct invoke.</span><br><span class="line">                &#x2F;&#x2F;没有注册url,是直接invoke</span><br><span class="line">                invoker &#x3D; CLUSTER.join(new StaticDirectory(invokers));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (shouldCheck() &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">        throw new IllegalStateException(&quot;Failed to check the status of the service &quot;</span><br><span class="line">                + interfaceName</span><br><span class="line">                + &quot;. No provider available for the service &quot;</span><br><span class="line">                + (group &#x3D;&#x3D; null ? &quot;&quot; : group + &quot;&#x2F;&quot;)</span><br><span class="line">                + interfaceName +</span><br><span class="line">                (version &#x3D;&#x3D; null ? &quot;&quot; : &quot;:&quot; + version)</span><br><span class="line">                + &quot; from the url &quot;</span><br><span class="line">                + invoker.getUrl()</span><br><span class="line">                + &quot; to the consumer &quot;</span><br><span class="line">                + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion());</span><br><span class="line">    &#125;</span><br><span class="line">    if (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(&quot;Refer dubbo service &quot; + interfaceClass.getName() + &quot; from url &quot; + invoker.getUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @since 2.7.0</span><br><span class="line">     * ServiceData Store</span><br><span class="line">     *&#x2F;</span><br><span class="line">    String metadata &#x3D; map.get(METADATA_KEY);</span><br><span class="line">    WritableMetadataService metadataService &#x3D; WritableMetadataService.getExtension(metadata &#x3D;&#x3D; null ? DEFAULT_METADATA_STORAGE_TYPE : metadata);</span><br><span class="line">    if (metadataService !&#x3D; null) &#123;</span><br><span class="line">        URL consumerURL &#x3D; new URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), 0, map.get(INTERFACE_KEY), map);</span><br><span class="line">        metadataService.publishServiceDefinition(consumerURL);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; create service proxy</span><br><span class="line">    &#x2F;&#x2F;将Invoker创建成代理</span><br><span class="line">    return (T) PROXY_FACTORY.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注册中心协议消费"><a href="#注册中心协议消费" class="headerlink" title="注册中心协议消费"></a>注册中心协议消费</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//获取注册url</span></span><br><span class="line">    url = getRegistryUrl(url);</span><br><span class="line">    <span class="comment">//创建注册中心实例</span></span><br><span class="line">    Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">    <span class="keyword">if</span> (RegistryService<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">type</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// group="a,b" or group="*"</span></span><br><span class="line">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">    String group = qs.get(GROUP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">"*"</span>.equals(group)) &#123;</span><br><span class="line">            <span class="comment">//多组订阅</span></span><br><span class="line">            <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//消费核心关键,持有实际的Invoker和接收订阅通知</span></span><br><span class="line">    RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">    Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">    <span class="comment">//创建订阅Url</span></span><br><span class="line">    URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">    <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">        <span class="comment">//注册消费消息到注册中心</span></span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据url的route配置创建RouterChain</span></span><br><span class="line">    directory.buildRouterChain(subscribeUrl);</span><br><span class="line">    <span class="comment">//服务消费者订阅 服务提供者,配置,路由信息</span></span><br><span class="line">    <span class="comment">//订阅后会有一个notifier,将拉取的数据放到directory中,并会使用具体的通信协议例如dubbo,去创建invoker，并放入directory中</span></span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">            PROVIDERS_CATEGORY + <span class="string">","</span> + CONFIGURATORS_CATEGORY + <span class="string">","</span> + ROUTERS_CATEGORY));</span><br><span class="line">    <span class="comment">//cluster选出一个invoker</span></span><br><span class="line">    Invoker invoker = cluster.join(directory);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br><span class="line">RegistryDirectory的notify方法会调用toInvokers方法动态更新</span><br><span class="line"><span class="comment">//consumer端 根据url创建Invoker,如果url对应的Invoker已经创建,就不会重新创建</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123;</span><br><span class="line">    Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;String&gt; keys = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">//获取消费端支持的协议</span></span><br><span class="line">    String queryProtocols = <span class="keyword">this</span>.queryMap.get(PROTOCOL_KEY);</span><br><span class="line">    <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line">        <span class="comment">// If protocol is configured at the reference side, only the matching protocol is selected</span></span><br><span class="line">        <span class="keyword">if</span> (queryProtocols != <span class="keyword">null</span> &amp;&amp; queryProtocols.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> accept = <span class="keyword">false</span>;</span><br><span class="line">            String[] acceptProtocols = queryProtocols.split(<span class="string">","</span>);</span><br><span class="line">            <span class="keyword">for</span> (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">                <span class="keyword">if</span> (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                    accept = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!accept) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">providerUrl</span>.<span class="title">getProtocol</span>())) </span>&#123;</span><br><span class="line">            logger.error(<span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported protocol "</span> + providerUrl.getProtocol() +</span><br><span class="line">                    <span class="string">" in notified url: "</span> + providerUrl + <span class="string">" from registry "</span> + getUrl().getAddress() +</span><br><span class="line">                    <span class="string">" to consumer "</span> + NetUtils.getLocalHost() + <span class="string">", supported protocol: "</span> +</span><br><span class="line">                    ExtensionLoader.getExtensionLoader(Protocol<span class="class">.<span class="keyword">class</span>).<span class="title">getSupportedExtensions</span>()))</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//合并服务端的配置数据</span></span><br><span class="line">        URL url = mergeUrl(providerUrl);</span><br><span class="line"></span><br><span class="line">        String key = url.toFullString(); <span class="comment">// The parameter urls are sorted</span></span><br><span class="line">        <span class="keyword">if</span> (keys.contains(key)) &#123; <span class="comment">// Repeated url</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.add(key);</span><br><span class="line">        <span class="comment">// Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="keyword">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="keyword">null</span> ? <span class="keyword">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (invoker == <span class="keyword">null</span>) &#123; <span class="comment">// Not in the cache, refer again</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> enabled = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (url.hasParameter(DISABLED_KEY)) &#123;</span><br><span class="line">                    enabled = !url.getParameter(DISABLED_KEY, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    enabled = url.getParameter(ENABLED_KEY, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                    <span class="comment">//使用具体的协议创建远程连接 例如 dubbo协议</span></span><br><span class="line">                    invoker = <span class="keyword">new</span> InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to refer invoker for interface:"</span> + serviceType + <span class="string">",url:("</span> + url + <span class="string">")"</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (invoker != <span class="keyword">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newUrlInvokerMap.put(key, invoker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys.clear();</span><br><span class="line">    <span class="comment">//每次都创建一个新的，考虑了安全性问题</span></span><br><span class="line">    <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="DubboProtol逻辑"><a href="#DubboProtol逻辑" class="headerlink" title="DubboProtol逻辑"></a>DubboProtol逻辑</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">RegistryDirectory#toInvokers 调用 invoker = new InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);//url已经是目标服务了</span><br><span class="line">Invoker创建时在DubboProtocol#refer中,DubboInvoker在返回invoker之前会创建客户端连接对象。</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AsyncToSyncInvoker&lt;&gt;(protocolBindingRefer(type, url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">protocolBindingRefer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create rpc invoker.</span></span><br><span class="line">    DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">    invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br><span class="line">DubboProtocol#getClients -&gt;initClients</span><br><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">initClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client type setting.</span></span><br><span class="line">    String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT));</span><br><span class="line"></span><br><span class="line">    url = url.addParameter(CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">    <span class="comment">// enable heartbeat by default</span></span><br><span class="line">    url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BIO is not allowed since it has severe performance issue.</span></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter<span class="class">.<span class="keyword">class</span>).<span class="title">hasExtension</span>(<span class="title">str</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Unsupported client type: "</span> + str + <span class="string">","</span> +</span><br><span class="line">                " supported client type is " + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), " "));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExchangeClient client;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//懒模式</span></span><br><span class="line">        <span class="comment">// connection should be lazy</span></span><br><span class="line">        <span class="keyword">if</span> (url.getParameter(LAZY_CONNECT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            client = <span class="keyword">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            #连接</span><br><span class="line">            client = Exchangers.connect(url, requestHandler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Fail to create remoting client for service("</span> + url + <span class="string">"): "</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dubbo多注册中心消费原理"><a href="#Dubbo多注册中心消费原理" class="headerlink" title="Dubbo多注册中心消费原理"></a>Dubbo多注册中心消费原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.多注册中心的消费原理很简单，多个注册中心最终都会根据对应的Service的服务提供者的url创建Invoker并存入StaticDirectory中，最后会通过cluster挑选出一个Invoker.</span><br><span class="line">ReferenceConfig#createProxy</span><br><span class="line">   for (URL url : urls) &#123;</span><br><span class="line">        &#x2F;&#x2F;将每个注册中心的服务添加到invokers列表</span><br><span class="line">        invokers.add(REF_PROTOCOL.refer(interfaceClass, url));</span><br><span class="line">        if (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">            &#x2F;&#x2F;使用最后一个注册url</span><br><span class="line">            registryURL &#x3D; url; &#x2F;&#x2F; use last registry url</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dubbo直连服务消费原理"><a href="#Dubbo直连服务消费原理" class="headerlink" title="Dubbo直连服务消费原理"></a>Dubbo直连服务消费原理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReferenceConfig --&gt;</span><br><span class="line">     --&gt; createProxy </span><br><span class="line">        .....</span><br><span class="line">        if(Constants.REGISTRY_PROTOCOL.equals(url.getProtocol()))&#123;</span><br><span class="line">                urls.add(url.addParameterAndEncode(Constants.REFER_KEY,StringUtils.toQueryString(map)));</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;直连,url中若有多个机器地址,也会触发负载均衡.</span><br><span class="line">                urls.add(ClusterUtils.mergeUrl(url,map));&#x2F;&#x2F;没有添加refer和registry参数</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dubbo优雅停机原理"><a href="#Dubbo优雅停机原理" class="headerlink" title="Dubbo优雅停机原理"></a>Dubbo优雅停机原理</h4><p><img src="/2020/07/11/dubbo/dubbo%E4%BC%98%E9%9B%85%E5%81%9C%E6%9C%BA.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.Dubbo中实现的优雅停机机制的6个步骤.</span><br><span class="line">   1.provider端unregister(删除节点)服务元数据信息.</span><br><span class="line">   2.consumer订阅了服务元数据信息会收到注册中心通知,更新providers列表.</span><br><span class="line">   3.Dubbo协议发送readonly给所有的订阅该服务的consumers,告知服务不可用.</span><br><span class="line">   4.provider端等待当前任务结束后退出.</span><br><span class="line">2.readonly报文的作用?</span><br><span class="line">  注册中心可能出现网络延迟,所以会额外的发送readonly报文给consumer端.</span><br></pre></td></tr></table></figure>
<h2 id="Dubbo-远程调用"><a href="#Dubbo-远程调用" class="headerlink" title="Dubbo 远程调用"></a>Dubbo 远程调用</h2><h3 id="dubbo核心调用流程"><a href="#dubbo核心调用流程" class="headerlink" title="dubbo核心调用流程"></a>dubbo核心调用流程</h3><p><img src="/2020/07/11/dubbo/dubbo%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt></p>
<h3 id="Dubbo协议详解"><a href="#Dubbo协议详解" class="headerlink" title="Dubbo协议详解"></a>Dubbo协议详解</h3><h4 id="Dubbo报文格式"><a href="#Dubbo报文格式" class="headerlink" title="Dubbo报文格式"></a>Dubbo报文格式</h4><p><img src="/2020/07/11/dubbo/dubbo%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">报文头部格式解析</span><br><span class="line">0~15            魔数            dabb</span><br><span class="line">16            数据包类型       0表示Response,1表示Request</span><br><span class="line">17             调用方式        0表示单向调用,1表示双向调用,例如readonly是单向调用</span><br><span class="line">18             事件标识        0标志数据包是请求包或相应包,1表示当前数据包是心跳包</span><br><span class="line">19~23         序列化器编号     3为JavaSerialization 6为FastJsonSerialization</span><br><span class="line">24~31           状态           20为OK 30为ClIENT——TIMEOUT 40为Server_TIMEOUT</span><br><span class="line">32~95         请求编号         8个字节表示请求唯一id</span><br><span class="line">96~127        消息体长头       4个字节存储报文长度</span><br></pre></td></tr></table></figure>
<h4 id="请求消息体"><a href="#请求消息体" class="headerlink" title="请求消息体"></a>请求消息体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">128~          消息体           Dubbo版本号,服务接口名,服务接口版本,方法名,参数类型,方法参数值,请求额外参数</span><br></pre></td></tr></table></figure>
<h4 id="响应消息体"><a href="#响应消息体" class="headerlink" title="响应消息体"></a>响应消息体</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">128~          消息体          返回状态标记(响应标记)</span><br><span class="line">状态值 | 状态符号 | 作用</span><br><span class="line">:-: | :-: | :-: </span><br><span class="line">5 | RESPONSE_NULL_VALUE_WITH_ATTACHMENTS|响应空值包含隐藏函数| </span><br><span class="line">4 | RESPONSE_VALUE_WITH_ATTACHMENTS|响应结果包含隐藏函数|</span><br><span class="line">3 | RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS|异常返回包含隐藏参数|</span><br><span class="line">2 | RESPONSE_NULL_VALUE|响应空值|</span><br><span class="line">1 | RESPONSE_VALUE|响应结果|</span><br><span class="line">0 | RESPONSE_WITH_EXCEPTION|异常返回 |</span><br></pre></td></tr></table></figure>
<h4 id="粘包-解包"><a href="#粘包-解包" class="headerlink" title="粘包/解包"></a>粘包/解包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.dubbo报文用报文长度和魔数(包定界)解决该问题</span><br></pre></td></tr></table></figure>
<h4 id="dubbo如何在高并发的保证安全性"><a href="#dubbo如何在高并发的保证安全性" class="headerlink" title="dubbo如何在高并发的保证安全性"></a>dubbo如何在高并发的保证安全性</h4><p><img src="/2020/07/11/dubbo/dubbo%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">异步+唯一ID</span><br><span class="line">异步 ---&gt;DefaultFuture---&gt;CompletableFuture</span><br><span class="line">一个get阻塞操作对应一个线程</span><br><span class="line">用DefaultFuture主要用到whenComplete,...等方法.</span><br></pre></td></tr></table></figure>
<h3 id="编码器原理"><a href="#编码器原理" class="headerlink" title="编码器原理"></a>编码器原理</h3><h4 id="编码器的总体模板模式"><a href="#编码器的总体模板模式" class="headerlink" title="编码器的总体模板模式"></a>编码器的总体模板模式</h4><p><img src="/2020/07/11/dubbo/Dubbo%E7%BC%96%E7%A0%81%E5%99%A8%E6%A8%A1%E6%9D%BF.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">AbstractCodec是提供基础能力,检验报文长度,使用具体的编码器.</span><br><span class="line">TransportCodec抽象编解码器实现,调用序列化、反序列化和自动cleanup流.</span><br><span class="line">DubboCodec继承自ExchangeCodec,继承了TelnetCodec实现.(ps:Telnet实现复用了dubbo协议的端口)</span><br><span class="line">DobboCountCodec的实现是为了解决一次流中包含多个RPC请求,实现很简单,就是依次调用DubboCodec去解码.</span><br><span class="line">DubboCountCodec源码</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboCountCodec</span> <span class="keyword">implements</span> <span class="title">Codec2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DubboCodec codec = <span class="keyword">new</span> DubboCodec();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        codec.encode(channel, buffer, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * buffer中可能含有多个RPC请求,调用DubboCodec处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> save = buffer.readerIndex();</span><br><span class="line">        MultiMessage result = MultiMessage.create();</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            Object obj = codec.decode(channel, buffer);</span><br><span class="line">            <span class="keyword">if</span> (Codec2.DecodeResult.NEED_MORE_INPUT == obj) &#123;</span><br><span class="line">                buffer.readerIndex(save);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.addMessage(obj);</span><br><span class="line">                logMessageLength(obj, buffer.readerIndex() - save);</span><br><span class="line">                save = buffer.readerIndex();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Codec2.DecodeResult.NEED_MORE_INPUT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ExchangeCodec#encodeRequest</span><br><span class="line">channel---&gt;buffer---&gt;ObjectOutput(url-&gt;socket)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequest</span><span class="params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Serialization serialization = getSerialization(channel);</span><br><span class="line">    <span class="comment">// header.</span></span><br><span class="line">    <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[HEADER_LENGTH];</span><br><span class="line">    <span class="comment">// set magic number.</span></span><br><span class="line">    Bytes.short2bytes(MAGIC, header);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set request and serialization flag.  </span></span><br><span class="line">    header[<span class="number">2</span>] = (<span class="keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (req.isTwoWay()) &#123;</span><br><span class="line">        header[<span class="number">2</span>] |= FLAG_TWOWAY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">        header[<span class="number">2</span>] |= FLAG_EVENT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set request id.  </span></span><br><span class="line">    Bytes.long2bytes(req.getId(), header, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// encode request data.</span></span><br><span class="line">    <span class="keyword">int</span> savedWriteIndex = buffer.writerIndex();</span><br><span class="line">    <span class="comment">//先写payload</span></span><br><span class="line">    buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);</span><br><span class="line">    ChannelBufferOutputStream bos = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br><span class="line">    ObjectOutput out = serialization.serialize(channel.getUrl(), bos);</span><br><span class="line">    <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">        encodeEventData(channel, out, req.getData());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        encodeRequestData(channel, out, req.getData(), req.getVersion());</span><br><span class="line">    &#125;</span><br><span class="line">    out.flushBuffer();</span><br><span class="line">    <span class="keyword">if</span> (out <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">        ((Cleanable) out).cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    bos.flush();</span><br><span class="line">    bos.close();</span><br><span class="line">    <span class="keyword">int</span> len = bos.writtenBytes();</span><br><span class="line">    checkPayload(channel, len);</span><br><span class="line">    Bytes.int2bytes(len, header, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再写header buffer可以随机写</span></span><br><span class="line">    buffer.writerIndex(savedWriteIndex);</span><br><span class="line">    buffer.writeBytes(header); <span class="comment">// write header.</span></span><br><span class="line">    buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DubboCodec#encodeRequestData</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeRequestData</span><span class="params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RpcInvocation inv = (RpcInvocation) data;</span><br><span class="line"></span><br><span class="line">    out.writeUTF(version);</span><br><span class="line">    out.writeUTF((String) inv.getAttachment(PATH_KEY));</span><br><span class="line">    out.writeUTF((String) inv.getAttachment(VERSION_KEY));</span><br><span class="line"></span><br><span class="line">    out.writeUTF(inv.getMethodName());</span><br><span class="line">    out.writeUTF(inv.getParameterTypesDesc());</span><br><span class="line">    Object[] args = inv.getArguments();</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            out.writeObject(encodeInvocationArgument(channel, inv, i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out.writeAttachments(sieveUnnecessaryAttachments(inv));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">编码响应对象</span><br><span class="line">ExchangeCodec#encodeResponse</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeResponse</span><span class="params">(Channel channel, ChannelBuffer buffer, Response res)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> savedWriteIndex = buffer.writerIndex();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Serialization serialization = getSerialization(channel);</span><br><span class="line">        <span class="comment">// header.</span></span><br><span class="line">        <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[HEADER_LENGTH];</span><br><span class="line">        <span class="comment">// set magic number.</span></span><br><span class="line">        Bytes.short2bytes(MAGIC, header);</span><br><span class="line">        <span class="comment">// set request and serialization flag.</span></span><br><span class="line">        header[<span class="number">2</span>] = serialization.getContentTypeId();</span><br><span class="line">        <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">            header[<span class="number">2</span>] |= FLAG_EVENT;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set response status.</span></span><br><span class="line">        <span class="keyword">byte</span> status = res.getStatus();</span><br><span class="line">        header[<span class="number">3</span>] = status;</span><br><span class="line">        <span class="comment">// set request id.</span></span><br><span class="line">        Bytes.long2bytes(res.getId(), header, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">//先写body payload</span></span><br><span class="line">        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);</span><br><span class="line">        ChannelBufferOutputStream bos = <span class="keyword">new</span> ChannelBufferOutputStream(buffer);</span><br><span class="line">        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);</span><br><span class="line">        <span class="comment">// encode response data or error message.</span></span><br><span class="line">        <span class="keyword">if</span> (status == Response.OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.isHeartbeat()) &#123;</span><br><span class="line">                encodeEventData(channel, out, res.getResult());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                encodeResponseData(channel, out, res.getResult(), res.getVersion());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out.writeUTF(res.getErrorMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flushBuffer();</span><br><span class="line">        <span class="keyword">if</span> (out <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) out).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">        bos.flush();</span><br><span class="line">        bos.close();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = bos.writtenBytes();</span><br><span class="line">        checkPayload(channel, len);</span><br><span class="line">        Bytes.int2bytes(len, header, <span class="number">12</span>);</span><br><span class="line">        <span class="comment">// 再写header</span></span><br><span class="line">        buffer.writerIndex(savedWriteIndex);</span><br><span class="line">        buffer.writeBytes(header); <span class="comment">// write header.</span></span><br><span class="line">        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// clear buffer</span></span><br><span class="line">        buffer.writerIndex(savedWriteIndex);</span><br><span class="line">        <span class="comment">// send error message to Consumer, otherwise, Consumer will wait till timeout.</span></span><br><span class="line">        <span class="keyword">if</span> (!res.isEvent() &amp;&amp; res.getStatus() != Response.BAD_RESPONSE) &#123;</span><br><span class="line">            Response r = <span class="keyword">new</span> Response(res.getId(), res.getVersion());</span><br><span class="line">            r.setStatus(Response.BAD_RESPONSE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> ExceedPayloadLimitException) &#123;</span><br><span class="line">                logger.warn(t.getMessage(), t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.setErrorMessage(t.getMessage());</span><br><span class="line">                    channel.send(r);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to send bad_response info back: "</span> + t.getMessage() + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// FIXME log error message in Codec and handle in caught() of IoHanndler?</span></span><br><span class="line">                logger.warn(<span class="string">"Fail to encode response: "</span> + res + <span class="string">", send bad_response info instead, cause: "</span> + t.getMessage(), t);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.setErrorMessage(<span class="string">"Failed to send response: "</span> + res + <span class="string">", cause: "</span> + StringUtils.toString(t));</span><br><span class="line">                    channel.send(r);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to send bad_response info back: "</span> + res + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rethrow exception</span></span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (IOException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (Error) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">DubboCodec#encodeResponseData</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encodeResponseData</span><span class="params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Result result = (Result) data;</span><br><span class="line">    <span class="comment">// currently, the version value in Response records the version of Request</span></span><br><span class="line">    <span class="comment">//判断客户端版本是否支持服务器端参数返回</span></span><br><span class="line">    <span class="keyword">boolean</span> attach = Version.isSupportResponseAttachment(version);</span><br><span class="line">    Throwable th = result.getException();</span><br><span class="line">    <span class="keyword">if</span> (th == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object ret = result.getValue();</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="keyword">null</span>) &#123;</span><br><span class="line">            out.writeByte(attach ? RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//先写一个字节标志(见前方body格式)</span></span><br><span class="line">            out.writeByte(attach ? RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);</span><br><span class="line">            <span class="comment">//再写结果</span></span><br><span class="line">            out.writeObject(ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        out.writeByte(attach ? RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);</span><br><span class="line">        out.writeThrowable(th);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (attach) &#123;</span><br><span class="line">        <span class="comment">//写回服务端隐藏参数</span></span><br><span class="line">        <span class="comment">// returns current version of Response to consumer side.</span></span><br><span class="line">        result.getAttachments().put(DUBBO_VERSION_KEY, Version.getProtocolVersion());</span><br><span class="line">        out.writeAttachments(result.getAttachments());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dubbo协议解码器"><a href="#Dubbo协议解码器" class="headerlink" title="Dubbo协议解码器"></a>Dubbo协议解码器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解码比编码较为复杂点,解码工作分为2部分,第一部分是解析报文头部,第二部分是解析报文体内容并将其转换为RpcInvocation.</span><br></pre></td></tr></table></figure>
<h4 id="解码器模板"><a href="#解码器模板" class="headerlink" title="解码器模板"></a>解码器模板</h4><p><img src="/2020/07/11/dubbo/Dubbo%E7%BC%96%E7%A0%81%E5%99%A8%E6%A8%A1%E6%9D%BF.png" alt></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">ExchangeCodec#decode</span><br><span class="line">buffer已经放好了当前到的数据,可能出现拆包和组包问题,channel是socket输入流</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, ChannelBuffer buffer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> readable = buffer.readableBytes();</span><br><span class="line">    <span class="keyword">byte</span>[] header = <span class="keyword">new</span> <span class="keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];</span><br><span class="line">    <span class="comment">//读取报文头部</span></span><br><span class="line">    buffer.readBytes(header);</span><br><span class="line">    <span class="keyword">return</span> decode(channel, buffer, readable, header);</span><br><span class="line">&#125;</span><br><span class="line">DubboCodec#decode</span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decodeBody</span><span class="params">(Channel channel, InputStream is, <span class="keyword">byte</span>[] header)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> flag = header[<span class="number">2</span>], proto = (<span class="keyword">byte</span>) (flag &amp; SERIALIZATION_MASK);</span><br><span class="line">    <span class="comment">// get request id.</span></span><br><span class="line">    <span class="keyword">long</span> id = Bytes.bytes2long(header, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> ((flag &amp; FLAG_REQUEST) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//解析响应.</span></span><br><span class="line">        Response res = <span class="keyword">new</span> Response(id);</span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            res.setEvent(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// get status.</span></span><br><span class="line">        <span class="keyword">byte</span> status = header[<span class="number">3</span>];</span><br><span class="line">        res.setStatus(status);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (status == Response.OK) &#123;</span><br><span class="line">                Object data;</span><br><span class="line">                <span class="keyword">if</span> (res.isEvent()) &#123;</span><br><span class="line">                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">                    data = decodeEventData(channel, in);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    DecodeableRpcResult result;</span><br><span class="line">                    <span class="keyword">if</span> (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                        result = <span class="keyword">new</span> DecodeableRpcResult(channel, res, is,</span><br><span class="line">                                (Invocation) getRequestData(id), proto);</span><br><span class="line">                        result.decode();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result = <span class="keyword">new</span> DecodeableRpcResult(channel, res,</span><br><span class="line">                                <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)),</span><br><span class="line">                                (Invocation) getRequestData(id), proto);</span><br><span class="line">                    &#125;</span><br><span class="line">                    data = result;</span><br><span class="line">                &#125;</span><br><span class="line">                res.setResult(data);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">                res.setErrorMessage(in.readUTF());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                log.warn(<span class="string">"Decode response failed: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            res.setStatus(Response.CLIENT_ERROR);</span><br><span class="line">            res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解析请求.</span></span><br><span class="line">        Request req = <span class="keyword">new</span> Request(id);</span><br><span class="line">        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">        req.setTwoWay((flag &amp; FLAG_TWOWAY) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((flag &amp; FLAG_EVENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            req.setEvent(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object data;</span><br><span class="line">            <span class="keyword">if</span> (req.isEvent()) &#123;</span><br><span class="line">                ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);</span><br><span class="line">                data = decodeEventData(channel, in);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DecodeableRpcInvocation inv;</span><br><span class="line">                <span class="keyword">if</span> (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123;</span><br><span class="line">                    inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req, is, proto);</span><br><span class="line">                    inv.decode();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    inv = <span class="keyword">new</span> DecodeableRpcInvocation(channel, req,</span><br><span class="line">                            <span class="keyword">new</span> UnsafeByteArrayInputStream(readMessageData(is)), proto);</span><br><span class="line">                &#125;</span><br><span class="line">                data = inv;</span><br><span class="line">            &#125;</span><br><span class="line">            req.setData(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                log.warn(<span class="string">"Decode request failed: "</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// bad request</span></span><br><span class="line">            req.setBroken(<span class="keyword">true</span>);</span><br><span class="line">            req.setData(t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> req;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">解码Request报文</span><br><span class="line">DecodeableRpcInvocation#decode</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">            .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">    String dubboVersion = in.readUTF();</span><br><span class="line">    request.setVersion(dubboVersion);</span><br><span class="line">    setAttachment(DUBBO_VERSION_KEY, dubboVersion);</span><br><span class="line"></span><br><span class="line">    String path = in.readUTF();</span><br><span class="line">    setAttachment(PATH_KEY, path);</span><br><span class="line">    setAttachment(VERSION_KEY, in.readUTF());</span><br><span class="line"></span><br><span class="line">    setMethodName(in.readUTF());</span><br><span class="line"></span><br><span class="line">    String desc = in.readUTF();</span><br><span class="line">    setParameterTypesDesc(desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] args = DubboCodec.EMPTY_OBJECT_ARRAY;</span><br><span class="line">        Class&lt;?&gt;[] pts = DubboCodec.EMPTY_CLASS_ARRAY;</span><br><span class="line">        <span class="keyword">if</span> (desc.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//                if (RpcUtils.isGenericCall(path, getMethodName()) || RpcUtils.isEcho(path, getMethodName())) &#123;</span></span><br><span class="line"><span class="comment">//                    pts = ReflectUtils.desc2classArray(desc);</span></span><br><span class="line"><span class="comment">//                &#125; else &#123;</span></span><br><span class="line">            ServiceRepository repository = ApplicationModel.getServiceRepository();</span><br><span class="line">            ServiceDescriptor serviceDescriptor = repository.lookupService(path);</span><br><span class="line">            <span class="keyword">if</span> (serviceDescriptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                MethodDescriptor methodDescriptor = serviceDescriptor.getMethod(getMethodName(), desc);</span><br><span class="line">                <span class="keyword">if</span> (methodDescriptor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pts = methodDescriptor.getParameterClasses();</span><br><span class="line">                    <span class="keyword">this</span>.setReturnTypes(methodDescriptor.getReturnTypes());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pts == DubboCodec.EMPTY_CLASS_ARRAY) &#123;</span><br><span class="line">                pts = ReflectUtils.desc2classArray(desc);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">            args = <span class="keyword">new</span> Object[pts.length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    args[i] = in.readObject(pts[i]);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                        log.warn(<span class="string">"Decode argument failed: "</span> + e.getMessage(), e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        setParameterTypes(pts);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = in.readAttachments();</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; attachment = getAttachments();</span><br><span class="line">            <span class="keyword">if</span> (attachment == <span class="keyword">null</span>) &#123;</span><br><span class="line">                attachment = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            attachment.putAll(map);</span><br><span class="line">            setAttachments(attachment);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//decode argument ,may be callback</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">            args[i] = decodeInvocationArgument(channel, <span class="keyword">this</span>, pts, i, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setArguments(args);</span><br><span class="line">        String targetServiceName = buildKey((String) getAttachment(PATH_KEY),</span><br><span class="line">                (String) getAttachment(GROUP_KEY),</span><br><span class="line">                (String) getAttachment(VERSION_KEY));</span><br><span class="line">        setTargetServiceUniqueName(targetServiceName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(StringUtils.toString(<span class="string">"Read invocation data failed."</span>, e));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">            ((Cleanable) in).cleanup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">解码响应</span><br><span class="line">DecodeableRpcResult#decode</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(Channel channel, InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    log.debug(<span class="string">"Decoding in thread -- "</span> + Thread.currentThread().getName());</span><br><span class="line">    ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)</span><br><span class="line">            .deserialize(channel.getUrl(), input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span> flag = in.readByte();</span><br><span class="line">    <span class="keyword">switch</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE:</span><br><span class="line">            handleValue(in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION:</span><br><span class="line">            handleException(in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">            handleAttachment(in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:</span><br><span class="line">            handleValue(in);</span><br><span class="line">            handleAttachment(in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:</span><br><span class="line">            handleException(in);</span><br><span class="line">            handleAttachment(in);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unknown result flag, expect '0' '1' '2' '3' '4' '5', but received: "</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (in <span class="keyword">instanceof</span> Cleanable) &#123;</span><br><span class="line">        ((Cleanable) in).cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Telnet调用原理"><a href="#Telnet调用原理" class="headerlink" title="Telnet调用原理"></a>Telnet调用原理</h3><h4 id="dubbo-Telnet-的使用"><a href="#dubbo-Telnet-的使用" class="headerlink" title="dubbo Telnet 的使用"></a>dubbo Telnet 的使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">参考 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://dubbo.apache.org/zh-cn/docs/user/references/telnet.html"</span>&gt;</span>http://dubbo.apache.org/zh-cn/docs/user/references/telnet.html<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">dubbo 2.0.5版本开始后,dubbo支持通过telnet命令来进行服务治理</span><br><span class="line">telnet localhost 20880   进入</span><br><span class="line">ls 显示服务列表</span><br><span class="line">ps  </span><br><span class="line">   -l   服务地址列表</span><br><span class="line">   20880 显示该端口的连接信息</span><br><span class="line">cd XXXService 改变缺省服务</span><br><span class="line">cd  /         改变为缺省服务</span><br><span class="line">pwd           显示缺省服务</span><br><span class="line">count         统计服务的调用次数</span><br><span class="line">invoke        调用服务方法</span><br><span class="line">      invoke   HelloService.sayHello("你好");</span><br><span class="line">      invoke   com.vicyor.service.HelloService.sayHello("你好")</span><br><span class="line">      invoke   sayHello("你好")</span><br><span class="line">select         当invoke命令匹配到多个方法时候,根据列表选择需要调用的方法</span><br><span class="line">status         汇总所有资源的状态</span><br><span class="line">log            </span><br><span class="line">   log debug   修改dubbo logger的日志级别</span><br><span class="line">help           帮助命令</span><br><span class="line">clear</span><br><span class="line">exit</span><br><span class="line">shutdown       关闭dubbo应用</span><br><span class="line">  shutdown -t 1000</span><br></pre></td></tr></table></figure>
<h4 id="调用原理"><a href="#调用原理" class="headerlink" title="调用原理"></a>调用原理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">所用的telnet命令处理都是实现TelnetHandler</span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TelnetHandler</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">telnet</span><span class="params">(Channel channel, String message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">&#125;</span><br><span class="line">完成Telnet指令转发的核心类是TelnetHandlerAdapter</span><br><span class="line">逻辑:将用输入的指令识别成command,将参数识别成message,根据command找到TelnetHandler去处理</span><br><span class="line">TelnetHandlerAdapter#telnet</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">telnet</span><span class="params">(Channel channel, String message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    String prompt = channel.getUrl().getParameterAndDecoded(Constants.PROMPT_KEY, Constants.DEFAULT_PROMPT);</span><br><span class="line">    <span class="keyword">boolean</span> noprompt = message.contains(<span class="string">"--no-prompt"</span>);</span><br><span class="line">    message = message.replace(<span class="string">"--no-prompt"</span>, <span class="string">""</span>);</span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    message = message.trim();</span><br><span class="line">    String command;</span><br><span class="line">    <span class="comment">//用空格分割命令和参数</span></span><br><span class="line">    <span class="keyword">if</span> (message.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = message.indexOf(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            command = message.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">            message = message.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            command = message;</span><br><span class="line">            message = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        command = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过DubboSPI</span></span><br><span class="line">    <span class="keyword">if</span> (command.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (extensionLoader.hasExtension(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (commandEnabled(channel.getUrl(), command)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获得处理结果</span></span><br><span class="line">                    String result = extensionLoader.getExtension(command).telnet(channel, message);</span><br><span class="line">                    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buf.append(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    buf.append(t.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.append(<span class="string">"Command: "</span>);</span><br><span class="line">                buf.append(command);</span><br><span class="line">                buf.append(<span class="string">" disabled"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf.append(<span class="string">"Unsupported command: "</span>);</span><br><span class="line">            buf.append(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        buf.append(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(prompt) &amp;&amp; !noprompt) &#123;</span><br><span class="line">        buf.append(prompt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">举个例子</span><br><span class="line">InvokerTelnetHandler</span><br><span class="line">invoke只能调用本地的服务，若想调用其它服务,则需要telnet provider机器  </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">telnet</span><span class="params">(Channel channel, String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(message)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Please input method name, eg: \r\ninvoke xxxMethod(1234, \"abcd\", &#123;\"prop\" : \"value\"&#125;)\r\n"</span> +</span><br><span class="line">                <span class="string">"invoke XxxService.xxxMethod(1234, \"abcd\", &#123;\"prop\" : \"value\"&#125;)\r\n"</span> +</span><br><span class="line">                <span class="string">"invoke com.xxx.XxxService.xxxMethod(1234, \"abcd\", &#123;\"prop\" : \"value\"&#125;)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String service = (String) channel.getAttribute(ChangeTelnetHandler.SERVICE_KEY);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = message.indexOf(<span class="string">"("</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || !message.endsWith(<span class="string">")"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Invalid parameters, format: service.method(args)"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提取方法名</span></span><br><span class="line">    String method = message.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">    <span class="comment">//获取调用方法参数</span></span><br><span class="line">    String args = message.substring(i + <span class="number">1</span>, message.length() - <span class="number">1</span>).trim();</span><br><span class="line">    i = method.lastIndexOf(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取接口</span></span><br><span class="line">        service = method.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">        <span class="comment">//提取方法</span></span><br><span class="line">        method = method.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将参数json转换为json对象</span></span><br><span class="line">    List&lt;Object&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        list = JSON.parseArray(<span class="string">"["</span> + args + <span class="string">"]"</span>, Object<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Invalid json argument, cause: "</span> + t.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    Method invokeMethod = <span class="keyword">null</span>;</span><br><span class="line">    ProviderModel selectedProvider = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//根据方法描述符</span></span><br><span class="line">    <span class="keyword">if</span> (isInvokedSelectCommand(channel)) &#123;</span><br><span class="line">        selectedProvider = (ProviderModel) channel.getAttribute(INVOKE_METHOD_PROVIDER_KEY);</span><br><span class="line">        invokeMethod = (Method) channel.getAttribute(SelectTelnetHandler.SELECT_METHOD_KEY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取本地的exporters</span></span><br><span class="line">        <span class="keyword">for</span> (ProviderModel provider : ApplicationModel.allProviderModels()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isServiceMatch(service, provider)) &#123;</span><br><span class="line">                selectedProvider = provider;</span><br><span class="line">                List&lt;Method&gt; methodList = findSameSignatureMethod(provider.getAllMethods(), method, list);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methodList)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (methodList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                        invokeMethod = methodList.get(<span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        List&lt;Method&gt; matchMethods = findMatchMethods(methodList, list);</span><br><span class="line">                        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(matchMethods)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (matchMethods.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                                invokeMethod = matchMethods.get(<span class="number">0</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123; <span class="comment">//exist overridden method</span></span><br><span class="line">                                channel.setAttribute(INVOKE_METHOD_PROVIDER_KEY, provider);</span><br><span class="line">                                channel.setAttribute(INVOKE_METHOD_LIST_KEY, matchMethods);</span><br><span class="line">                                channel.setAttribute(INVOKE_MESSAGE_KEY, message);</span><br><span class="line">                                printSelectMessage(buf, matchMethods);</span><br><span class="line">                                <span class="keyword">return</span> buf.toString();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找不到</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(service)) &#123;</span><br><span class="line">        buf.append(<span class="string">"Use default service "</span>).append(service).append(<span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (selectedProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//参数数组</span></span><br><span class="line">                Object[] array = realize(list.toArray(), invokeMethod.getParameterTypes(),</span><br><span class="line">                        invokeMethod.getGenericParameterTypes());</span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                AppResponse result = <span class="keyword">new</span> AppResponse();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object o = invokeMethod.invoke(selectedProvider.getServiceInstance(), array);</span><br><span class="line">                    result.setValue(o);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    result.setException(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">                buf.append(<span class="string">"\r\nresult: "</span>);</span><br><span class="line">                buf.append(JSON.toJSONString(result.recreate()));</span><br><span class="line">                buf.append(<span class="string">"\r\nelapsed: "</span>);</span><br><span class="line">                buf.append(end - start);</span><br><span class="line">                buf.append(<span class="string">" ms."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Failed to invoke method "</span> + invokeMethod.getName() + <span class="string">", cause: "</span> + StringUtils.toString(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            buf.append(<span class="string">"\r\nNo such method "</span>).append(method).append(<span class="string">" in service "</span>).append(service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf.append(<span class="string">"\r\nNo such service "</span>).append(service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Dubbo内部使用的ChannelHandler组件与Netty框架有关。</span><br><span class="line">Dubbo框架内部使用了大量的Hanlder组成,类似命令模式,Handler有编解码、心跳时间戳、方法调用handler等。</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ChannelHandler. (API, Prototype, ThreadSafe)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.dubbo.remoting.Transporter#bind(org.apache.dubbo.common.URL, ChannelHandler)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.apache.dubbo.remoting.Transporter#connect(org.apache.dubbo.common.URL, ChannelHandler)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * channel连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * channel断开连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">disconnected</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *消息发送</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sent</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     *消息接收</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常抛出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">caught</span><span class="params">(Channel channel, Throwable exception)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Netty-的简单使用"><a href="#Netty-的简单使用" class="headerlink" title="Netty 的简单使用"></a>Netty 的简单使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">Channel 接口抽象了底层socket的一些状态属性以及调用方法</span><br><span class="line">NioServerSocketChannel#构造方法</span><br><span class="line">NioServerSocketChannel(</span><br><span class="line">        ChannelFactory factory,</span><br><span class="line">        ChannelPipeline pipeline,</span><br><span class="line">        ChannelSink sink, Boss boss, WorkerPool&lt;NioWorker&gt; workerPool) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(factory, pipeline, sink);</span><br><span class="line">    <span class="keyword">this</span>.boss = boss;</span><br><span class="line">    <span class="keyword">this</span>.workerPool = workerPool;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket = ServerSocketChannel.open();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                <span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        socket.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">"Failed to close a partially initialized socket."</span>, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    config = <span class="keyword">new</span> DefaultServerSocketChannelConfig(socket.socket());</span><br><span class="line"></span><br><span class="line">    fireChannelOpen(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">ChannelHandler用于处理Channel对应的事件  sent,received,connected</span><br><span class="line">ChannelInboundHandler</span><br><span class="line">回调方法                 触发时机                        client         server</span><br><span class="line">channelRegistered       当前channel注册到EventLoop中     <span class="keyword">true</span>           <span class="keyword">true</span></span><br><span class="line">channelUnregistered     当前channel从EventLoop中取消注册 <span class="keyword">true</span>           <span class="keyword">true</span></span><br><span class="line">channelActive           当前channel被激活时候            <span class="keyword">true</span>           <span class="keyword">true</span></span><br><span class="line">channelInactive         当前channel不活跃的时候          <span class="keyword">true</span>           <span class="keyword">true</span></span><br><span class="line">channelRead	            当前channel从远端读取到数据      <span class="keyword">true</span>           <span class="keyword">true</span></span><br><span class="line">channelReadComplete	    channel read消费完读取的数据的时候被触发   <span class="keyword">true</span>  <span class="keyword">true</span></span><br><span class="line">当事件方法处理完后,通过ChannelHandlerContext调用对应fireXXX方法传递给下一个ChannelHandler(责任链模式).</span><br><span class="line">ChannelOutboundHandler</span><br><span class="line">回调方法	    触发时机	               client      server</span><br><span class="line">bind        bind操作执行前触发      <span class="keyword">false</span>       <span class="keyword">true</span></span><br><span class="line">connect     connect 操作执行前触发   <span class="keyword">true</span>       <span class="keyword">false</span></span><br><span class="line">disconnect  disconnect 操作执行前触发  <span class="keyword">true</span>     <span class="keyword">false</span></span><br><span class="line">close       close操作执行前触发      <span class="keyword">false</span>      <span class="keyword">true</span></span><br><span class="line">deregister  deregister操作执行前触发</span><br><span class="line">read        read操作执行前触发       <span class="keyword">true</span>       <span class="keyword">true</span></span><br><span class="line">write       write操作执行前触发      <span class="keyword">true</span>       <span class="keyword">true</span></span><br><span class="line">flush       flush操作执行前触发      <span class="keyword">true</span>       <span class="keyword">true</span> </span><br><span class="line">例如:</span><br><span class="line">AbstractChannel#write</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">write</span><span class="params">(Object msg, ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pipeline.write(msg, promise);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ChannelHandlerContext</span><br><span class="line">当ChannelHandler加入到ChannelPipeline中,会创建一个对应的ChannelHandlerContext,并且绑定.</span><br><span class="line">ChannelPipeline维护的是ChannelHandlerContext与ChannelHandler的关系.</span><br><span class="line">DefaultChannelPipeline源码</span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext head;</span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext tail;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/11/dubbo/netty-channel.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelHandler与ChannelHandlerContext一一对应</span><br></pre></td></tr></table></figure>
<h4 id="NIO-reactor模型"><a href="#NIO-reactor模型" class="headerlink" title="NIO reactor模型"></a>NIO reactor模型</h4><p><img src="/2020/07/11/dubbo/netty-nio.png" alt></p>
<h4 id="Dubbo的核心handler和线程模型"><a href="#Dubbo的核心handler和线程模型" class="headerlink" title="Dubbo的核心handler和线程模型"></a>Dubbo的核心handler和线程模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Dubbo中ChannelHandler的5种状态</span><br><span class="line">connected           Channel已经被创建</span><br><span class="line">disconnected        Channel已经被断开</span><br><span class="line">sent                消息被发送</span><br><span class="line">received            消息被接收</span><br><span class="line">caught              捕获到异常</span><br></pre></td></tr></table></figure>
<h4 id="Dubbo常见的Handler类型"><a href="#Dubbo常见的Handler类型" class="headerlink" title="Dubbo常见的Handler类型"></a>Dubbo常见的Handler类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ExchangeHandlerAdapter                          查找服务方法并调用</span><br><span class="line">HeaderExchangeHandler                           封装处理Request&#x2F;Response和Telnet调用能力</span><br><span class="line">DecodeHandler                                   在dubbo线程池中做解码</span><br><span class="line">ChannelHandlerDispatcher                        封装多Handler广播调用</span><br><span class="line">AllChannelHandler                               支持Dubbo线程池中调用业务方法</span><br><span class="line">HeartbeatHandler                                支持心跳处理</span><br><span class="line">MultiMessageHandler                             支持流中多消息报文批处理</span><br><span class="line">ConnectionOrderedChannelHandler                 单独线程池处理TCP的连接和断开</span><br><span class="line">MessageOnlyChannelHandler                       仅在线程池处理接收报文,其它事件在I&#x2F;O线程池处理</span><br><span class="line">WrappedChannelHandler                           基于内存key-value存储封装和共享线程池能力,比如记录线程池等</span><br><span class="line">NettyServerHandler                              封装Netty服务端事件,处理连接、断开、读取、写入和异常</span><br><span class="line">NettyClientHandler                              封装Netty客户端事件,处理连接、断开、读取、写入和异常</span><br></pre></td></tr></table></figure>
<h4 id="ChannelHandler的调用逻辑"><a href="#ChannelHandler的调用逻辑" class="headerlink" title="ChannelHandler的调用逻辑"></a>ChannelHandler的调用逻辑</h4><p><img src="/2020/07/11/dubbo/channelHandler.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Channel ---&gt; ChannelPipeline(一系列的Handler)</span><br><span class="line">入站事件触发,比如连接或数据读取,会从ChannelPipeline头部开始一直传播到ChannelPipeLine的尾端.</span><br><span class="line">出站事件触发,会从ChannelPipeline右端向左端传播.</span><br><span class="line">入站传播只对实现了ChannelInboundHandler接口的ChannelHandler有效</span><br><span class="line">出站传播只对实现了ChannelOutboundHandler接口的ChannelHandler有效</span><br><span class="line">Dubbo通过装饰者模式层层包装handler,不需要将每个handler都追加到PipeLine中.</span><br><span class="line">在NettyServer和NettyClient最多有3个handler,分别是编码,解码和NettyServerHandler或NettyClientHandler</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NettyServer#doOpen</span><br><span class="line">bootstrap &#x3D; new ServerBootstrap(channelFactory);</span><br><span class="line">final NettyHandler nettyHandler &#x3D; new NettyHandler(getUrl(), this);</span><br><span class="line">channels &#x3D; nettyHandler.getChannels();</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-365</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-379</span><br><span class="line">&#x2F;&#x2F; final Timer timer &#x3D; new HashedWheelTimer(new NamedThreadFactory(&quot;NettyIdleTimer&quot;, true));</span><br><span class="line">bootstrap.setOption(&quot;child.tcpNoDelay&quot;, true);</span><br><span class="line">bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ChannelPipeline getPipeline() &#123;</span><br><span class="line">        NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);</span><br><span class="line">        ChannelPipeline pipeline &#x3D; Channels.pipeline();</span><br><span class="line">        &#x2F;*int idleTimeout &#x3D; getIdleTimeout();</span><br><span class="line">        if (idleTimeout &gt; 10000) &#123;</span><br><span class="line">            pipeline.addLast(&quot;timer&quot;, new IdleStateHandler(timer, idleTimeout &#x2F; 1000, 0, 0));</span><br><span class="line">        &#125;*&#x2F;</span><br><span class="line">        pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());</span><br><span class="line">        pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());</span><br><span class="line">        pipeline.addLast(&quot;handler&quot;, nettyHandler);</span><br><span class="line">        return pipeline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; bind</span><br><span class="line">channel &#x3D; bootstrap.bind(getBindAddress());</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">DubboProtocol的内部类继承ExchangeHandlerAdapter,完成服务提供方Invoker实例的查找及服务的真实调用</span><br><span class="line">private ExchangeHandler requestHandler &#x3D; new ExchangeHandlerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public CompletableFuture&lt;Object&gt; reply(ExchangeChannel channel, Object message) throws RemotingException &#123;</span><br><span class="line"></span><br><span class="line">        if (!(message instanceof Invocation)) &#123;</span><br><span class="line">            throw new RemotingException(channel, &quot;Unsupported request: &quot;</span><br><span class="line">                    + (message &#x3D;&#x3D; null ? null : (message.getClass().getName() + &quot;: &quot; + message))</span><br><span class="line">                    + &quot;, channel: consumer: &quot; + channel.getRemoteAddress() + &quot; --&gt; provider: &quot; + channel.getLocalAddress());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Invocation inv &#x3D; (Invocation) message;</span><br><span class="line">        &#x2F;&#x2F;查找Invocation关联的Invoker 根据服务暴露协议的端口,接口,分组,版本</span><br><span class="line">        Invoker&lt;?&gt; invoker &#x3D; getInvoker(channel, inv);</span><br><span class="line">        &#x2F;&#x2F; need to consider backward-compatibility if it&#39;s a callback</span><br><span class="line">        if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">            String methodsStr &#x3D; invoker.getUrl().getParameters().get(&quot;methods&quot;);</span><br><span class="line">            boolean hasMethod &#x3D; false;</span><br><span class="line">            if (methodsStr &#x3D;&#x3D; null || !methodsStr.contains(&quot;,&quot;)) &#123;</span><br><span class="line">                hasMethod &#x3D; inv.getMethodName().equals(methodsStr);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                String[] methods &#x3D; methodsStr.split(&quot;,&quot;);</span><br><span class="line">                for (String method : methods) &#123;</span><br><span class="line">                    if (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                        hasMethod &#x3D; true;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!hasMethod) &#123;</span><br><span class="line">                logger.warn(new IllegalStateException(&quot;The methodName &quot; + inv.getMethodName()</span><br><span class="line">                        + &quot; not found in callback service interface ,invoke will be ignored.&quot;</span><br><span class="line">                        + &quot; please update the api interface. url is:&quot;</span><br><span class="line">                        + invoker.getUrl()) + &quot; ,invocation is :&quot; + inv);</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">        &#x2F;&#x2F;调用业务方具体方法</span><br><span class="line">        Result result &#x3D; invoker.invoke(inv);</span><br><span class="line">        return result.completionFuture().thenApply(Function.identity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void received(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">        if (message instanceof Invocation) &#123;</span><br><span class="line">            reply((ExchangeChannel) channel, message);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            super.received(channel, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void connected(Channel channel) throws RemotingException &#123;</span><br><span class="line">        invoke(channel, ON_CONNECT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disconnected(Channel channel) throws RemotingException &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(&quot;disconnected from &quot; + channel.getRemoteAddress() + &quot;,url:&quot; + channel.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        invoke(channel, ON_DISCONNECT_KEY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void invoke(Channel channel, String methodKey) &#123;</span><br><span class="line">        Invocation invocation &#x3D; createInvocation(channel, channel.getUrl(), methodKey);</span><br><span class="line">        if (invocation !&#x3D; null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                received(channel, invocation);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.warn(&quot;Failed to invoke event method &quot; + invocation.getMethodName() + &quot;(), cause: &quot; + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Invocation createInvocation(Channel channel, URL url, String methodKey) &#123;</span><br><span class="line">        String method &#x3D; url.getParameter(methodKey);</span><br><span class="line">        if (method &#x3D;&#x3D; null || method.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RpcInvocation invocation &#x3D; new RpcInvocation(method, new Class&lt;?&gt;[0], new Object[0]);</span><br><span class="line">        invocation.setAttachment(PATH_KEY, url.getPath());</span><br><span class="line">        invocation.setAttachment(GROUP_KEY, url.getParameter(GROUP_KEY));</span><br><span class="line">        invocation.setAttachment(INTERFACE_KEY, url.getParameter(INTERFACE_KEY));</span><br><span class="line">        invocation.setAttachment(VERSION_KEY, url.getParameter(VERSION_KEY));</span><br><span class="line">        if (url.getParameter(STUB_EVENT_KEY, false)) &#123;</span><br><span class="line">            invocation.setAttachment(STUB_EVENT_KEY, Boolean.TRUE.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return invocation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">DubboProtocol#createServer将暴露的服务url与requestHandler,</span><br><span class="line">private ExchangeServer createServer(URL url) &#123;</span><br><span class="line">    url &#x3D; URLBuilder.from(url)</span><br><span class="line">            &#x2F;&#x2F; send readonly event when server closes, it&#39;s enabled by default</span><br><span class="line">            .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class="line">            &#x2F;&#x2F; enable heartbeat by default</span><br><span class="line">            .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))</span><br><span class="line">            .addParameter(CODEC_KEY, DubboCodec.NAME)</span><br><span class="line">            .build();</span><br><span class="line">    String str &#x3D; url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">    if (str !&#x3D; null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">        throw new RpcException(&quot;Unsupported server type: &quot; + str + &quot;, url: &quot; + url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;在这里绑定的</span><br><span class="line">        server &#x3D; Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; catch (RemotingException e) &#123;</span><br><span class="line">        throw new RpcException(&quot;Fail to start server(url: &quot; + url + &quot;) &quot; + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str &#x3D; url.getParameter(CLIENT_KEY);</span><br><span class="line">    if (str !&#x3D; null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">        Set&lt;String&gt; supportedTypes &#x3D; ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">        if (!supportedTypes.contains(str)) &#123;</span><br><span class="line">            throw new RpcException(&quot;Unsupported client type: &quot; + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dubbo请求响应Handler"><a href="#Dubbo请求响应Handler" class="headerlink" title="Dubbo请求响应Handler"></a>Dubbo请求响应Handler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在Dubbo框架内部,所有的远程方法调用都会被抽象成Request&#x2F;Response,每次调用(一次会话)都会创建一个Request,如果是方法调用则会返回一个Response对象.</span><br><span class="line">HeaderExchangeHandler负责的四件事</span><br><span class="line">1.更新发送和读取请求时间戳.</span><br><span class="line">2.判断请求格式或编解码是否有错,并响应客户端失败的具体原因.</span><br><span class="line">3.处理Request请求和Response正常响应.</span><br><span class="line">4.支持Telnet调用.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Object message)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="comment">//更新事件时间戳</span></span><br><span class="line">    channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());</span><br><span class="line">    <span class="keyword">final</span> ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">            <span class="comment">// handle request.</span></span><br><span class="line">            Request request = (Request) message;</span><br><span class="line">            <span class="keyword">if</span> (request.isEvent()) &#123;</span><br><span class="line">                <span class="comment">//处理事件请求 readonly事件</span></span><br><span class="line">                handlerEvent(channel, request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.isTwoWay()) &#123;</span><br><span class="line">                    <span class="comment">//处理有返回的方法调用</span></span><br><span class="line">                    handleRequest(exchangeChannel, request);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//处理没有返回的方法调用</span></span><br><span class="line">                    handler.received(exchangeChannel, request.getData());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> Response) &#123;</span><br><span class="line">            <span class="comment">//接收响应</span></span><br><span class="line">            handleResponse(channel, (Response) message);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="comment">//客户端不支持Telnet调用</span></span><br><span class="line">            <span class="keyword">if</span> (isClientSide(channel)) &#123;</span><br><span class="line">                Exception e = <span class="keyword">new</span> Exception(<span class="string">"Dubbo client can not supported string message: "</span> + message + <span class="string">" in channel: "</span> + channel + <span class="string">", url: "</span> + channel.getUrl());</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//Telnet调用</span></span><br><span class="line">                String echo = handler.telnet(channel, (String) message);</span><br><span class="line">                <span class="keyword">if</span> (echo != <span class="keyword">null</span> &amp;&amp; echo.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    channel.send(echo);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handler.received(exchangeChannel, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">HeaderExchangeHandler#handleRequest</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(<span class="keyword">final</span> ExchangeChannel channel, Request req)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    Response res = <span class="keyword">new</span> Response(req.getId(), req.getVersion());</span><br><span class="line">    <span class="keyword">if</span> (req.isBroken()) &#123; <span class="comment">//出现错误</span></span><br><span class="line">        Object data = req.getData();</span><br><span class="line"></span><br><span class="line">        String msg;</span><br><span class="line">        <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">            msg = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">            msg = StringUtils.toString((Throwable) data);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            msg = data.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        res.setErrorMessage(<span class="string">"Fail to decode request due to: "</span> + msg);</span><br><span class="line">        res.setStatus(Response.BAD_REQUEST);</span><br><span class="line"></span><br><span class="line">        channel.send(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find handler by message class.</span></span><br><span class="line">    Object msg = req.getData();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CompletionStage&lt;Object&gt; future = handler.reply(channel, msg);</span><br><span class="line">        future.whenComplete((appResult, t) -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    res.setStatus(Response.OK);</span><br><span class="line">                    <span class="comment">//设置结果</span></span><br><span class="line">                    res.setResult(appResult);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//有异常</span></span><br><span class="line">                    res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">                    res.setErrorMessage(StringUtils.toString(t));</span><br><span class="line">                &#125;</span><br><span class="line">                channel.send(res);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Send result to consumer failed, channel is "</span> + channel + <span class="string">", msg is "</span> + e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// HeaderExchangeChannel.removeChannelIfDisconnected(channel);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        res.setStatus(Response.SERVICE_ERROR);</span><br><span class="line">        res.setErrorMessage(StringUtils.toString(e));</span><br><span class="line">        channel.send(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HeaderExchangeHandler#handleResponse</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleResponse</span><span class="params">(Channel channel, Response response)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (response != <span class="keyword">null</span> &amp;&amp; !response.isHeartbeat()) &#123;</span><br><span class="line">        <span class="comment">//唤醒阻塞的线程并通知结果</span></span><br><span class="line">        DefaultFuture.received(channel, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Dubbo-心跳handler"><a href="#Dubbo-心跳handler" class="headerlink" title="Dubbo 心跳handler"></a>Dubbo 心跳handler</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Dubbo默认的客户端和服务器都会发送心跳报文,用来保证TCP长连接状态(续约).</span><br><span class="line">在客户端和服务端,Dubbo内部会开启一个线程循环扫描并检测连接是否超时,在服务端如果发现超时则关闭客户端连接,在客户端发现超时则会重新创建连接.</span><br><span class="line">默认的心跳检测时间是60秒,具体应用可以通过heartbeat进行设置.</span><br><span class="line">新版源码都是续约处理,未判断客户端还是服务器</span><br><span class="line">HeartBeatTimerTask#run</span><br><span class="line">public void run(Timeout timeout) throws Exception &#123;</span><br><span class="line">    Collection&lt;Channel&gt; c &#x3D; channelProvider.getChannels();</span><br><span class="line">    for (Channel channel : c) &#123;</span><br><span class="line">        if (channel.isClosed()) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        doTask(channel);</span><br><span class="line">    &#125;</span><br><span class="line">    reput(timeout, tick);</span><br><span class="line">&#125;</span><br><span class="line">HeartBeatTimerTask#doTask</span><br><span class="line">protected void doTask(Channel channel) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        Long lastRead &#x3D; lastRead(channel);</span><br><span class="line">        Long lastWrite &#x3D; lastWrite(channel);</span><br><span class="line">        if ((lastRead !&#x3D; null &amp;&amp; now() - lastRead &gt; heartbeat)</span><br><span class="line">                || (lastWrite !&#x3D; null &amp;&amp; now() - lastWrite &gt; heartbeat)) &#123;</span><br><span class="line">            &#x2F;&#x2F;超时</span><br><span class="line">            Request req &#x3D; new Request();</span><br><span class="line">            req.setVersion(Version.getProtocolVersion());</span><br><span class="line">            req.setTwoWay(true);</span><br><span class="line">            req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">            &#x2F;&#x2F;续约</span><br><span class="line">            channel.send(req);</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Send heartbeat to remote channel &quot; + channel.getRemoteAddress()</span><br><span class="line">                        + &quot;, cause: The channel has no data-transmission exceeds a heartbeat period: &quot;</span><br><span class="line">                        + heartbeat + &quot;ms&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.warn(&quot;Exception when heartbeat to remote channel &quot; + channel.getRemoteAddress(), t);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第七章-Dubbo集群容错"><a href="#第七章-Dubbo集群容错" class="headerlink" title="第七章 Dubbo集群容错"></a>第七章 Dubbo集群容错</h2><h3 id="Cluster层概述"><a href="#Cluster层概述" class="headerlink" title="Cluster层概述"></a>Cluster层概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在微服务环境中,为了保证服务的高可用,很少会有单点服务出现,服务通常是以集群的形式出现.</span><br><span class="line">当某个服务出现异常时候,如网络抖动、服务暂且不可用需要自动容错、或者只想本地测试、服务降级、需要Mock返回结果,就需要使用集群容错机制.</span><br></pre></td></tr></table></figure>
<h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><h4 id="Dubbo-九种容错机制"><a href="#Dubbo-九种容错机制" class="headerlink" title="Dubbo 九种容错机制"></a>Dubbo 九种容错机制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FailOver            Dubbo默认的容错机制.(失败重试+负载均衡)</span><br><span class="line">FailFast            失败不重试(多用于幂等接口的调用)+负载均衡</span><br><span class="line">FailSafe            忽略异常+负载均衡</span><br><span class="line">Failback            失败进队列+重试+负载均衡</span><br><span class="line">Forking             并行执行,配置forks&#x3D;n来确定最大并行调用的服务数量,只需要一个返回即可.(通常用于实时性极高的调用).</span><br><span class="line">Boardcast           通常用于更新,广播所有的节点,一个节点报错则报错.</span><br><span class="line">Mock                广播调用所有可用的服务,任意一个节点报错则报错</span><br><span class="line">Available           迭代,找到一个可用的节点就使用</span><br><span class="line">Mergeable           合并多个节点的结果</span><br><span class="line">&lt;dubbo:reference interface&#x3D;&quot;com.xxx.MenuService&quot; group&#x3D;&quot;*&quot;&gt;</span><br><span class="line">    &lt;dubbo:method name&#x3D;&quot;getMenuItems&quot; merger&#x3D;&quot;.addAll&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:reference&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">FailOverCluster</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailOverCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt;Invoker&lt;T&gt;join(Directory directory) <span class="keyword">throws</span> RpcException&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FailoverClusterInvoker&lt;T&gt;(directory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">FailoverClusterInvoker#doInvoke</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"rawtypes"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">//已经路由过的invokers</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">    checkInvokers(copyInvokers, invocation);</span><br><span class="line">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    <span class="comment">//retry</span></span><br><span class="line">    <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// retry loop.</span></span><br><span class="line">    RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">    Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class="line">        <span class="comment">//<span class="doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            checkWhetherDestroyed();</span><br><span class="line">            copyInvokers = list(invocation);</span><br><span class="line">            <span class="comment">// check again</span></span><br><span class="line">            checkInvokers(copyInvokers, invocation);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排除invoked的内容</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line">        invoked.add(invoker);</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Although retry the method "</span> + methodName</span><br><span class="line">                        + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">                        + <span class="string">" was successful by the provider "</span> + invoker.getUrl().getAddress()</span><br><span class="line">                        + <span class="string">", but there have been failed providers "</span> + providers</span><br><span class="line">                        + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">                        + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">                        + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost()</span><br><span class="line">                        + <span class="string">" using the dubbo version "</span> + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">                        + le.getMessage(), le);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            le = e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            providers.add(invoker.getUrl().getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//全部失败</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le.getCode(), <span class="string">"Failed to invoke the method "</span></span><br><span class="line">            + methodName + <span class="string">" in the service "</span> + getInterface().getName()</span><br><span class="line">            + <span class="string">". Tried "</span> + len + <span class="string">" times of the providers "</span> + providers</span><br><span class="line">            + <span class="string">" ("</span> + providers.size() + <span class="string">"/"</span> + copyInvokers.size()</span><br><span class="line">            + <span class="string">") from the registry "</span> + directory.getUrl().getAddress()</span><br><span class="line">            + <span class="string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="string">" using the dubbo version "</span></span><br><span class="line">            + Version.getVersion() + <span class="string">". Last error is: "</span></span><br><span class="line">            + le.getMessage(), le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">各种容错策略的实现方式</span><br><span class="line">1.FailOver</span><br><span class="line">  见上方代码</span><br><span class="line">2.FailFast</span><br><span class="line">  try()&#123;invoker.invoke();&#125;catch(Exception e)&#123;throw new RpcException(e);&#125;</span><br><span class="line">3.FailSafe</span><br><span class="line">  try()&#123;invoker.invoke();&#125;catche(Exception e)&#123;log.error(&quot;exception: %s &quot;,e.toString());&#125;</span><br><span class="line">4.Failback</span><br><span class="line">  ConcurrentHashMap----&gt; &lt;Invocation,AbstractClusterInvoker&gt;保存所有的失败请求,每隔5秒就会对这些请求重试.</span><br><span class="line">5.Forking</span><br><span class="line">  CachedThreadPool+LinkedBlockingQueue  ---&gt; 当有一个thread获取结果后将结果放入到queue中,当从queue中获取到结果(即第一个)成过.</span><br></pre></td></tr></table></figure>
<h3 id="Directory的实现"><a href="#Directory的实现" class="headerlink" title="Directory的实现"></a>Directory的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">Directory也有多种实现子类,既可以提供静态的Invoker列表(StaticDirectory),也可以提供动态的Invoker列表(RegistryDirectory).</span><br><span class="line">静态列表是用户自己设置的Invoker列表,动态列表是抓取服务注册中心的Invoker列表.</span><br><span class="line">                                        ----&gt;  RegistryDirectory</span><br><span class="line">Directory   ----&gt;  AbstractDirectory</span><br><span class="line">                                        ----&gt;  StaticDirectory</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDirectory</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Directory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// logger</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(AbstractDirectory<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroyed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> URL consumerUrl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> RouterChain&lt;T&gt; routerChain;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(url, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url, RouterChain&lt;T&gt; routerChain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(url, url, routerChain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDirectory</span><span class="params">(URL url, URL consumerUrl, RouterChain&lt;T&gt; routerChain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.getProtocol().equals(REGISTRY_PROTOCOL)) &#123;</span><br><span class="line">            Map&lt;String, String&gt; queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">            <span class="keyword">this</span>.url = url.addParameters(queryMap).removeParameter(MONITOR_KEY);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.consumerUrl = consumerUrl;</span><br><span class="line">        setRouterChain(routerChain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Directory already destroyed .url: "</span> + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doList(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterChain&lt;T&gt; <span class="title">getRouterChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> routerChain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRouterChain</span><span class="params">(RouterChain&lt;T&gt; routerChain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.routerChain = routerChain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addRouters</span><span class="params">(List&lt;Router&gt; routers)</span> </span>&#123;</span><br><span class="line">        routers = routers == <span class="keyword">null</span> ? Collections.emptyList() : routers;</span><br><span class="line">        routerChain.addRouters(routers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> URL <span class="title">getConsumerUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> consumerUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConsumerUrl</span><span class="params">(URL consumerUrl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consumerUrl = consumerUrl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDestroyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> destroyed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        destroyed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取所有的invoker列表,迭代所有的router,对invoker进行过滤,返回过滤后的invoker列表</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) <span class="keyword">throws</span> RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">RegistryDirectory的实现</span><br><span class="line"><span class="number">1</span>.订阅与动态更新(dubbo-admin)</span><br><span class="line">subscribe   ---&gt;registry.subscribe---&gt;   notify   ---&gt;   refreshInvoker</span><br><span class="line">RegistryDirectory#notify</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据category对url进行过滤</span></span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream()</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .filter(<span class="keyword">this</span>::isValidCategory)</span><br><span class="line">            .filter(<span class="keyword">this</span>::isNotCompatibleFor26x)</span><br><span class="line">            .collect(Collectors.groupingBy(url -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isConfigurator(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> CONFIGURATORS_CATEGORY;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isRoute(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ROUTERS_CATEGORY;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isProvider(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> PROVIDERS_CATEGORY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">    List&lt;URL&gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="keyword">this</span>.configurators = Configurator.toConfigurators(configuratorURLs).orElse(<span class="keyword">this</span>.configurators);</span><br><span class="line"></span><br><span class="line">    List&lt;URL&gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    toRouters(routerURLs).ifPresent(<span class="keyword">this</span>::addRouters);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// providers</span></span><br><span class="line">    List&lt;URL&gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    refreshOverrideAndInvoker(providerURLs);</span><br><span class="line">&#125;</span><br><span class="line">notify ----&gt; providers的url ----&gt; toInvokers ----&gt;Map&lt;String,List&lt;Invoker&lt;T&gt;&gt;&gt; newUrlInvokerMap </span><br><span class="line">doList ----&gt; newUrlInvokerMap ----&gt;routerChain.route ----&gt;List&lt;Invoker&lt;T&gt;&gt;invokers</span><br><span class="line"></span><br><span class="line">用三个list保存更新的Invoker URL,路由配置URL(Router),配置URL(Configurer)</span><br><span class="line"></span><br><span class="line">            router                 遍历所有router类型的url,通过router工厂把每个url包装成路由规则,最后更新本地的路由信息.</span><br><span class="line">category    configurator           管理员可以在dubbo-admin动态配置功能上修改生产者的参数,这些参数会保存在配置中心的configurators类目下.notify监听到URL配置参数的变化,会解析并更新本地的Configurator配置</span><br><span class="line">            Invoker(provider)      empty协议会清空本地的invokers列表,如果url不为空,则将新url与老url一同更新     </span><br><span class="line">            </span><br><span class="line">路由时condition协议</span><br><span class="line">动态配置</span><br><span class="line">zookeeper  path=&gt;/dubbo/service/configurators/ip:port</span><br><span class="line">value=&gt;</span><br><span class="line">    协议       <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>对所有服务生效   服务           类别                 持久化        覆盖规则        应用              超时时间</span><br><span class="line">    override:<span class="comment">//10.20.155.1/com.vicyor.DemoService?category=configurators&amp;dynamic=false&amp;enabled=true&amp;application=test&amp;timeout=1000</span></span><br></pre></td></tr></table></figure>
<h3 id="路由的实现"><a href="#路由的实现" class="headerlink" title="路由的实现"></a>路由的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">路由分为条件路由,文件路由,脚本路由.</span><br></pre></td></tr></table></figure>
<h4 id="条件路由"><a href="#条件路由" class="headerlink" title="条件路由"></a>条件路由</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">参数规则</span><br><span class="line">url   --&gt;  &quot;condition:&#x2F;&#x2F;0.0.0.0&#x2F;com.vicyor.HelloService?category&#x3D;router&amp;dynamic&#x3D;false&amp;rule&#x3D;&quot; + URL.encode(&quot;host&#x3D;10.20.153.10&#x3D;&gt;host&#x3D;10.20.153.11&quot;)</span><br><span class="line">参数</span><br><span class="line">condition:&#x2F;&#x2F;     路由规则为条件路由</span><br><span class="line">dynamic          持久化类型数据</span><br><span class="line">enabled           覆盖</span><br><span class="line">force            强制是指若路由结果为空,则为空,不强制是指路由结果为空,就将这个路由策略失效</span><br><span class="line">runtime          是否在每次调用时都执行路由规则</span><br><span class="line">priority         路由规则的优先级</span><br><span class="line">rule             路由规则</span><br><span class="line"> 路由规则:     消费者 &#x3D;&gt; 提供方</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">条件路由的实现</span><br><span class="line">ConditionRouter解析的逻辑</span><br><span class="line">1.根据url的rule获取规则. 规则用 &#x3D;&gt; 分成两段,前端是whenRule(针对消费者),后端是thenRule(针对提供者)</span><br><span class="line">2.whenRule和thenRule以 &#x3D;,&amp;,!&#x3D;,&#39;,&#39;分割,会被转换成MatchPair</span><br><span class="line">3.whenRule ---&gt;Invocation</span><br><span class="line">  thenRule ---&gt;List&lt;Invoker&gt;invokers</span><br></pre></td></tr></table></figure>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><h4 id="公用的特性"><a href="#公用的特性" class="headerlink" title="公用的特性"></a>公用的特性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.粘滞连接</span><br><span class="line">  &lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; sticky&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">  粘滞连接用于有状态服务,尽可能让客户端总是向同一提供者发起调用.</span><br><span class="line">2.可用检测</span><br><span class="line">  若url含有cluster.availablecheck&#x3D;false,则不检测远程服务是否可用,并直接调用.</span><br><span class="line">3.避免重复调用</span><br><span class="line">  不调用已经调用过的节点.若不存在剩下的节点,说明全都调用过一次,那就从已调用的节点中选</span><br></pre></td></tr></table></figure>
<h4 id="常用的几种负载均衡算法"><a href="#常用的几种负载均衡算法" class="headerlink" title="常用的几种负载均衡算法"></a>常用的几种负载均衡算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RandomLoadBalance                                          根据权重随机选择</span><br><span class="line">RoundRobinLoadBalance                                      轮询</span><br><span class="line">LeastActiveLoadBalance                                     最少活跃数调用</span><br><span class="line">ConsistentHashLoadBalance                                  一致性hash算法,默认对第一个参数进行hash,默认使用160份虚拟节点</span><br><span class="line">                                                           &lt;dubbo:parameter key&#x3D;&quot;hash.arguments&quot; value&#x3D;&quot;0&quot;&#x2F;&gt;</span><br><span class="line">                                                           &lt;dubbo:parameter key&#x3D;&quot;hash.nodes&quot; value&#x3D;&quot;320&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Merger的实现"><a href="#Merger的实现" class="headerlink" title="Merger的实现"></a>Merger的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MergerCluster是cluster的一种实现,通过MergerFactory寻找Merger,将返回类型合并.</span><br><span class="line">MapMerger</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;?,?&gt;merge(Map&lt;?,?&gt;...items)&#123;</span><br><span class="line">    <span class="keyword">if</span>(items.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Object,Object&gt;result=<span class="keyword">new</span> HashMap&lt;Object,Object&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Map&lt;?,?&gt;item:items)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            result.putAll(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MergeableClusterInvoker机制</span><br><span class="line">MergeableCluster#join ---&gt; MergeableClusterInvoker</span><br><span class="line">MergeableCLusterInvoker#invoke  ---&gt;MergerFactory工厂获取不同Merger接口实现,并将其合并.</span><br><span class="line"><span class="number">1</span>.前置准备:通过directory获取所有的Invoker列表</span><br><span class="line"><span class="number">2</span>.合并器检查:判断某个方法是否有合并器,如果没有，就找到第一个Invoker直接调用并返回结果</span><br><span class="line"><span class="number">3</span>.获取接口的返回类型.根据接口的返回类型查找不同的合并器.</span><br><span class="line"><span class="number">4</span>.并行调用.把Invoker封装成一个个Callable对象,放到线程池中执行,保存线程池中返回的future对象到hashmap中.</span><br><span class="line"><span class="number">5</span>.等待future对象的返回结果.</span><br><span class="line"><span class="number">6</span>.合并结果集,通过配置方法. 如 merger=<span class="string">".addAll"</span>,并且方法的返回类型是set,就会调用set.addAll合并结果.</span><br></pre></td></tr></table></figure>
<p>##未完待续</p>

    </div>

    
    
    
		<div>
			
				<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

			
		</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/dubbo/" rel="tag"># dubbo</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/11/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/11/apollo/" rel="next" title="apollo">
      apollo <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-Dubbo—高性能RPC通信框架"><span class="nav-number">1.</span> <span class="nav-text">第一章 Dubbo—高性能RPC通信框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#应用架构演变"><span class="nav-number">1.1.</span> <span class="nav-text">应用架构演变</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单体应用"><span class="nav-number">1.1.1.</span> <span class="nav-text">单体应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分布式应用"><span class="nav-number">1.1.2.</span> <span class="nav-text">分布式应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dubbo简介"><span class="nav-number">1.2.</span> <span class="nav-text">dubbo简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo的总体分层"><span class="nav-number">1.2.1.</span> <span class="nav-text">dubbo的总体分层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo的整体调用过程"><span class="nav-number">1.2.2.</span> <span class="nav-text">dubbo的整体调用过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-开发第一款Dubbo应用程序"><span class="nav-number">2.</span> <span class="nav-text">第二章 开发第一款Dubbo应用程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于xml配置"><span class="nav-number">2.1.</span> <span class="nav-text">基于xml配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于注解配置"><span class="nav-number">2.2.</span> <span class="nav-text">基于注解配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#硬编码方式-ServiceConfig和ReferenceConfig"><span class="nav-number">2.3.</span> <span class="nav-text">硬编码方式 ServiceConfig和ReferenceConfig</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-Dubbo注册中心"><span class="nav-number">3.</span> <span class="nav-text">第三章 Dubbo注册中心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注册中心概述"><span class="nav-number">3.1.</span> <span class="nav-text">注册中心概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册中心工作流程"><span class="nav-number">3.2.</span> <span class="nav-text">注册中心工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Zookeeper注册中心原理概述"><span class="nav-number">3.3.</span> <span class="nav-text">Zookeeper注册中心原理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">3.3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发布订阅"><span class="nav-number">3.3.2.</span> <span class="nav-text">发布订阅</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis注册中心原理概述"><span class="nav-number">3.4.</span> <span class="nav-text">Redis注册中心原理概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构-1"><span class="nav-number">3.4.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发布订阅-1"><span class="nav-number">3.4.2.</span> <span class="nav-text">发布订阅</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存的加载"><span class="nav-number">3.5.</span> <span class="nav-text">缓存的加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注册重试机制"><span class="nav-number">3.6.</span> <span class="nav-text">注册重试机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计模式"><span class="nav-number">3.7.</span> <span class="nav-text">设计模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-Dubbo扩展点加载机制"><span class="nav-number">4.</span> <span class="nav-text">第四章 Dubbo扩展点加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java的SPI机制"><span class="nav-number">4.1.</span> <span class="nav-text">Java的SPI机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dubbo的spi机制"><span class="nav-number">4.2.</span> <span class="nav-text">dubbo的spi机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo-spi"><span class="nav-number">4.2.1.</span> <span class="nav-text">dubbo spi</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo-spi扩展点缓存"><span class="nav-number">4.2.2.</span> <span class="nav-text">dubbo spi扩展点缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo-spi扩展类四大特性"><span class="nav-number">4.2.3.</span> <span class="nav-text">dubbo spi扩展类四大特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dubbospi的实现"><span class="nav-number">4.3.</span> <span class="nav-text">dubbospi的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本的扩展加载方法"><span class="nav-number">4.3.1.</span> <span class="nav-text">基本的扩展加载方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自适应扩展类"><span class="nav-number">4.3.2.</span> <span class="nav-text">自适应扩展类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#激活类加载逻辑"><span class="nav-number">4.3.3.</span> <span class="nav-text">激活类加载逻辑</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-Dubbo-启停原理解析"><span class="nav-number">5.</span> <span class="nav-text">第五章 Dubbo 启停原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于xml配置原理解析"><span class="nav-number">5.1.</span> <span class="nav-text">基于xml配置原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spring的xml解析简单调用流程"><span class="nav-number">5.1.1.</span> <span class="nav-text">spring的xml解析简单调用流程.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DubboNamspaceHandler的init方法"><span class="nav-number">5.1.2.</span> <span class="nav-text">DubboNamspaceHandler的init方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于注解的配置原理解析"><span class="nav-number">5.2.</span> <span class="nav-text">基于注解的配置原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring基于注解的简单调用流程"><span class="nav-number">5.2.1.</span> <span class="nav-text">Spring基于注解的简单调用流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务暴露的实现原理"><span class="nav-number">5.3.</span> <span class="nav-text">服务暴露的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo配置的优先级"><span class="nav-number">5.3.1.</span> <span class="nav-text">dubbo配置的优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo服务暴露整体机制"><span class="nav-number">5.3.2.</span> <span class="nav-text">dubbo服务暴露整体机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#远程服务的暴露"><span class="nav-number">5.3.3.</span> <span class="nav-text">远程服务的暴露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册中心协议暴露"><span class="nav-number">5.3.4.</span> <span class="nav-text">注册中心协议暴露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DubboProtocol的export方法"><span class="nav-number">5.3.5.</span> <span class="nav-text">DubboProtocol的export方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地服务暴露-injvm"><span class="nav-number">5.3.6.</span> <span class="nav-text">本地服务暴露 injvm</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务消费的原理"><span class="nav-number">5.4.</span> <span class="nav-text">服务消费的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo服务整体消费逻辑"><span class="nav-number">5.4.1.</span> <span class="nav-text">dubbo服务整体消费逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#远程服务的消费"><span class="nav-number">5.4.2.</span> <span class="nav-text">远程服务的消费</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册中心协议消费"><span class="nav-number">5.4.3.</span> <span class="nav-text">注册中心协议消费</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DubboProtol逻辑"><span class="nav-number">5.4.4.</span> <span class="nav-text">DubboProtol逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo多注册中心消费原理"><span class="nav-number">5.4.5.</span> <span class="nav-text">Dubbo多注册中心消费原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo直连服务消费原理"><span class="nav-number">5.4.6.</span> <span class="nav-text">Dubbo直连服务消费原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo优雅停机原理"><span class="nav-number">5.4.7.</span> <span class="nav-text">Dubbo优雅停机原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dubbo-远程调用"><span class="nav-number">6.</span> <span class="nav-text">Dubbo 远程调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dubbo核心调用流程"><span class="nav-number">6.1.</span> <span class="nav-text">dubbo核心调用流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo协议详解"><span class="nav-number">6.2.</span> <span class="nav-text">Dubbo协议详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo报文格式"><span class="nav-number">6.2.1.</span> <span class="nav-text">Dubbo报文格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求消息体"><span class="nav-number">6.2.2.</span> <span class="nav-text">请求消息体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应消息体"><span class="nav-number">6.2.3.</span> <span class="nav-text">响应消息体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#粘包-解包"><span class="nav-number">6.2.4.</span> <span class="nav-text">粘包&#x2F;解包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo如何在高并发的保证安全性"><span class="nav-number">6.2.5.</span> <span class="nav-text">dubbo如何在高并发的保证安全性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码器原理"><span class="nav-number">6.3.</span> <span class="nav-text">编码器原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编码器的总体模板模式"><span class="nav-number">6.3.1.</span> <span class="nav-text">编码器的总体模板模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dubbo协议解码器"><span class="nav-number">6.4.</span> <span class="nav-text">Dubbo协议解码器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解码器模板"><span class="nav-number">6.4.1.</span> <span class="nav-text">解码器模板</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Telnet调用原理"><span class="nav-number">6.5.</span> <span class="nav-text">Telnet调用原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dubbo-Telnet-的使用"><span class="nav-number">6.5.1.</span> <span class="nav-text">dubbo Telnet 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调用原理"><span class="nav-number">6.5.2.</span> <span class="nav-text">调用原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ChannelHandler"><span class="nav-number">6.6.</span> <span class="nav-text">ChannelHandler</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty-的简单使用"><span class="nav-number">6.6.1.</span> <span class="nav-text">Netty 的简单使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NIO-reactor模型"><span class="nav-number">6.6.2.</span> <span class="nav-text">NIO reactor模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo的核心handler和线程模型"><span class="nav-number">6.6.3.</span> <span class="nav-text">Dubbo的核心handler和线程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo常见的Handler类型"><span class="nav-number">6.6.4.</span> <span class="nav-text">Dubbo常见的Handler类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ChannelHandler的调用逻辑"><span class="nav-number">6.6.5.</span> <span class="nav-text">ChannelHandler的调用逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo请求响应Handler"><span class="nav-number">6.6.6.</span> <span class="nav-text">Dubbo请求响应Handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-心跳handler"><span class="nav-number">6.6.7.</span> <span class="nav-text">Dubbo 心跳handler</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章-Dubbo集群容错"><span class="nav-number">7.</span> <span class="nav-text">第七章 Dubbo集群容错</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Cluster层概述"><span class="nav-number">7.1.</span> <span class="nav-text">Cluster层概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容错机制"><span class="nav-number">7.2.</span> <span class="nav-text">容错机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dubbo-九种容错机制"><span class="nav-number">7.2.1.</span> <span class="nav-text">Dubbo 九种容错机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Directory的实现"><span class="nav-number">7.3.</span> <span class="nav-text">Directory的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由的实现"><span class="nav-number">7.4.</span> <span class="nav-text">路由的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#条件路由"><span class="nav-number">7.4.1.</span> <span class="nav-text">条件路由</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#负载均衡"><span class="nav-number">7.5.</span> <span class="nav-text">负载均衡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#公用的特性"><span class="nav-number">7.5.1.</span> <span class="nav-text">公用的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常用的几种负载均衡算法"><span class="nav-number">7.5.2.</span> <span class="nav-text">常用的几种负载均衡算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Merger的实现"><span class="nav-number">7.6.</span> <span class="nav-text">Merger的实现</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vicyor"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">vicyor</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">49</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vicyor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vicyor" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2457569580@qq.com" title="E-Mail → mailto:2457569580@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vicyor</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">867k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">13:08</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=m9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'm9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz',
            'X-LC-Key': 'g7WSuE6aDmunoX4rgyBN7SJa',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'qQhr9rNGJh6YalJA0mfaaurx-gzGzoHsz',
    appKey: 'kJy8NJeOTMPnxQ3zLihOcnw3',
    placeholder: "请留下您的宝贵评论",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

	
		 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
		 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
		 <script type="text/javascript" src="/js/src/fireworks.js"></script>
	
</body>
</html>
