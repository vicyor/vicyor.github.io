<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://vicyor.gitee.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="&lt;&lt;深入了解Java虚拟机&gt;&gt;这本书把java相关的大部分的底层都讲了一遍.">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm">
<meta property="og:url" content="http://vicyor.gitee.io/2020/07/11/jvm/index.html">
<meta property="og:site_name" content="Vicyor">
<meta property="og:description" content="&lt;&lt;深入了解Java虚拟机&gt;&gt;这本书把java相关的大部分的底层都讲了一遍.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/jvm/java-object.jpg">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/jvm/javac-compiler-process.jpg">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/jvm/markword.png">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/jvm/biasable.jpg">
<meta property="og:image" content="http://vicyor.gitee.io/2020/07/11/jvm/lock.png">
<meta property="article:published_time" content="2020-07-11T01:00:40.519Z">
<meta property="article:modified_time" content="2020-07-11T01:00:41.253Z">
<meta property="article:author" content="vicyor">
<meta property="article:tag" content="jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://vicyor.gitee.io/2020/07/11/jvm/java-object.jpg">

<link rel="canonical" href="http://vicyor.gitee.io/2020/07/11/jvm/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>jvm | Vicyor</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vicyor</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">41</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">39</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vicyor.gitee.io/2020/07/11/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="vicyor">
      <meta itemprop="description" content="大路且慢慢,咱一步一步走完.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vicyor">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          jvm
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-11 09:00:40 / 修改时间：09:00:41" itemprop="dateCreated datePublished" datetime="2020-07-11T09:00:40+08:00">2020-07-11</time>
            </span>

          
            <span id="/2020/07/11/jvm/" class="post-meta-item leancloud_visitors" data-flag-title="jvm" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/07/11/jvm/#comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/07/11/jvm/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>65k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>59 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>&lt;&lt;深入了解Java虚拟机&gt;&gt;这本书把java相关的大部分的底层都讲了一遍.</p>
<a id="more"></a>
<h2 id="第一章-走进JAVA"><a href="#第一章-走进JAVA" class="headerlink" title="第一章 走进JAVA"></a>第一章 走进JAVA</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><h4 id="JDK各个版本新特性"><a href="#JDK各个版本新特性" class="headerlink" title="JDK各个版本新特性"></a>JDK各个版本新特性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">JDK1.5</span><br><span class="line">  1.泛型(Signature).</span><br><span class="line">  2.枚举(Enum).</span><br><span class="line">  3.注解(Annotation).</span><br><span class="line">  4.可变参数(Varargs).</span><br><span class="line">  5.装箱与拆箱.</span><br><span class="line">  6.遍历循环(foreach循环).</span><br><span class="line">  7.静态导入(导入某个静态方法).</span><br><span class="line">  8.java.util.concurrent(并发包).</span><br><span class="line">JDK1.6</span><br><span class="line">  1.Compiler ApI(Java 动态编译器).</span><br><span class="line">  2.嵌入式数据库 Derby.</span><br><span class="line">JDK1.7</span><br><span class="line">  1.java.lang.invoke(MethodHandler). </span><br><span class="line">  2.invokedynamic(动态类型语言).</span><br><span class="line">  3.某些语法糖. </span><br><span class="line">    Map map&#x3D;&#123;name:&quot;vicyor&quot;,age:18&#125;;</span><br><span class="line">    Set&lt;String&gt;set&#x3D;&#123;&quot;item1&quot;,&quot;item2&quot;,&quot;item3&quot;&#125;;</span><br><span class="line">    int binary&#x3D;0b101;</span><br><span class="line">  4.switch可以用String类型.</span><br><span class="line">  5.G1垃圾回收器.</span><br><span class="line">JDK1.8</span><br><span class="line">  1.lambda表达式(动态类型语言 BootstrapMethod,CallSite,MethodType,MethodHandle).</span><br><span class="line">  2.@FunctionInterface.</span><br><span class="line">  3.方法引用.</span><br><span class="line">  4.Stream Api.</span><br><span class="line">  5.Optional类</span><br><span class="line">  6.inteface的默认方法实现.</span><br><span class="line">    public interface IHello&#123;</span><br><span class="line">        default public void sayHello()&#123;</span><br><span class="line">            System.out.println(&quot;hello&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二章-Java-内存区域与内存溢出异常"><a href="#第二章-Java-内存区域与内存溢出异常" class="headerlink" title="第二章 Java 内存区域与内存溢出异常"></a>第二章 Java 内存区域与内存溢出异常</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Program Counter Register 是一块较小的内存空间,是当前线程所执行字节码的行号指示器.</span><br><span class="line">2.字节码解释器(Interpreter)是通过程序计数器的值来选取需要执行的字节码指令.</span><br><span class="line">3.程序计数器只存地址,无OOM错误.</span><br><span class="line">4.线程私有.</span><br></pre></td></tr></table></figure>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.Java Virtual Machine Stacks是描述Java方法执行的内存模型.</span><br><span class="line">2.每个方法在执行时候都会创建一个栈帧(Stack Frame).调用一个方法到返回,对栈而言就是栈帧的压入和弹出.</span><br><span class="line">3.栈帧数据结构:            </span><br><span class="line">   局部变量表</span><br><span class="line">   操作数栈</span><br><span class="line">   方法出口</span><br><span class="line">   动态链接(dynamic linking) 我觉得和invoke dynamic有关.</span><br><span class="line">4.局部变量表结构:</span><br><span class="line">   基本数据类型</span><br><span class="line">   对象引用类型(reference)</span><br><span class="line">   returnAddress(指向一条字节码指令的地址,基本就没有了)</span><br><span class="line">   局部变量表的组成单位是slot,slot的大小一般是32bit,像double这种用2个slot.</span><br><span class="line">   局部变量表的第0位存this引用.</span><br><span class="line">5.栈可能出现的jvm 错误</span><br><span class="line">  StackOverflowError  当jvm栈深度大于虚拟机能允许的深度.</span><br><span class="line">  OutOfMemoryError              当线程数量过多时候.</span><br></pre></td></tr></table></figure>
<h4 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.几乎所有的对象都在JAVA堆上分配.</span><br><span class="line">  特殊的对象            </span><br><span class="line">   1.Class对象在方法区分配</span><br><span class="line">   2.JIT及时编译器与逃逸分析技术</span><br><span class="line">     栈上分配 (OSA,TLAB-&gt;THread Local Allocation Buffer)</span><br><span class="line">     标量替换 (拆分对象成基本数据类型)</span><br><span class="line">2.线程共享.</span><br></pre></td></tr></table></figure>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.方法区存放虚拟机加载的类信息,常量,静态变量,JIT编译后的代码.</span><br><span class="line">2.JAVA虚拟机规范把方法区描述为堆的一个逻辑部分,但是我们叫它 Non-Heap,与java堆区分.</span><br><span class="line">3.jdk 1.7 hotspot 用 永久代 实现方法区.</span><br><span class="line">  jdk 1.7 字符串常量池进入堆中.</span><br><span class="line">  jdk 1.8 hotspot 用 metaspace 实现方法区.</span><br><span class="line">4.方法区的垃圾回收目标主要是针对常量池以及类型的卸载.</span><br><span class="line">  永久代实现方法区容易遇到OOM以及内存泄露问题.</span><br><span class="line">5.MetaSpace使用的是NativeMemory,不存在于java虚拟机中.</span><br><span class="line">  1.每个类加载器都会有其对应的元空间. (OSGI)</span><br><span class="line">  2.由于每个元空间属于类加载器,属于类加载的卸载和其加载的类卸载会很方便.</span><br><span class="line">6.方法区的运行时常量池.</span><br><span class="line">  常量池: 字面量+符号引用(会变直接引用)</span><br><span class="line">  字面量: 基本数据类型,String.</span><br><span class="line">  符号引用: </span><br><span class="line">          CONSTRANT_Class_info</span><br><span class="line">          CONSTRANT_Fieldref_info</span><br><span class="line">          CONSTRANT_Methodref_info</span><br><span class="line">          CONSTRANT_Interface-Methodref_info</span><br><span class="line">7.class对象是存在方法区中的,hotspot jdk 1.7永久代在堆中,</span><br><span class="line">  static 值(基本数据类型&#x2F;&quot;&quot;)或reference是存在Class对象里.</span><br><span class="line">  Class是操作方法区的类数据入口.</span><br><span class="line">  参考博客:https:&#x2F;&#x2F;blog.csdn.net&#x2F;x_iya&#x2F;article&#x2F;details&#x2F;81260154</span><br></pre></td></tr></table></figure>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.直接内存不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域.</span><br><span class="line">2.jdk 1.4 引入NIO Reactor设计模式,基于通道和缓存.</span><br><span class="line">  可以通过API直接分配堆外内存.DirectByteBuffer对象可以对堆外内存做引用处理操作.</span><br><span class="line">  注意 DirectByteBuffer不被jvm回收的话,堆外内存也不会被回收.</span><br><span class="line">3.jvm内存+堆外内存大于物理内存限时候,也会出现OOM错误.</span><br></pre></td></tr></table></figure>
<h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><h4 id="Java对象的几种创建方式"><a href="#Java对象的几种创建方式" class="headerlink" title="Java对象的几种创建方式"></a>Java对象的几种创建方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.obj.clone(); 浅拷贝</span><br><span class="line">2.序列化        ObjectInputStream</span><br><span class="line">3.new          new</span><br><span class="line">4.反射         class.newInstance();</span><br></pre></td></tr></table></figure>
<h4 id="对象的创建过程"><a href="#对象的创建过程" class="headerlink" title="对象的创建过程"></a>对象的创建过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.Interpreter解析new指令时,会根据指令的参数去常量池寻找类的符号引用.</span><br><span class="line">2.符号引用指向的类若未被加载,解析和初始化.则会触发类加载操作.</span><br><span class="line">3.虚拟机为新生对象分配内存.</span><br><span class="line">  二种分配对象内存的方式.</span><br><span class="line">    指针碰撞(Bump the Pointer) (Servial,ParNew,Mark Compact)</span><br><span class="line">       假设Java堆中的内存时规整的,已分配的内存在左边,未分配的内存在右边.</span><br><span class="line">       通过一个指针作为分界点的指示器.分配内存就将指针向空闲空间移动与对象大小相同的空间.</span><br><span class="line">    空闲列表(Free List) (Mark Sweep)</span><br><span class="line">       在分配的时候从列表中找到一块足够大的空间划分给对象实例,并更新列表上的记录,这种分配</span><br><span class="line">       方式称为空闲列表.</span><br><span class="line">    虚拟机分配对象内存是通过移动指针,在并发情况下会出现线程安全问题.</span><br><span class="line">     二种解决方式</span><br><span class="line">       1.cas分配和失败重试.</span><br><span class="line">         for(;;)&#123;if(cas(o,ov,nv)&#123;break;&#125;&#125;;</span><br><span class="line">       2.TLAB (-XX:+UseTLAB)</span><br><span class="line">         内存分配的动作按线程划分到不同的空间之中.</span><br><span class="line">4.虚拟机为新生对象的字段进行赋零值操作.</span><br><span class="line">5.虚拟机设置对象头</span><br><span class="line">  对象头:Markword+符号引用</span><br><span class="line">6.执行&lt;init&gt;方法  初始化.</span><br><span class="line">  父类---&gt;子类字段---&gt;构造函数</span><br></pre></td></tr></table></figure>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p><img src="/2020/07/11/jvm/java-object.jpg" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.在HotSpot虚拟机中,对象在内存中的存储的布局可以分为三个区域:</span><br><span class="line">  对象头(Header)+实例数据(Instance Data)+对齐数据(Padding).</span><br><span class="line">2.对象头包含2部分.MarkWord和类型指针.</span><br><span class="line">3.MarkWord的数据结构. 32Bit&#x2F;64Bit</span><br><span class="line">  HashCode,GC分代年龄,锁状态标志,线程持有的锁,偏向线程Id,偏向时间戳,epoch,等</span><br><span class="line">4.类型指针. constrant_class_info 可以通过这个指针找到对象的类.</span><br><span class="line">5.若对象是数组对象,对象头还由一块用于记录数组长度的数据.</span><br><span class="line">6.虚拟机可以通过Java对象的元数据确定Java对象的大小.</span><br><span class="line">  数组对象的大小不能确定.</span><br><span class="line">7.对象的大小必须是8byte的整数倍,当对象数据部分没有对其时候,需要通过对其填充(Padding)来补全.</span><br></pre></td></tr></table></figure>
<h4 id="对象的访问方式"><a href="#对象的访问方式" class="headerlink" title="对象的访问方式"></a>对象的访问方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.句柄池.</span><br><span class="line">  Java堆中会划分一块内存来做句柄池,reference中存的是对象的句柄地址.句柄包含了对象的实例数据和类型数据.</span><br><span class="line">  类型数据---&gt;Class对象.</span><br><span class="line">2.直接指针.</span><br><span class="line">  reference存的是对象地址.</span><br><span class="line">  对象Header里存的是类型指针.</span><br><span class="line">3.两种方式的优点.</span><br><span class="line">  句柄池: 在垃圾回收,例如标记整理算法,会移动对象位置，对象地址会变,而通过句柄池这种方式,reference的句柄地址不会变.</span><br><span class="line">  直接指针: 访问速度快,句柄池多转一次.</span><br><span class="line">4.HotSpot是使用直接地址的方式.</span><br><span class="line">  reference存对象地址.</span><br><span class="line">  对象Header存类型指针.</span><br></pre></td></tr></table></figure>
<h3 id="OutOfMemeoryError-异常"><a href="#OutOfMemeoryError-异常" class="headerlink" title="OutOfMemeoryError 异常"></a>OutOfMemeoryError 异常</h3><h4 id="内存泄露和内存溢出"><a href="#内存泄露和内存溢出" class="headerlink" title="内存泄露和内存溢出"></a>内存泄露和内存溢出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内存泄露: 程序在申请内存后,无法释放已申请的内存空间造成内存泄露.</span><br><span class="line">内存溢出: 程序申请内存时,没有足够的内存供申请者使用.</span><br></pre></td></tr></table></figure>
<h4 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  VM Args： -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span></span>&#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">                        </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">                        List&lt;OOMObject&gt;list=<span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">                        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                                    list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.虚拟机规范描述了两种异常.</span><br><span class="line">  <span class="number">1</span>.StackOverflowError  线程请求的栈深度大于虚拟机规范允许的最大深度.</span><br><span class="line">  <span class="number">2</span>.OutOfMemoryError             虚拟机在扩展栈时无法申请到足够的空间.</span><br><span class="line"><span class="number">2</span>.StackOverflowError</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  *VM Args : -Xss128k</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</span><br><span class="line">                 stackLength++;</span><br><span class="line">                 stackLeak();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">                 JavaVMStackSOF sof=<span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">                 <span class="keyword">try</span>&#123;</span><br><span class="line">                             sof.stackLeak();</span><br><span class="line">                 &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">                             System.out.println(<span class="string">"stack length:"</span>+oom.stackLength);</span><br><span class="line">                 &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="number">4</span>.OutOfMemoryError</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * VM Args -Xss2M</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span></span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span></span>&#123;</span><br><span class="line">                            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                                        </span><br><span class="line">                            &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">                            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                                        Thread thread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable)&#123;</span><br><span class="line">                                                    <span class="meta">@Override</span></span><br><span class="line">                                                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                                                                dontStop();</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                        &#125;;</span><br><span class="line">                                        thread.start();</span><br><span class="line">                            &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">                            JavaVMStackOOM oom=<span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">                            oom.stackLeadByThread();</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">PS: Java的线程是映射在操作系统的内核线程上,如果创建多个线程,并抛出oom,会导致操作系统假死.</span><br></pre></td></tr></table></figure>
<h4 id="方法区和运行时常量池的溢出"><a href="#方法区和运行时常量池的溢出" class="headerlink" title="方法区和运行时常量池的溢出"></a>方法区和运行时常量池的溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.方法区溢出.</span><br><span class="line">            <span class="number">1</span>.疯狂通过不同的类加载器加载类.</span><br><span class="line">            <span class="number">2</span>.疯狂动态创建类，如aop.</span><br><span class="line">            <span class="number">3</span>.JSP 文件 JasperLoader.</span><br><span class="line">            <span class="number">4</span>.基于OSGI的应用,同一个类文件,被不同的加载器加载.</span><br><span class="line"><span class="number">2</span>.运行时常量池溢出.</span><br><span class="line">  <span class="number">1</span>.<span class="string">"abcdefg"</span>.intern().  jdk <span class="number">1.7</span>后可能会没用</span><br><span class="line"><span class="number">3</span>.运行时常量池溢出</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * VM Args: -XX:PermSize=10M -XX:MaxPermSize</span></span><br><span class="line"><span class="comment">   * JDK Version 1.6</span></span><br><span class="line"><span class="comment">   * JDK 1.6 OOM--&gt;PermGen Space</span></span><br><span class="line"><span class="comment">   * Jdk 1.7+ OOM--&gt; GC overhead limit exceeded</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span></span>&#123;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">4</span>.关于字符串池的小问题</span><br><span class="line">  String str=<span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).appent(<span class="string">"软件"</span>).toString();</span><br><span class="line">  System.out.println(str.intern()==str);</span><br><span class="line">  jdk1<span class="number">.6</span> ===&gt;False 因为 str在堆中,str.intern在字符串常量池中，字符串常量池在方法区中.</span><br><span class="line">  jdk1<span class="number">.7</span> ===&gt;True  因为 str在堆中,str.intern在字符串常量池中，字符串常量池在堆中.</span><br><span class="line"><span class="number">5</span>.方法区溢出.</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                            Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line">                            enhancer.setSuperClass(OOMObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">                            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor()&#123;</span><br><span class="line">                                       <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj,Mehtod method,Object[]args,MethodProxy proxy)</span> <span class="keyword">throws</span> Threwable</span>&#123;</span><br><span class="line">                                                   <span class="keyword">return</span> proxy.invokeSuper(obj,args);</span><br><span class="line">                                       &#125; </span><br><span class="line">                            &#125;);</span><br><span class="line">                            enhancer.create();</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.DirectMemory容量可以通过 -XX:MaxDirectMemorySize指令.</span><br><span class="line"><span class="number">2</span>.默认DirectMemory大小和-Xmx容量大小相同.</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * VM Args -Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span></span>&#123;</span><br><span class="line">              <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB=<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">                          Field unsafeField=Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">                          unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                          Unsafe unsfae=(Unsafe)unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">                          <span class="keyword">while</span>(ture)&#123;</span><br><span class="line">                                      unsafe.allocateMemory(_1MB);</span><br><span class="line">                          &#125;</span><br><span class="line">              &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="第三章-垃圾回收器与内存分配策略"><a href="#第三章-垃圾回收器与内存分配策略" class="headerlink" title="第三章 垃圾回收器与内存分配策略"></a>第三章 垃圾回收器与内存分配策略</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="GC需要完成的3件事情"><a href="#GC需要完成的3件事情" class="headerlink" title="GC需要完成的3件事情"></a>GC需要完成的3件事情</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.哪些内存需要回收</span><br><span class="line">2.什么时候需要回收</span><br><span class="line">3.如何回收</span><br></pre></td></tr></table></figure>
<h4 id="什么时候回收"><a href="#什么时候回收" class="headerlink" title="什么时候回收"></a>什么时候回收</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.程序计数器,虚拟机栈,本地方法栈三个区域随线程生,随线程灭.</span><br><span class="line">  栈帧的内存时在类结构确定下来就已知的,所以这几个区域的回收具有确定性.</span><br><span class="line">2.Java堆和方法区的回收具有动态性,因为我们只有在程序运行期间才知道会创建哪些对象.</span><br></pre></td></tr></table></figure>
<h3 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.引用计数法,当有一个引用指向对象时,对象的计数器值就加1，当引用失效时,对象计数器就减1.</span><br><span class="line">  当计数为0时,这个对象就是不可用的.</span><br><span class="line">  缺点:不能解决循环引用的问题.</span><br></pre></td></tr></table></figure>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.可达性算法:</span><br><span class="line">  通过一系列的称为&quot;GC ROOTS&quot;的对象作为起始点,从这些节点往下搜索,走过的路径称为引用链(Reference chain),</span><br><span class="line">  当一个对象到GC ROOTs 没有任何的引用链时候,则证明该对象是不可用的.</span><br><span class="line">2.GC ROOTS 的对象.</span><br><span class="line">  1.虚拟机栈(栈帧的局部变量表)中引用的对象.</span><br><span class="line">  2.方法区类静态属性引用的对象.</span><br><span class="line">  3.方法区常量引用的对象.</span><br><span class="line">  4.JNI引用的对象</span><br></pre></td></tr></table></figure>
<h4 id="GC-ROOTS-两次标记"><a href="#GC-ROOTS-两次标记" class="headerlink" title="GC ROOTS 两次标记"></a>GC ROOTS 两次标记</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.对象在进行可达性分析时候发现没有与GCRoots相连的引用链,那么它将会被第一次标记.</span><br><span class="line">  并进行一次筛选,筛选的条件是对象是否有必要执行finalize方法.</span><br><span class="line">2.若对象没有Override finalize方法,或者finalize方法已经被执行过.则对象会被直接回收.</span><br><span class="line">3.若对象被筛选出来会放入-个F-Queue中.</span><br><span class="line">4.虚拟机会创建一个Finalizer守护线程.由这个线程执行finialize方法.</span><br><span class="line">5.自救</span><br><span class="line">  GC会对F-Queue中的对象做二次标记,若对象在finalize中拯救了自己,那么它可以逃脱回收.若自救失败,那么它只能被回收.</span><br><span class="line">  自救方式:</span><br><span class="line">     将this发布出去.例如list.add(this). xxx.setObj(this);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代码展示了2点</span></span><br><span class="line"><span class="comment"> * 1.自救</span></span><br><span class="line"><span class="comment"> * 2.只能自救一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span></span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK=<span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> isAlive&#123;</span><br><span class="line">                        System.out.println(<span class="string">"yes,i am still alive :"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span><span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                        <span class="keyword">super</span>.finalize();</span><br><span class="line">                        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">                        <span class="comment">//自救</span></span><br><span class="line">                        FinalizeEscapeGC.SAVE_HOOK=<span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                        SAVE_HOOK=<span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">                        SAVE_HOOK=<span class="keyword">null</span>;</span><br><span class="line">                        System.gc(); <span class="comment">//full gc  </span></span><br><span class="line">                        Thread.sleep(<span class="number">500</span>); <span class="comment">//让出cpu,让Finalizer线程由runnable变为running</span></span><br><span class="line">                        <span class="keyword">if</span>(SAVE_HOOK!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                                    <span class="comment">//自救</span></span><br><span class="line">                                    SAVE_HOOK.isAlive();</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">"no, i am dead "</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        SAVE_HOOK=<span class="keyword">null</span>;</span><br><span class="line">                        System.gc(); <span class="comment">//full gc</span></span><br><span class="line">                        THread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="keyword">if</span>(SAVE_HOOK!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                                    SAVE_HOOK.isAlive();</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">"no, i am dead"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span>.不推荐使用 finalize方法.</span><br><span class="line">  运行代价高昂,不确定性大,无法确保各个对象的调用关系.</span><br><span class="line">  finalize的逻辑完全可以在<span class="keyword">try</span>-<span class="keyword">finally</span>或者其它方式.</span><br></pre></td></tr></table></figure>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.jdk1.1 JAVA引用的定义:</span><br><span class="line">  如果reference类型的数据中存储的代表另外一块内存的起始地址,就称这块内存代表一个引用.</span><br><span class="line">  缺点:引用种类太少,对某些&quot;食之无味,弃之可惜&quot;的对象无能为例.</span><br><span class="line">  例如:</span><br><span class="line">     内存空间还足够时,就将其保留在内存中.</span><br><span class="line">     若内存空间在垃圾回收时还非常紧张,则抛弃这些对象.</span><br><span class="line">2.jdk1.2之后,Java对引用进行了扩充.</span><br><span class="line">  引用分为:强引用(Strong Reference),软引用(Soft Reference),弱引用(Weak Reference),虚引用(PhantomReference Reference).</span><br><span class="line">     强引用: 垃圾回收器永远不会回收掉的对象.</span><br><span class="line">     软引用: 在系统即将发生内存溢出异常时候,会对其进行回收.</span><br><span class="line">     弱引用: 垃圾收集器工作时候,会回收弱引用关联的对象. </span><br><span class="line">     虚引用: 无法通过虚引用取得对象实例,为对象设置虚引用的目的是在这个对象被垃圾收集器回收时候收到一个系统通知.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ps:ThreadLocalMap的Entry</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line">            <span class="comment">//k被保存在超类的referent字段中.</span></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                        <span class="keyword">super</span>(k);<span class="comment">//super方法会将k赋给referent字段.</span></span><br><span class="line">                        value = v;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.方法区的组成:</span><br><span class="line">  方法区--&gt;class文件元数据+常量池</span><br><span class="line">  常量池--&gt;字面量+符号引用</span><br><span class="line">2.永久代的垃圾回收效率很低,而堆的回收效率很高,尤其是新生代,每次回收能回收70%-95%的空间.</span><br><span class="line">3.永久代垃圾回收的内容.</span><br><span class="line">  废弃常量+无用的类.</span><br><span class="line">4.废弃常量和符号引用的回收.</span><br><span class="line">  GC 可达性算法.</span><br><span class="line">5.无用的类(类卸载).</span><br><span class="line">   1.该类所有的实例都被回收.</span><br><span class="line">   2.该类的ClassLoader被回收.(条件很苛刻)</span><br><span class="line">   3.该类的对应的java.lang.Class没有在任何地方被引用.</span><br><span class="line">6.虚拟机必须具备类卸载的情况,避免方法区溢出.</span><br><span class="line">  1.反射.</span><br><span class="line">  2.动态代理,CGLib等ByteCode框架.</span><br><span class="line">  3.动态生成JSP.</span><br><span class="line">  4.OSGi需要频繁的自定义ClassLoader。</span><br></pre></td></tr></table></figure>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.标记-清除算法(Mark-Sweep).</span><br><span class="line">  算法分为标记和清除两个阶段.</span><br><span class="line">     1.标记出要回收的对象(可达性分析法).</span><br><span class="line">     2.统一回收所有标记的对象.</span><br><span class="line">2.Mark-Sweep的3个缺点.</span><br><span class="line">  1.效率问题,标记和清除的效率都不高.</span><br><span class="line">  2.空间问题,标记和清除后会产生大量不连续的内存碎片.</span><br><span class="line">  3.空间碎片大量,导致不能分配连续内存给大对象,不得不触发一次垃圾回收.(不是说mark sweep对应 空闲列表的分配方式).</span><br></pre></td></tr></table></figure>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.复制算法(Copying).</span><br><span class="line">  复制算法,它将可用的容量划分成大小相等的两块,每次只使用其中的一块.</span><br><span class="line">  当一块内存用完时候,就将还存活的对象移动到另外一个内存上.将已经使用的内存空间一次清理掉.</span><br><span class="line">2.现代的商业虚拟机采用复制算法回收新生代.</span><br><span class="line">  IBM公司的研究表示新生代的对象98%都是朝生夕死,并不需要按照1:1的比例来划分内存空间.</span><br><span class="line">  将新生代分为一块较大的Eden空间和两块较小的Survivor空间.</span><br><span class="line">  每次使用Eden和其中一块Survivor.回收时,将Eden和Survivor中还存活的对象一次性的复制到另一个Survivor空间上,</span><br><span class="line">  最后清理掉Eden和刚才用过的Survivor空间.</span><br><span class="line">  Eden + From Survivor + To Survivor</span><br><span class="line">3.HotSpot虚拟机默认Eden和Survivor的大小比例是8:1.</span><br><span class="line">4.当垃圾回收时,To Servivor的空间若不够用,则将放不下的那些对象(放得下的还放在ToServivor中)放到老年代进行分配担保.</span><br><span class="line">5.复制算法的缺点.</span><br><span class="line">  1.对象存活率高时,复制算法是复制操作,效率会变低(老年代所以不用这种算法).</span><br><span class="line">  2.浪费50%的额外空间(其实就浪费10%的ToServivor).</span><br></pre></td></tr></table></figure>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.标记整理算法(Mark-Compact).</span><br><span class="line">  标记整理分为两个步骤:</span><br><span class="line">     1.标记阶段和标记清除算法相同.</span><br><span class="line">     2.整理过程是将存活的对象向一端移动,直接清理掉端边界以外的内存.</span><br></pre></td></tr></table></figure>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.分代收集算法(Generational Collection).</span><br><span class="line">  根据对象的存活周期的不同将内存划分为几块.</span><br><span class="line">  新生代:对象朝生夕死,使用复制算法,只有少量的存活对象,付出的复制成本很低.</span><br><span class="line">  老年代:因为对象存活率高,没有额外的空间,必须使用标记-整理,标记-清理算法完成回收.</span><br></pre></td></tr></table></figure>
<h3 id="HotSpot算法实现"><a href="#HotSpot算法实现" class="headerlink" title="HotSpot算法实现."></a>HotSpot算法实现.</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.存在的问题.</span><br><span class="line">    1.从GCROOTS的节点出发查找整个引用链会比较消耗时间.</span><br><span class="line">      GC ROOTS的节点:</span><br><span class="line">      全局性的引用:            常量或类静态属性.</span><br><span class="line">      执行上下文:                        栈帧中的本地变量表.</span><br><span class="line">            2.一致性:GC停顿,整个分析期整个分析过程看起来就像被冻在某个时间点上,对象的引用关系不能还在不断变化.</span><br><span class="line">2.问题的解决.</span><br><span class="line">    1.HotSpot jvm中,使用OopMap的数据结构完成这个目的.</span><br><span class="line">      在类加载完成时候,HotSpot就将对象内什么偏移量上是什么数据类型计算出来.</span><br><span class="line">      在JIT编译过程中,也会在特定的位置记录下栈和寄存器中哪些位置是引用.</span><br><span class="line">    2.GC执行时必须要停顿所有的Java执行线程. STW</span><br></pre></td></tr></table></figure>
<h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.每条指令都可能引起OopMap的变化,但是对每条指令,都生成对应的OopMap,GC的空间成本会变的很高.</span><br><span class="line">2.HtopSpot只是在特定的位置记录了这些信息.这些位置被称为安全点.  </span><br><span class="line">3.程序执行时,只有到达安全点才会暂停并进行GC.</span><br><span class="line">4.SafePoint的选用既不能太少导致GC等待时间太长.</span><br><span class="line">  也不能太多导致频繁gc,增大运行时符合.</span><br><span class="line">5.安全点的选定基本上根据指令是否具有让程序长时间执行的特征。</span><br><span class="line">  例如方法调用,循环跳转,异常跳转.</span><br></pre></td></tr></table></figure>
<h4 id="STW实现方式"><a href="#STW实现方式" class="headerlink" title="STW实现方式"></a>STW实现方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.线程中断有二种方案可供选择.</span><br><span class="line">  抢占式中断(不适合):若线程正处在安全点上,则直接中断线程.若线程未在安全点上,则让它执行,跑到安全点上. </span><br><span class="line">  主动式中断:为所有线程设置中断位,若线程发现中断位为true时,就中断线程.</span><br></pre></td></tr></table></figure>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.某些指令执行后,程序是进入blocked或sleep状态.线程让出cpu,无法响应STW,</span><br><span class="line">  对于这种问题,JVM使用安全区域解决.</span><br><span class="line">2.安全区域是指在一段代码中,引用关系不会发生变化.</span><br><span class="line">  在这个位置中任意地方开始GC都是安全的.</span><br><span class="line">3.线程离开安全区域必须收到根节点枚举或者整个GC已完成的通知.</span><br></pre></td></tr></table></figure>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Serial收集器是年轻代垃圾收集器.</span><br><span class="line">2.在垃圾回收时,STW,只有一个垃圾回收线程.</span><br><span class="line">3.Serial主要用于桌面应用,Client模式下的虚拟机.</span><br></pre></td></tr></table></figure>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.ParNew收集器是年轻代垃圾收集器.</span><br><span class="line">2.ParNew是Serial的多线程版本.在垃圾回收时,STW,有多个垃圾回收线程并行执行.</span><br><span class="line">3.ParNew多用于Server模式下的虚拟机的新生代收集器.</span><br><span class="line">  原因: ParNew可以和CMS垃圾收集器一起使用.</span><br></pre></td></tr></table></figure>
<h4 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.操作系统的并发和并行</span><br><span class="line">  并发:在一个时间段,多个线程同时执行.</span><br><span class="line">  并行:在一个时间点,多个线程同时执行.</span><br><span class="line">2.垃圾收集器的并发和并行</span><br><span class="line">  并行:多个垃圾收集线程并行工作,此时用户线程仍然处于等待状态.</span><br><span class="line">  并发:用户线程与垃圾回收线程同时执行.</span><br></pre></td></tr></table></figure>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.Parallel Scavenge收集器是一个新生代收集器.</span><br><span class="line">2.Parallel Scavenge收集器的目标是达到一个可控制的吞吐量.</span><br><span class="line">  吞吐量: 运行用户代码时间&#x2F;(运行用户代码时间+垃圾收集时间)</span><br><span class="line">3.Parallel Scavenge收集器提供了两个参数用于控制吞吐量.</span><br><span class="line">  -XX:GCTimeRatio 吞吐量大小</span><br><span class="line">  -XX:MaxGCPauseMillis 最大垃圾收集停顿时间</span><br><span class="line">  设定停顿时间的界限会修改新生代的大小.</span><br><span class="line">    例如减少新生代的大小,可以减少垃圾收集停顿时间.</span><br><span class="line">    但是会导致吞吐量下降,虽然单次垃圾收集停顿时间下降,</span><br><span class="line">    但随着垃圾回收次数的变多,导致总的垃圾收集停顿时间上升.</span><br><span class="line">4.-XX:+UseAdaptiveSizePolicy </span><br><span class="line">    虚拟机会根据当前系统运行情况,动态调整 -Xmn,-XX:SurvivorRatio,-XX:PretenureSizeThreshold(晋升老年代对象大小),</span><br><span class="line">    以提供最合适的停顿时间和最大的吞吐量.</span><br><span class="line">5.Parallel Scavenge垃圾收集器主要和Parallel Old收集器一同使用.</span><br></pre></td></tr></table></figure>
<h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Serial Old 是Serial收集器的老年代版本.标记整理.</span><br><span class="line">2.用途:</span><br><span class="line">  1.给Client模式的虚拟机使用.</span><br><span class="line">  2.作为CMS收集器的后备预案.</span><br></pre></td></tr></table></figure>
<h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Parallel Old 是Parallel Scavenage的老年代版本.</span><br><span class="line">2.使用多线程和标记整理算法.</span><br></pre></td></tr></table></figure>
<h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.CMS收集器是一种以最短回收停顿时间为目标的收集器.</span><br><span class="line">2.CMS收集器是基于标记-清除算法实现的,整个过程分为4个步骤.</span><br><span class="line">  1.初始标记(CMS initial mark).           GC ROOTS 根对象.</span><br><span class="line">  2.并发标记(CMS concurrent mark).        GC ROOTs Tracing过程.耗时长,所以并发.</span><br><span class="line">  3.重新标记(CMS remark).                                                         修正并发标记期间标记产生变动的那一部分对象(从未标记的对象能可达的).</span><br><span class="line">  4.并发清除(CMS concurrent sweep).       回收未标记的对象.</span><br><span class="line">3.CMS垃圾回收器缺点</span><br><span class="line">  1.mark sweep 存在内存碎片.</span><br><span class="line">  2.CMS垃圾回收器亦占用老年代空间.</span><br></pre></td></tr></table></figure>
<h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.G1收集器(garbage first).</span><br><span class="line">  G1会分析Region的垃圾回收价值(回收获取空间,回收花费时间)后台维护一个优先列表.优先回收价值最大的region.</span><br><span class="line">2.JAVA内存堆的布局.</span><br><span class="line">  使用G1收集器后,它将整个Java堆分为多个大小相等的独立区域Region.</span><br><span class="line">  概念上保留新生代和老年代.</span><br><span class="line">  新生代和老年代不再是物理隔离的,它们是一系列Region的集合.</span><br><span class="line">3.问题1:一个对象在一个Region中分配,那么该对象查找它引用的其它对象是否需要全堆扫描?</span><br><span class="line">   1.每个Region都会有Remembered Set.</span><br><span class="line">   2.虚拟机写一个对象时候,会检查该对象是否被其它对象引用.</span><br><span class="line">     若有,就会通过Card Table将该对象的引用放入其它对象Region的Remembered Set中.</span><br><span class="line">4.G1收集器的运作步骤.</span><br><span class="line">  1.初始标记.  </span><br><span class="line">  2.并发标记. GC ROOTS Tracing</span><br><span class="line">  3.最终标记. 虚拟机会将标记过的记录到Remembered Set logs中.将logs更新到set中.</span><br><span class="line">  4.筛选回收. 优先回收价值和成本最优的Region.</span><br></pre></td></tr></table></figure>
<h4 id="Full-GC触发时机"><a href="#Full-GC触发时机" class="headerlink" title="Full GC触发时机"></a>Full GC触发时机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.System.gc();</span><br><span class="line">2.永久代空间不足,不能分配新空间(jdk1.7).</span><br><span class="line">3.分配大对象(-XX:PretenureSizeThreshold).</span><br><span class="line">4.minor gc 时候</span><br><span class="line">  1.toServivor放不下                        --&gt; 老年代空间放不下晋升的对象.</span><br><span class="line">  2.对象年龄到了                                    --&gt; ......</span><br><span class="line">  .....                                                            --&gt; ......</span><br></pre></td></tr></table></figure>
<h4 id="垃圾回收器参数总结"><a href="#垃圾回收器参数总结" class="headerlink" title="垃圾回收器参数总结"></a>垃圾回收器参数总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC                        </span><br><span class="line">-XX:+UseParNewGC      </span><br><span class="line">-XX:+UseConcMarkSweepGC                             CMS</span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line">-XX:+UseParallelOldGC</span><br><span class="line">SurvivorRatio                                                    Eden:Survivor(Eden:From:To).</span><br><span class="line">PretenureSizeThreshold                             直接晋升到老年代对象大小.</span><br><span class="line">MaxTenuringTHreshold                                       晋升到老年代的对象的年龄.</span><br><span class="line">UseAdaptiveSizePolicy                                    Parallel Scavenge收集器才能用.</span><br><span class="line">HandlePromotionFailure                                    是否允许分配担保失败.机端情况:老年代剩余空间不足以应付Eden和Survivor所有对象.</span><br><span class="line">ParallelGCThreads                                                GC进行内存回收的线程数.</span><br><span class="line">GCTimeRatio                                                                        GC吞吐率.</span><br><span class="line">MaxGCPauseMillis                                                一次GC的最大停顿时间.</span><br><span class="line">CMSInitiatingOccupancyFraction            CMS收集器在老年代空间使用多少后触发垃圾收集.默认68%.</span><br><span class="line">UseCMSCompactAtFullCollection            CMS收集器在完成垃圾回收后,是否进行一次内存碎片整理.</span><br><span class="line">CMSFullGCsBeforeCompaction                        在若干次垃圾收集后启动一次内存碎片整理.</span><br></pre></td></tr></table></figure>
<h3 id="内存回收与回收策略"><a href="#内存回收与回收策略" class="headerlink" title="内存回收与回收策略"></a>内存回收与回收策略</h3><h4 id="minor-gc-与-major-gc"><a href="#minor-gc-与-major-gc" class="headerlink" title="minor gc 与 major gc"></a>minor gc 与 major gc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.minor gc: 发生在新生代的垃圾回收动作.回收速度快,回收频繁.</span><br><span class="line">2.major gc: 一般major gc都是由 minor gc导致的(System.gc()除外).Major GC 速度比 Minor GC 速度慢10倍.</span><br></pre></td></tr></table></figure>
<h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.对象优先在Eden分配,Eden空间不够会触发一次Minor GC.</span><br><span class="line"><span class="number">2</span>.存活的eden和from servivor中的对象会去to servivor.</span><br><span class="line"><span class="number">3</span>.如果to servivor放不下某些对象,就将放不下的那些对象送到 tenured generation.</span><br><span class="line"><span class="number">4</span>.如果 tenured generation 也放不下那些对象,就会触发Full GC.</span><br><span class="line"><span class="number">5</span>.如果Full GC后也放不下,就会抛出OOM.</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM params: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB=<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//eden 8M ,from servivor 1m,to servivor 1m</span></span><br><span class="line">             <span class="comment">//old 10M</span></span><br><span class="line">            <span class="keyword">byte</span> [] allocation1,allocation2,allocation3,allocation4;</span><br><span class="line">            allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">            allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">            allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">            <span class="comment">//minor gc</span></span><br><span class="line">            allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB];</span><br><span class="line">            <span class="comment">//eden 4m,old 6m.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB=<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -verbose:gc -Xms:20M -Xmx20M -Xmn10M -XX:+printGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">byte</span>[]allocation;</span><br><span class="line">            <span class="comment">//没有发生gc.</span></span><br><span class="line">            allocation=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.对象年龄记录在对象头(Head)的mark word中.</span><br><span class="line"><span class="number">2</span>.对象第一进入servivor时年龄为<span class="number">1</span>,每熬过一次gc,年龄+<span class="number">1</span>.</span><br><span class="line"><span class="number">3</span>.当对象的年龄增大于MaxTenuringThreshold(默认<span class="number">15</span>)时候,就会进入老年代.</span><br></pre></td></tr></table></figure>
<h4 id="对象动态年龄判定"><a href="#对象动态年龄判定" class="headerlink" title="对象动态年龄判定."></a>对象动态年龄判定.</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半,</span><br><span class="line">  年龄大于或等于该年龄的对象就直接进入老年代.</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB= <span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * VM params: -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment">   *            -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">byte</span>[] allocation1,allocation2,allocation3,allocation4;</span><br><span class="line">       allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[_1MB/<span class="number">4</span>];</span><br><span class="line">       allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[_1MB/<span class="number">4</span>];</span><br><span class="line">       allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB];</span><br><span class="line">       <span class="comment">//minor gc</span></span><br><span class="line">       <span class="comment">// eden 4m  ,from servivor 1/2 m &gt;=1/2 * 1mb,old 4mb</span></span><br><span class="line">       <span class="comment">//eden 4m , from servivor 0 ,old 4.5mb</span></span><br><span class="line">       allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB];</span><br><span class="line">       allocation4=<span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//minor gc 4m, old 4.5m</span></span><br><span class="line">       allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Handler Promotion Failure</span><br><span class="line">minor gc前:            </span><br><span class="line">     检查老年代最大的可用连续空间是否大于新生代所有对象总空间.</span><br><span class="line">         <span class="number">1</span>.满足的话,那么Minor GC 是安全的.</span><br><span class="line">         <span class="number">2</span>.不满足的话.</span><br><span class="line">           HandlePromotionFailure: </span><br><span class="line">             <span class="keyword">true</span>   检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小(与当前新生代对象大小无关).</span><br><span class="line">                    大于:(担保) minor gc.</span><br><span class="line">                    担保失败---&gt;full gc.</span><br><span class="line">                    小于:(不担保) full gc.</span><br><span class="line">             <span class="keyword">false</span> (不担保) full gc.</span><br><span class="line">         冒险:取历次晋升老年代对象的平均大小做参考.因为当前晋升老年代的对象已经大于老年代剩余的连续空间.</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB=<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 开启冒险</span></span><br><span class="line"><span class="comment">          * VM Params: -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:-HandlePromotionFailure</span></span><br><span class="line"><span class="comment">          * Version: jdk 6 update 24</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHandlePromiotion</span><span class="params">()</span></span>&#123;</span><br><span class="line">             <span class="keyword">byte</span>[]allocation1,allocation2,allocation3,allocation4,allocation5,allocation6,allocation7;</span><br><span class="line">             allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">             allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">             allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">             allocation1=<span class="keyword">null</span>;</span><br><span class="line">             allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">             allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">             allocation5=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">             allocation6=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">             allocation4=<span class="keyword">null</span>;</span><br><span class="line">             allocation5=<span class="keyword">null</span>;</span><br><span class="line">             allocation6=<span class="keyword">null</span>;</span><br><span class="line">             allocation7=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB];</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<h2 id="第四章-虚拟机性能监控与故障处理工具"><a href="#第四章-虚拟机性能监控与故障处理工具" class="headerlink" title="第四章 虚拟机性能监控与故障处理工具"></a>第四章 虚拟机性能监控与故障处理工具</h2><h2 id="第五章-调优案例分析与实战"><a href="#第五章-调优案例分析与实战" class="headerlink" title="第五章 调优案例分析与实战"></a>第五章 调优案例分析与实战</h2><h2 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h2><h3 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h3><h4 id="Class文件介绍"><a href="#Class文件介绍" class="headerlink" title="Class文件介绍"></a>Class文件介绍</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.Class文件是一组以8字节为基本单位的二进制流.</span><br><span class="line">  1.各个数据项目排列在Class文件中,中间没有添加任何分隔符.</span><br><span class="line">  2.若数据项目占用8字节以上,则会按照Big-Endian方式分割若干个8位的字节进行存储.</span><br><span class="line">  Big-Endian:最高位字节在地址最低位,最低位字节在地址最高位.</span><br><span class="line">  ps:操作系统的地址是越向下越高(大).看起来像栈.</span><br><span class="line">2.Class文件格式采用类似C语言结构体的伪结构体来存储数据.</span><br><span class="line">  这种伪结构体只有两种数据结构: 无符号数和表</span><br><span class="line">  无符号数: u1,u2,u4,u8 代表 1个字节,2个字节,4个字节,8个字节的无符号数.</span><br><span class="line">  表: 多个无符号数或其它数据项构成的复合数据类型,所有的表都习惯地以_info结尾.</span><br></pre></td></tr></table></figure>
<h4 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.Class 文件格式</span><br><span class="line">     表 6-1                         Class文件格式</span><br><span class="line">     类型           名称                            描述</span><br><span class="line">     u1             magic               魔数:0Xcafebabe</span><br><span class="line">     u2             minor_version       小版本</span><br><span class="line">     u2             major_version       大版本</span><br><span class="line">     u2             constant_pool_count 常量池大小</span><br><span class="line">     cp_info        constant_pool       常量池表</span><br><span class="line">     u2             access_flags        访问标志</span><br><span class="line">     u2             this_class          类索引</span><br><span class="line">     u2             super_class         父类索引</span><br><span class="line">     u2             interfaces_count</span><br><span class="line">     u2             interfaces          接口索引</span><br><span class="line">     u2             fields_count                        </span><br><span class="line">     field_info     fields              域表</span><br><span class="line">     u2             methods_count</span><br><span class="line">     method_info    methods             方法表</span><br><span class="line">     u2             attributes_count</span><br><span class="line">     attribute_info            attributes          属性表</span><br></pre></td></tr></table></figure>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.常量池可以理解为Class文件的资源仓库.</span><br><span class="line">2.常量池主要存放两大类常量:字面量+符号引用.</span><br><span class="line">  字面量: 字面量接近于Java语言层面的常量概念,如文本字符串,声明为final的常量值.</span><br><span class="line">  符号引用: 符号引用属于编译原理的概念,包括下面三类常量.</span><br><span class="line">       1.类 和 接口 的全限定名(Fully Qualified Name).</span><br><span class="line">       2.字段的名称和描述符(Descriptor).</span><br><span class="line">       3.方法的名称和描述符.</span><br><span class="line">3.Javac编译代码时候,并不像C和C++那样有&quot;连接&quot;这一步骤,而是虚拟机加载Class文件时候进行动态连接.</span><br><span class="line">  动态连接:在类创建时候将符号引用解析,翻译到具体的内存地址上.</span><br><span class="line">4.常量池的14种表结构,jdk1.7增加了动态类型语言的支持.</span><br><span class="line">    类型                            标志                                描述</span><br><span class="line">    CONSTANT_Utf8_info              1                       UTF-8编码的字符串(既不是字面量，也不是符号引用,相当于一个工具)</span><br><span class="line">    CONSTANT_Integer_info           3                       整形字面量</span><br><span class="line">    CONSTANT_Float_info             4                       浮点型字面量</span><br><span class="line">    CONSTANT_Long_info              5                       长整型字面量</span><br><span class="line">    CONSTANT_Double_info            6                       双精度浮点型字面量</span><br><span class="line">    CONSTANT_CLass_info             7                       类或接口的符号引用</span><br><span class="line">    CONSTANT_String_info            8                       字符串类型字面量</span><br><span class="line">    CONSTANT_Fieldref_info          9                       字段的符号引用</span><br><span class="line">    CONSTANT_Methodref_info         10                      类中方法的符号引用</span><br><span class="line">    CONSTANT_InterfaceMethodref_info11                      接口中方法的符号引用</span><br><span class="line">    CONSTANT_NameAndType_info       12                      字段或方法的部分符号引用</span><br><span class="line">    CONSTANT_MethodHandle_info      15                      方法句柄</span><br><span class="line">    CONSTANT_MethodType_info        16                      方法类型</span><br><span class="line">    CONSTANT_InvokeDynamic_info     18                      动态方法调用点.</span><br></pre></td></tr></table></figure>
<h4 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.access_flags是u2数据结构.</span><br><span class="line">2.访问标志表.</span><br><span class="line">   标志名称                            含义</span><br><span class="line">   ACC_PUBLIC                         public</span><br><span class="line">   ACC_FINAL                          fianl</span><br><span class="line">   ACC_SUPER                          invokespecial</span><br><span class="line">   ACC_INTERFACE                      接口</span><br><span class="line">   ACC_ABSTRACT                       抽象</span><br><span class="line">   ACC_SYNTHETIC不                    是由用户代码生成的</span><br><span class="line">   ACC_ANNOTATION                     注解</span><br><span class="line">   ACC_ENUM                           枚举</span><br><span class="line">3.访问标志表的每一项对应于u2的每一位.</span><br></pre></td></tr></table></figure>
<h4 id="类索引-父类索引-接口索引集合"><a href="#类索引-父类索引-接口索引集合" class="headerlink" title="类索引,父类索引,接口索引集合"></a>类索引,父类索引,接口索引集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Class文件由这三项数据(this_class,super_class,interfaces,u2类型)来确定这个类的继承关系.</span><br><span class="line">  this_class --&gt;CONSTANT_Class_info--&gt;CONSTANT_Utf8_info</span><br></pre></td></tr></table></figure>
<h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.字段表用于描述接口或者类中声明的变量.</span><br><span class="line">2.字段包括类变量以及实例级变量,但不包括方法内部声明的局部变量.</span><br><span class="line">3.字段表结构</span><br><span class="line">  access_flags(字段访问标志,u2的数据类型.),name_index(简单名称),descriptor_index(字段描述符索引),attribute_count,attributes.</span><br><span class="line">4.字段访问标志</span><br><span class="line">   ACC_PUBLIC</span><br><span class="line">   ACC_PRIVATE</span><br><span class="line">   ACC_PROTECTED</span><br><span class="line">   ACC_STATIC</span><br><span class="line">   ACC_FINAL                   可变性</span><br><span class="line">   ACC_VOLATILE                可见性</span><br><span class="line">   ACC_TRANSIENT               序列化</span><br><span class="line">   ACC_SYNTHETIC               编译器自动产生</span><br><span class="line">   ACC_ENUM                    是否enum</span><br><span class="line">5.描述符的作用是用来描述字段的数据类型,方法的参数列表(数量,类型,顺序)和返回值.</span><br><span class="line">例子:</span><br><span class="line">     [[Ljava&#x2F;lang&#x2F;Object ----&gt; Object[][]</span><br><span class="line">     B                   ----&gt; byte</span><br><span class="line">    ([CII[CIII)I         ----&gt; int indexOf(char[]source,int sourceOffset,int sourceCount,char[]target,int targetOffset,int targetCount,int fromIndex);</span><br><span class="line">6.字段的属性表</span><br><span class="line">   例如: final static int m&#x3D;123;  该字段会存在一个ConstantValue的属性,属性值为123.</span><br><span class="line">7.字段表集合不会列出从超类或者父接口继承而来的字段.</span><br><span class="line">8.字段表可能会列出原本java代码之中不存在的字段.</span><br><span class="line">  例如:内部类添的字段表亦添加外部类的字段.</span><br><span class="line">9.对于byte code而言,如果两个字段的描述符不一致,那字段重名是合法的.</span><br></pre></td></tr></table></figure>
<h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">1.方法表结构.</span><br><span class="line">  access_flags,name_index,descriptor_index,attributes_count,attributes.</span><br><span class="line">2.方法表的访问标志.</span><br><span class="line">   ACC_PUBLIC   </span><br><span class="line">   ACC_PRIVATE</span><br><span class="line">   ACC_PROTECTED</span><br><span class="line">   ACC_STATIC</span><br><span class="line">   ACC_FINAL</span><br><span class="line">   ACC_SYNCHRONIZED          方法是否是synchronized.</span><br><span class="line">   ACC_BRIDGE                方法是否是桥接.</span><br><span class="line">   ACC_VARARGS               方法是否是不定参数.</span><br><span class="line">   ACC_NATIVE                本地方法.</span><br><span class="line">   ACC_ABSTRACT              方法是否是抽象方法.</span><br><span class="line">   ACC_STRICTFP              方法是否是strictfp.</span><br><span class="line">   ACC_SYNTHETIC             方法是否由编译器产生的.</span><br><span class="line">3.方法里的Java代码经过compiler编译生成字节码指令后,放在方法属性表的一个名为code的属性里面.</span><br><span class="line">4.方法表集合不会出现来自父类的方法(重写的方法会出现).</span><br><span class="line">5.方法表可能会出现编译器自动添加的方法.</span><br><span class="line">  比如:类构造器&lt;clinit&gt;和实例构造器&lt;init&gt;.</span><br><span class="line">6.在class文件中,只要描述符不同的方法就可以共存(和java层面不同).</span><br><span class="line">  Java的方法签名: 方法参数数量,顺序,类型</span><br><span class="line">  方法描述符(descriptor):(方法参数数量,顺序,类型)+返回值类型+受查异常表.</span><br><span class="line">举个例子:</span><br><span class="line">    public String test(List&lt;String&gt;ss)&#123;</span><br><span class="line">                return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public String test(List&lt;Integer&gt;ss)&#123;</span><br><span class="line">                return null;</span><br><span class="line">    &#125;</span><br><span class="line">修改成</span><br><span class="line">    public String test(List&lt;String&gt;ss)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    public Integer test(List&lt;Integer&gt;ss)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">在idea和eclipse上实验似乎都不能.</span><br></pre></td></tr></table></figure>
<h4 id="方法表与常量池的方法符号引用-字段表与常量池字段符号引用"><a href="#方法表与常量池的方法符号引用-字段表与常量池字段符号引用" class="headerlink" title="方法表与常量池的方法符号引用,字段表与常量池字段符号引用"></a>方法表与常量池的方法符号引用,字段表与常量池字段符号引用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法表:当前类的所有方法.</span><br><span class="line">方法符号引用:引用其它类或当前类的方法.</span><br><span class="line">字段表:当前类的所有字段.</span><br><span class="line">字段符号引用:引用其它类字段或当前类字段.</span><br></pre></td></tr></table></figure>
<h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.在class文件中,字段表和方法表都携带自己的属性表集合,以用于描述某些场景专有的信息.</span><br><span class="line">2.虚拟机规范预定义的属性.</span><br><span class="line">  Code                      Java代码编译生成的字节码指令.</span><br><span class="line">  ConstantValue             final关键字定义的常量值(static final int i&#x3D;4;).</span><br><span class="line">  Deprecated                被声明为deprecated的方法和字段.</span><br><span class="line">  Exceptions                throws后的异常.</span><br><span class="line">  EnclosingMethod           局部类或匿名类用于标识这个类所在的外围方法.</span><br><span class="line">  InnerClasses              内部类和宿主类之间的关系.</span><br><span class="line">  LineNumberTable           Java源码的行号与字节码指令的对应关系(抛出异常时可以找到具体的行号).</span><br><span class="line">  LocalVariableTable        局部变量表与方法本地变量之间的关系.</span><br><span class="line">  StackMapTable             Jdk1.6新增的属性,类型检查验证器(Type Checker)检查和</span><br><span class="line">                            处理目标方法的局部变量和操作数栈所需要的类型是否匹配(操作数栈和局部变量类型).</span><br><span class="line">  Signature                 Jdk1.5中新增的属性,这个属性支持泛型情况下的方法签名.</span><br><span class="line">                            由于Java的泛型采用擦除法实现.为了避免类型信息被擦除后导致签名混乱,</span><br><span class="line">                            需要这个属性记录泛型中的相关信息.</span><br><span class="line">  SourceFile                源文件名称.</span><br><span class="line">  SourceDebugExtension      Jdk1.6新增的属性,这个属性用于支持泛型情况下的方法签名.</span><br><span class="line">  Synthetic                 标识方法或字段为编译器自动生成的.</span><br><span class="line">  LocalVariableTypeTable    Jdk1.5新增的属性,它使用特征签名代替描述符.是为了引入泛型语法后能描述泛型参数化类型而添加.</span><br><span class="line">  RuntimeVisibleAnnotations            Jdk1.5新增的属性,为动态注解提供支持.</span><br><span class="line">                            RuntimeVisibleAnnotations属性用来说明哪些注解是运行时可见的.</span><br><span class="line">  RuntimeInvisbleAnnotations Jdk1.5新增的属性,与上一个属性作用相反.</span><br><span class="line">  RuntimeVisibleParameterAnnotations  运行时注解(s),作用对象为方法参数.</span><br><span class="line">  RuntimeInvisibleParameterAnnotations</span><br><span class="line">  AnnotationDefault         JDK1.5中新增的属性,用于记录注解类元素的默认值.</span><br><span class="line">  BootstrapMethods          Jdk1.7中新增的属性,用于保存invokedynamic指令引用的指导方法限定符.</span><br></pre></td></tr></table></figure>
<h4 id="code属性"><a href="#code属性" class="headerlink" title="code属性"></a>code属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.code属性表的结构</span><br><span class="line">  attribute_name_index  ---&gt;CONSTANT_Utf8_info(&quot;Code&quot;).</span><br><span class="line">  attribute_length</span><br><span class="line">  max_stack             ---&gt;操作数栈最大深度.</span><br><span class="line">  max_locals            ---&gt;局部变量表最大深度.</span><br><span class="line">  code_length                                    </span><br><span class="line">  code                  ---&gt;byte code指令</span><br><span class="line">  exception_table_length</span><br><span class="line">  exception_table       ---&gt;异常表 try catch</span><br><span class="line">  attributes_count</span><br><span class="line">  attributes</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * java 代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> com.vicyor.blog.apps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> field;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> field + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成的字节码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">vicyor</span>.<span class="title">blog</span>.<span class="title">apps</span>.<span class="title">TestClass</span></span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#18         // java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">   #2 = Fieldref           #3.#19         // com/vicyor/blog/apps/TestClass.field:I</span><br><span class="line">   #3 = Class              #20            // com/vicyor/blog/apps/TestClass</span><br><span class="line">   #4 = Class              #21            // java/lang/Object</span><br><span class="line">   #5 = Utf8               field</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/vicyor/blog/apps/TestClass;</span><br><span class="line">  #14 = Utf8               inc</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               SourceFile</span><br><span class="line">  #17 = Utf8               TestClass.java</span><br><span class="line">  #18 = NameAndType        #7:#8          // "&lt;init&gt;":()V</span><br><span class="line">  #19 = NameAndType        #5:#6          // field:I</span><br><span class="line">  #20 = Utf8               com/vicyor/blog/apps/TestClass</span><br><span class="line">  #21 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> com.vicyor.blog.apps.TestClass();   构造函数</span><br><span class="line">            descriptor: ()V                                                                                     方法签名</span><br><span class="line">            flags: ACC_PUBLIC                                                                         访问标志符</span><br><span class="line">            Code:</span><br><span class="line">              stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span>                        args_size=<span class="number">1</span>是因为Javac Compiler 编译的时候将<span class="keyword">this</span>关键字访问转为对一个普通方法参数访问,在虚拟机调用方法时候,会自动传入<span class="keyword">this</span>参数</span><br><span class="line">                         <span class="number">0</span>: aload_0                                                                                                <span class="keyword">this</span>入操作数栈</span><br><span class="line">                         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V  父类Object对象构造函数super();</span><br><span class="line">                         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">              LineNumberTable:</span><br><span class="line">                        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line">              LocalVariableTable:</span><br><span class="line">                        Start  Length  Slot  Name   Signature</span><br><span class="line">                                    <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/vicyor/blog/apps/TestClass;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span></span>;</span><br><span class="line">            descriptor: ()I</span><br><span class="line">            flags: ACC_PUBLIC</span><br><span class="line">            Code:</span><br><span class="line">              stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">                         <span class="number">0</span>: aload_0                                                                                                        <span class="keyword">this</span>入操作数栈.</span><br><span class="line">                         1: getfield      #2                  // Field field:I  this.i.     </span><br><span class="line">                         <span class="number">4</span>: iconst_1                                                                                                                                    常量<span class="number">1</span>入栈.</span><br><span class="line">                         <span class="number">5</span>: iadd                                                                                                                                                运算指令.</span><br><span class="line">                         <span class="number">6</span>: ireturn                                                                                                                                                返回returnValue中的值.</span><br><span class="line">              LineNumberTable:</span><br><span class="line">                        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">              LocalVariableTable:</span><br><span class="line">                        Start  Length  Slot  Name   Signature</span><br><span class="line">                                    <span class="number">0</span>       <span class="number">7</span>     <span class="number">0</span>  <span class="keyword">this</span>   Lcom/vicyor/blog/apps/TestClass;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">"TestClass.java"</span></span><br><span class="line"><span class="number">2</span>.异常表</span><br><span class="line">   exception_table                         ---&gt;  start_pc(<span class="keyword">try</span>开始位置),end_pc(<span class="keyword">try</span>结束位置),handler_pc(<span class="keyword">catch</span>开始位置),catch_type(异常捕获类型).</span><br><span class="line">   <span class="number">1</span>.编译器使用异常表而不是简单的跳转命令实现Java异常和<span class="keyword">finally</span>处理机制.</span><br><span class="line">   <span class="number">2</span>.编译器会根据<span class="keyword">try</span> <span class="keyword">catch</span> <span class="keyword">finally</span> 语句块的每种情况后添加<span class="keyword">finally</span>中的指令.</span><br><span class="line">   <span class="number">3</span>.每一种情况:</span><br><span class="line">       <span class="number">1</span>.正常处理后.</span><br><span class="line">       <span class="number">2</span>.<span class="keyword">try</span>里抛出异常,在<span class="keyword">catch</span>后添加<span class="keyword">finally</span>语句.</span><br><span class="line">       <span class="number">3</span>.抛出catchetype之外的异常.</span><br><span class="line">       <span class="number">4</span>.<span class="keyword">catch</span>里抛出异常.</span><br></pre></td></tr></table></figure>
<h4 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Exceptions属性的作用是列举出方法可能抛出的受检查异常.也就是throws关键字后面的异常.</span><br><span class="line">2.Exceptions属性表结构.</span><br><span class="line">  attribute_name_index+attribute+number_of_exceptions_exception_index_table.</span><br></pre></td></tr></table></figure>
<h4 id="LineNumberTable属性"><a href="#LineNumberTable属性" class="headerlink" title="LineNumberTable属性"></a>LineNumberTable属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.LineNumberTable属性用于描述Java源码行号与字节码行号之间的对应关系.</span><br><span class="line">  程序抛出异常时候,堆栈会抛出从出错的行号.</span><br><span class="line">2.LineNumberTable属性结构.</span><br><span class="line">  attribute_name_index+attribute_length+line_number_table_length+line_number_table.</span><br></pre></td></tr></table></figure>
<h4 id="LocalVariableTable属性与LocalVariableTypeTable属性"><a href="#LocalVariableTable属性与LocalVariableTypeTable属性" class="headerlink" title="LocalVariableTable属性与LocalVariableTypeTable属性"></a>LocalVariableTable属性与LocalVariableTypeTable属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.LocalVariableTable描述栈帧中的局部变量表和Java源码中定义的变量之间的关系.</span><br><span class="line">2.-g:none,-g:vars可以取消这项信息.</span><br><span class="line">  若没有生成这项属性,最大的影响就是当其它人引用这个方法时候,所有的参数名称就会丢失.</span><br><span class="line">3.LocalVariableTable属性结构.</span><br><span class="line">  attribute_name_index</span><br><span class="line">  attribute_length</span><br><span class="line">  local_variable_table_length</span><br><span class="line">  local_variable_table(n)            ----&gt;  start_pc(变量作用域) +length+name_index(变量名索引)+descriptor_index(描述符索引)+index</span><br><span class="line">4.LocalVariableTypeTable</span><br><span class="line">  为了适应JDK1.5出现的泛型,添加了LocalVariableTypeTable这个属性表.</span><br><span class="line">  LocalVariableTypeTable是将LocalVariableTable的desciptor(描述符)换成了signature(特征签名).</span><br></pre></td></tr></table></figure>
<h4 id="ConstantValue属性"><a href="#ConstantValue属性" class="headerlink" title="ConstantValue属性"></a>ConstantValue属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.ConstantValue属性作用是通知虚拟机自动为静态变量（static)赋值.</span><br><span class="line">2.静态变量的赋值有两种方式.</span><br><span class="line">    1.&lt;clinit&gt;.</span><br><span class="line">    2.ConstantValue.</span><br><span class="line">3.ConstantValue作用的静态变量的条件.</span><br><span class="line">    1.基本数据类型+String(ps:因为就它们有字面量). </span><br><span class="line">    2.有final修饰.</span><br></pre></td></tr></table></figure>
<h4 id="Synthetic属性"><a href="#Synthetic属性" class="headerlink" title="Synthetic属性"></a>Synthetic属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.Synthetic属性代表字段和方法不是由Java源码直接产生的,而是由编译器自行添加的.</span><br><span class="line">2.jdk1.5后亦可以设置acc_flags的ACC_SYNTHETIC标志位.</span><br><span class="line">3.最典型的是桥接方法.</span><br><span class="line">  桥接方法是JDK1.5引入泛型后,为了使得JAVA的泛型方法生成的字节码和之前未引入泛型的版本兼容,</span><br><span class="line">  由编译器自动生成的方法.</span><br></pre></td></tr></table></figure>
<h4 id="Signature属性"><a href="#Signature属性" class="headerlink" title="Signature属性"></a>Signature属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Jdk1.5添加的属性,可出现于字段表,方法表,类的属性表结构中.</span><br><span class="line">2.Signature属性会记录泛型签名信息.</span><br><span class="line">3.由于泛型擦除,泛型信息可能会在运行时丢失.</span><br><span class="line">  Signature记录泛型信息,可以通过运行时反射获取.</span><br></pre></td></tr></table></figure>
<h4 id="BootStrapMethods属性"><a href="#BootStrapMethods属性" class="headerlink" title="BootStrapMethods属性"></a>BootStrapMethods属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.BootStrapMethods属性在JDK1.7发布后用于保存invokedynamic指令引用的引导方法限定符.</span><br><span class="line">2.&lt;JAVA虚拟机规范&gt;规定,若某个类文件结构的常量池曾经出现过CONSTANT_InvokeDynamic_info类型的常量.</span><br><span class="line">  那么类文件的属性表必须存在一个明确的BootStrapMethods属性.</span><br><span class="line">            CONSTANT_InvokeDynamic_info与BootStrapMethods是多对一的关系.</span><br><span class="line">3.BootStrapMethods属性结构.</span><br><span class="line">  BootStrapMethods ---&gt;</span><br><span class="line">        attribute_name_index,attribute_length,num_bootstrap_methods,bootstrap_methods.</span><br><span class="line">  bootstrap_method ---&gt; </span><br><span class="line">        bootstrap_method_ref (CONSTANT_MethodHandle)</span><br><span class="line">        num_bootstrap_arguments</span><br><span class="line">        bootstrap_arguments[] (boostrap的参数数量)</span><br></pre></td></tr></table></figure>
<h3 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.JVM的指令由操作码(一个字节,OPCode)和操作数(可能多个,一般指令没有操作数Operands).</span><br><span class="line">2.Java虚拟机的解释器的执行模型.</span><br><span class="line">  do&#123;</span><br><span class="line">     自动计算PC寄存器的值+1;</span><br><span class="line">     根据PC寄存器的指示位置,从字节码流中取出操作码;</span><br><span class="line">     if(字节码存在操作数) 从字节码中取出操作数;</span><br><span class="line">     执行字节码指令;</span><br><span class="line">  &#125;while(字节码流长度&gt;0);</span><br></pre></td></tr></table></figure>
<h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.局部变量到操作栈.</span><br><span class="line">  iload,iload_&lt;n&gt;,lload,lload_&lt;n&gt;,fload,fload_&lt;n&gt;,dload,dload_&lt;n&gt;,aload(引用),aload_&lt;n&gt;;</span><br><span class="line">2.操作栈到局部变量.</span><br><span class="line">  istore.....</span><br><span class="line">3.将一个常量加载到操作数栈.</span><br><span class="line">  bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_m1,iconst_&lt;i&gt;,lconst_&lt;l&gt;,fconst_&lt;f&gt;,dconst&lt;d&gt;.</span><br></pre></td></tr></table></figure>
<h4 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">加法: iadd,ladd,fadd,dadd</span><br><span class="line">减法: isub,lsub,fsub,dsub</span><br><span class="line">乘法: imul,lmul,fmul,dmul</span><br><span class="line">除法: idiv,ldiv,fdiv,ddiv</span><br><span class="line">求余: irem,lrem,frem,drem</span><br><span class="line">取反: ineg,lneg,fneg,dneg</span><br><span class="line">位移: ishl,ishr,iushr,lshl,lshr,lushr</span><br><span class="line">按位或: ior,lor</span><br><span class="line">按位与: iand,land</span><br><span class="line">按位异或: ixor,lxor</span><br><span class="line">局部变量自增: iinc</span><br><span class="line">比较指令: dcmpg,dcmpl,fcmpg,fcmpl,lcmp</span><br></pre></td></tr></table></figure>
<h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.宽化类型转换(隐式类型转换).</span><br><span class="line">  int   ---&gt; long,float,double</span><br><span class="line">  long  ---&gt; float,double</span><br><span class="line">  float ---&gt; double</span><br><span class="line">2.窄式类型转换.</span><br><span class="line">  i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f.</span><br><span class="line">  转换可能导致精度,正负号(128转byte)等问题.</span><br><span class="line">  精度---&gt;丢弃低位导致的.</span><br><span class="line">  正负号---&gt;取余导致的.</span><br></pre></td></tr></table></figure>
<h4 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.创建类实例指令: new.</span><br><span class="line">2.创建数组指令:  newarray,anewarray,multianewarray.</span><br><span class="line">3.访问类字段: getfield,putfield,getstatic,putstatic.</span><br><span class="line">4.将一个数组元素加载到操作数栈的指令:baload,caload,saload,iaload,laload,faload,daload,aaload.</span><br><span class="line">5.将一个操作数栈的值存到数组元素中的指令.</span><br><span class="line">  bastore,castore,sastore,iastore,fastore,dastore,aastore.</span><br><span class="line">6.取数组长度指令: arraylength.</span><br><span class="line">7.检查类实例类型的指令: instanceof,checkeast.</span><br></pre></td></tr></table></figure>
<h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.出栈: pop ,pop2(2个元素).</span><br><span class="line">2.栈顶复制: dup,dup2,,dup_x1,dup2_x1,dup_x2,du2_x2.</span><br><span class="line">3.栈顶的两个元素互换: swap.</span><br></pre></td></tr></table></figure>
<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.条件分支: ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpne,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne.</span><br><span class="line">2.复合条件分支: tableswitch,lookupswitch</span><br><span class="line">3.无条件分支: goto,goto_w,jsr,jsr_w,ret.</span><br><span class="line">  对于boolean,byte,char,short都是最终转成int类型的比较指令完成的.</span><br><span class="line">  对于long,float,double指令,会执行相对应的类型比较运算指令(dcmpg,dcmpl,fcmpg,fcmpl,lcmp).</span><br></pre></td></tr></table></figure>
<h4 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.方法调用指令.</span><br><span class="line">  invokevirtual. 对象的实例方法.根据对象实际类型进行分派(虚方法分派,动态单分派).</span><br><span class="line">  invokeinterface. 调用接口方法.</span><br><span class="line">  invokespecial.  调用一些特殊的实例方法.包括&lt;init&gt;,&lt;clinit&gt;,父类未被重写方法.</span><br><span class="line">  invokestatic.   调用类方法.</span><br><span class="line">  invokedynamic.  运行时动态解析调用点限定符所引用的方法(bootstrap-method).</span><br><span class="line">2.方法返回指令.</span><br><span class="line">  方法返回指令,结果压栈.</span><br><span class="line">  ireturn,freturn,dreturen,areturn,return(Void类型).</span><br></pre></td></tr></table></figure>
<h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. athrow(a指对象).</span><br><span class="line">2.java虚拟机中,处理异常(catch)不是由字节码指令完成的,而是用异常表完成的.</span><br></pre></td></tr></table></figure>
<h4 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.synchronized是使用管程(Monitor)实现的.</span><br><span class="line">2.方法级别的同步时隐式(不用monitorenter指令)的.</span><br><span class="line">  在虚拟机调用方法时,方法表的访问标志(ACC_SYNCHRONIZED为true)声明该方法是同步方法.</span><br><span class="line">  执行同步方法,必须要先获取管程(Monitor),方法执行结束后或抛出异常都会释放管程.</span><br><span class="line">3.monitorenter,monitorexit</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* 源码</span><br><span class="line">*&#x2F;</span><br><span class="line">void onlyMe(Foo f) &#123;</span><br><span class="line">            synchronized (f) &#123;</span><br><span class="line">                        doSomething();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 字节码</span><br><span class="line"> *&#x2F;</span><br><span class="line">void onlyMe(com.vicyor.blog.apps.Foo);</span><br><span class="line">descriptor: (Lcom&#x2F;vicyor&#x2F;blog&#x2F;apps&#x2F;Foo;)V</span><br><span class="line">flags:</span><br><span class="line">Code:</span><br><span class="line">  stack&#x3D;2, locals&#x3D;4, args_size&#x3D;2</span><br><span class="line">             0: aload_1                                                                                     &#x2F;&#x2F;f入栈</span><br><span class="line">             1: dup                                                                                                 &#x2F;&#x2F;复制栈顶元素</span><br><span class="line">             2: astore_2                                                                         &#x2F;&#x2F;栈顶(f)---&gt;slot 2</span><br><span class="line">             3: monitorenter                                                             &#x2F;&#x2F;以栈顶f为锁,开始同步</span><br><span class="line">             4: aload_0                                                                                     &#x2F;&#x2F;this入栈</span><br><span class="line">             5: invokevirtual #3                  &#x2F;&#x2F; Method doSomething:()V</span><br><span class="line">             8: aload_2                                                                                      &#x2F;&#x2F;slot 2(f) 入栈</span><br><span class="line">             9: monitorexit                                                                          &#x2F;&#x2F;退出同步</span><br><span class="line">            10: goto          18                                                  &#x2F;&#x2F;跳转return</span><br><span class="line">            13: astore_3                                                                          &#x2F;&#x2F;异常表 13-16 异常-----&gt;slot 3</span><br><span class="line">            14: aload_2                                                                                      &#x2F;&#x2F;slot 2(f) 入栈</span><br><span class="line">            15: monitorexit                                                                          &#x2F;&#x2F;退出同步</span><br><span class="line">            16: aload_3                                                                                      &#x2F;&#x2F;异常入栈</span><br><span class="line">            17: athrow                                                                                      &#x2F;&#x2F;抛出异常</span><br><span class="line">            18: return                                                                                      &#x2F;&#x2F;方法出口</span><br><span class="line">  Exception table:</span><br><span class="line">             from    to  target type</span><br><span class="line">                         4    10    13   any</span><br><span class="line">                        13    16    13   any</span><br></pre></td></tr></table></figure>
<h2 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h2><h3 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">      连接(Linking)</span><br><span class="line">加载,(验证,准备,(解析)),初始化,使用,卸载.</span><br></pre></td></tr></table></figure>
<h4 id="何时触发类的初始化-initialization-操作"><a href="#何时触发类的初始化-initialization-操作" class="headerlink" title="何时触发类的初始化(initialization)操作."></a>何时触发类的初始化(initialization)操作.</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.new,getstatic,putstatic,invokestatic指令.</span><br><span class="line">  getstatic(如果有ConstantValue属性的除外).</span><br><span class="line">2.java.lang.reflect包的方法对类进行反射调用的时候.</span><br><span class="line">3.子类初始化时触发父类初始化.</span><br><span class="line">  ps:子接口不会触发父接口初始化.</span><br><span class="line">4.主类初始化(含有main方法的类).</span><br><span class="line">5.Jdk1.7动态类型语言支持.</span><br><span class="line">  java.lang.invoke.MethodHandle实例----&gt;REF_getStatic,REF_putStatic,REF_invokeStatic 方法句柄.</span><br><span class="line">  方法句柄对应的类没有进行初始化,则需要先触发其初始化.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过子类 getstatic 获取父类的字段,不会触发子类的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">            <span class="keyword">static</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"SuperClass init !"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span></span>&#123;</span><br><span class="line">            <span class="keyword">static</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"SubClass init !"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">                        <span class="comment">//不会触发子类的初始化</span></span><br><span class="line">                        System.out.println(SubClass.value);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * new 数组 不会触发数组元素的初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">                        SuperClass[]sca=<span class="keyword">new</span> SuperClass[<span class="number">10</span>];   </span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ConstantValue属性  亦不会触发初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstClass</span></span>&#123;</span><br><span class="line">            <span class="keyword">static</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"ConstClass init"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD=<span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotInitialization</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">                        System.out.println(ConstClass.HELLOWORLD);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.加载时类加载的第一个阶段.</span><br><span class="line">  加载阶段,虚拟机需要完成的三个事情.</span><br><span class="line">   1.通过类的全限定名获取定义类的二进制字节流.</span><br><span class="line">   2.将这个字节流代表的静态存储结构转化为方法区的运行时数据结构.</span><br><span class="line">   3.在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口.</span><br><span class="line">     对于HotSpot虚拟机而言,Class对象比较特殊,虽然它是对象,但是存放在方法区里面(P215).</span><br><span class="line">2.各种各样的加载方式.</span><br><span class="line">  1.从ZIP包中获取Class文件(JAR,EAR,WAR格式).</span><br><span class="line">  2.从网络中获取,Applet.</span><br><span class="line">  3.运行时计算生成,动态代理技术.ProxyGenerator.generateProxyClass.</span><br><span class="line">  4.由其它文件生成,例如JSP应用,由JSP文件生成对应的Class类.</span><br><span class="line">  5.从数据库中读取,中间件服务器(SAP Netweaver).</span><br><span class="line">3.数组类的加载.</span><br><span class="line">   1.数组类的组件类型(Component Type)是引用类型的话,那就用ApplicationClassLoader去加载那个Component Type.</span><br><span class="line">     类加载器加载ComponentType后, 数组会在类加载器的类命名空间上被标记.</span><br><span class="line">   2.数组类的组件类型不是引用类型的话,数组会在bootstrap classloader的类名称空间上被标记.</span><br></pre></td></tr></table></figure>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.文件格式验证. Class文件规范.</span><br><span class="line">2.元数据验证.  Java语言规范.</span><br><span class="line">3.字节码验证.</span><br><span class="line">4.符号引用验证.</span><br></pre></td></tr></table></figure>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.准备阶段是正式为类变量分配内存并设置类变量初始值的阶段.</span><br><span class="line">  例如:</span><br><span class="line">   private static int i&#x3D;123;</span><br><span class="line">   i在准备阶段会被设为0.</span><br><span class="line">   而赋值语句putstatic会编译在&lt;clinit&gt;方法中.</span><br><span class="line">2.特殊情况:字段有属性ConstantValue,那么字段就会在准备阶段初始化为ConstantValue属性指定的值.</span><br><span class="line">  private static final int i&#x3D;123;</span><br></pre></td></tr></table></figure>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.解析阶段是虚拟机将符号引用替换成直接引用的过程.</span><br><span class="line">  符号引用(Symbolic Reference): CONSTANT_Class_info,CONSTANT_Fieldref_info,CONSTANT_Methodref_info.</span><br><span class="line">     符号引用以一组符号来描述所引用的目标,符号可以是任何形式的字面量,只要使用时能无歧义的定位到目标即可.</span><br><span class="line">  直接引用:</span><br><span class="line">    直接引用可以是直接指向目标的指针,相对偏移量或一个能间接定位到目标的句柄.  </span><br><span class="line">2.类和接口的解析.</span><br><span class="line">  CONSTANT_Class_info,根据类的全限定名加载类(父类,接口,父类字段,接口字段..).</span><br><span class="line">  如果是数组,虚拟机会生成一个代表数组维度和元素的数组对象.</span><br><span class="line">3.字段的解析.</span><br><span class="line">  1.先解析class_index对应的CONSTANT_Class_info.</span><br><span class="line">  2.搜索字段(找到即返回).</span><br><span class="line">    1.从当前类字段表里找.</span><br><span class="line">    2.从接口,按继承关系从下到上寻找.</span><br><span class="line">    3.从超类中查找,按继承关系.</span><br><span class="line">    4.若找不到,抛出java.lang.NoSuchFieldException.</span><br><span class="line">4.类方法的解析.</span><br><span class="line">  1.根据方法的class_index去解析类.</span><br><span class="line">  2.搜索方法(找到即返回).</span><br><span class="line">    1.当前类方法表.</span><br><span class="line">    2.接口</span><br><span class="line">    3.父类,从下往上</span><br><span class="line">    4.若找不到,抛出java.lang.NoSuchMethodError.</span><br><span class="line">5.接口方法的解析.</span><br><span class="line">  1.判断class_index中的索引C是不是接口,若不是,抛出java.lang.IncompatibleClassChangeError.</span><br><span class="line">  2.搜索方法.</span><br><span class="line">    1.在接口C中查找.</span><br><span class="line">    2.在接口C的父接口中递归查找(从下往上查找).</span><br><span class="line">    3.找不到,抛出java.lang.NoSuchMethodError.</span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.初始化阶段是执行类构造器&lt;clinit&gt;的过程.</span><br><span class="line">2.父类的clinit方法会在父类的类加载过程中执行,所以clinit没有类时super的操作.</span><br><span class="line">3.&lt;clinit&gt;方法是编译器自动收集类中所有类变量的赋值动作和相关的静态语句块合并产生的.</span><br><span class="line">  编译器的收集的顺序是由语句在源文件中出现的顺序决定的.</span><br></pre></td></tr></table></figure>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.通过一个类的全限定名(Fully Qualified Name)获取描述此类的二进制字节流.</span><br><span class="line">2.类加载器起初是为了满足Java Applet的需求开发出来的.</span><br><span class="line">  应用于OSGi,热部署,代码加密等领域.</span><br></pre></td></tr></table></figure>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.对于任意一个类,都需要类加载器与类本身一同确定其在Java虚拟机的唯一性.</span><br><span class="line">2.类加载器拥有一个独立的类名称空间(namespace).</span><br><span class="line">  类名称空间里存放着这个类加载器所加载的所有类.</span><br><span class="line">3.比较两个类是否相等,只有两个类是由同一个类加载器(classloader&#39;s namespace)加载的前提下才有意义.</span><br><span class="line">  比较两个类的方法:</span><br><span class="line">   Class.equals();Class.isAssignableFrom();CLass.isInstance();</span><br><span class="line">    语法糖</span><br><span class="line">    a instanceof A</span><br></pre></td></tr></table></figure>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.从Java虚拟机角度,只存在两种不同的类加载器.</span><br><span class="line">  Bootstrap ClassLoader C++语言实现的.</span><br><span class="line">  所有其它的类加载器.  Java语言实现的.继承抽象类Java.lang.ClassLoader</span><br><span class="line">2.三种系统提供的类加载器.</span><br><span class="line">  1.启动类加载器 BootStrap ClassLoader ---&gt; &lt;JAVA_HOME&gt;\lib</span><br><span class="line">  2.扩展类加载器 Extension ClassLoader ---&gt; &lt;JAVA_HOME&gt;\lib\ext</span><br><span class="line">  3.应用程序加载器 Application ClassLoader ---&gt; ClassPath</span><br><span class="line">3.双亲委派模型:</span><br><span class="line">  一个类加载器加载某个类,会先委派给父类加载器去完成,</span><br><span class="line">  只有当父类加载器反馈无法完成这个加载请求,子类加载器才会尝试自己去加载.</span><br><span class="line">4.从上往下加载原因: 避免重复加载类.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *             java.lang.ClassLoader  ---&gt; 模板模式</span></span><br><span class="line"><span class="comment"> *  ClassLoader.loadClass源码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">                        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">                        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">                        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                                    <span class="keyword">try</span> &#123;</span><br><span class="line">                                                <span class="comment">//双亲委派</span></span><br><span class="line">                                                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                            c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                                            c = findBootstrapClassOrNull(name);</span><br><span class="line">                                                &#125;</span><br><span class="line">                                    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                                                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                                                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                                                <span class="comment">// to find the class.</span></span><br><span class="line">                                                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                                                <span class="comment">//调用自定义的findClass方法</span></span><br><span class="line">                                                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                                                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                                                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                                                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                                                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                                    &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//加载后 linking步骤的最后一步解析(符号引用转直接引用),并会触发类初始化.默认resolve为false.</span></span><br><span class="line">                        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                                    resolveClass(c);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">5.破坏双亲委派的方式</span><br><span class="line">  原理:重写ClassLoader.loadClass方法</span><br><span class="line">  3次较大规模的破坏双亲委派模型.</span><br><span class="line">   1.JDK1.2之前不存在双亲委派模型,都是重写loadClass方法.</span><br><span class="line">   2.JNDI服务.Java Name And Directory Interface.</span><br><span class="line">     JNDI需要独立厂商实现部署应用程序的ClassPath下的JNDI接口提供者(SPI service provider interface)的代码.</span><br><span class="line">     但是SPI的接口是由BootStrapClassLoader加载的,而接口对应的实现BootstrapClassLoader加载不了.</span><br><span class="line">     优雅的解决方案: Thread Context ClassLoader. 可以通过java.lang.Thread.setContextClassLoader方法进行设置.</span><br><span class="line">     JDNI的例子:</span><br><span class="line">      java.sql.Driver ----&gt; com.mysql.cj.jdbc.Driver</span><br><span class="line">                                                              ----&gt; oracle.jdbc.driver.OracleDriver</span><br><span class="line">   3.用户对程序动态性的追求,动态性:热替换(HotSwap),热模块部署(HotDeployment).</span><br><span class="line">     每一个程序模块(OSGi称为Bundle)都有一个类加载器,当更换一个Bundle时候,就把Bundle连同类加载器一起替换掉.</span><br></pre></td></tr></table></figure>
<h4 id="ClassLoader-loadClass与Class-forName区别"><a href="#ClassLoader-loadClass与Class-forName区别" class="headerlink" title="ClassLoader.loadClass与Class.forName区别"></a>ClassLoader.loadClass与Class.forName区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.loadClass(name) ----&gt;loadClass(name,false) &#x2F;&#x2F;不会对类进行解析和初始化操作</span><br><span class="line">Class.forName ----&gt; caller&#x3D;Reflection.getCallerClass(); &#x2F;&#x2F;会对类进行初始化操作</span><br><span class="line">                    return forName0(className,initialize:true,ClassLoader.getClassLoader(caller),caller);</span><br></pre></td></tr></table></figure>
<h2 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 虚拟机字节码执行引擎"></a>第八章 虚拟机字节码执行引擎</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.虚拟机与物理机.</span><br><span class="line">  物理机的执行引擎是直接建立在处理器上,硬件,指令集,操作系统层面.</span><br><span class="line">  虚拟机的执行引擎是由虚拟机自己实现的.</span><br><span class="line">2.Java虚拟机的执行引擎: 输入的是字节码文件,处理过程是字节码解析的等效过程,输出的是执行结果.</span><br></pre></td></tr></table></figure>
<h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><h4 id="运行时栈帧结构-1"><a href="#运行时栈帧结构-1" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.栈帧存储了方法的局部变量表(Local variable Table),操作数栈(Operand Stack),动态连接(Dynamic Linking),方法返回地址(Return Address).</span><br><span class="line">  每一方法从调用开始到执行完成的过程,对应一个栈帧在虚拟机里面入栈到出栈的过程.</span><br><span class="line">2.Code属性记录当前栈帧,局部变量表的阈值.</span><br><span class="line">3.位于线程栈顶的栈帧称为当前栈帧(Current Stack Frame).这个栈帧相关联的方法称为当前方法.</span><br></pre></td></tr></table></figure>
<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.局部变量表(Local Variable Table)是一组变量值存储空间,用于存储方法参数和局部定义的变量.</span><br><span class="line">2.局部变量表以变量槽(Variable Slot)为最小单位,</span><br><span class="line">  每个slot能过存放boolean,byte,char,short,int,float,reference,returnAddress(很久以前的jdk版本用).</span><br><span class="line">3.由于实例方法会默认传入this作为第0个参数,所以局部变量表的第0个slot为this.</span><br><span class="line">4.为了尽可能节省栈帧空间,局部变量表的slot是可以重用的.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释的2条语句不加  的话是不会被回收的,因为局部变量表采取的是覆盖策略,不是删除策略.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">            &#123;</span><br><span class="line">                        <span class="keyword">byte</span>[]placeholder=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">                        <span class="comment">//placeholder=null;  //清空  </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//int i=1;  //覆盖</span></span><br><span class="line">            </span><br><span class="line">            System.gc();</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5.手动将变量设置为null是极特殊情形下的奇技.</span><br><span class="line">  特殊情形: 对象占用内存大,此方法的栈帧长时间不能回收(可能阻塞住了),方法调用次数达不到JIT的编译条件.</span><br><span class="line">  JIT编译器会把obj&#x3D;null;给消除掉.</span><br><span class="line">  JIT编译器将字节码编译成本地代码后,GCRoots的枚举与解释执行有着巨大差别,在&#123;&#125;语句块结束后,不需要为语句块内的obj赋null,亦可以对其清除.</span><br><span class="line">6.局部变量没有准备阶段(赋系统初值).</span><br><span class="line">  未赋值的变量不能使用.</span><br></pre></td></tr></table></figure>
<h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.操作数栈(Operand Stack)也叫操作栈,它是一个后入先出的栈(LIFO).</span><br><span class="line">2.在方法的执行过程中,会有各种字节码指令往操作栈中写入和提取内容,也就是出栈&#x2F;入栈操作.</span><br><span class="line">3.在算术运时候通过操作数栈进行,调用其它方法时候是通过操作数栈进行参数传递的.</span><br><span class="line">4.操作数栈的数据类型必须与字节码指令的序列严格匹配.</span><br></pre></td></tr></table></figure>
<h4 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.每一个栈帧都有指向运行时常量池中该方法(栈帧的方法)的符号引用,符号引用只为了支持方法调用过程的动态连接.</span><br><span class="line">2.静态解析和动态连接</span><br><span class="line">  静态解析: 在类加载的解析阶段将符号引用转为直接引用.</span><br><span class="line">           主要包括静态方法和私有方法. invokestatic和invokespecial指令. invokevirtual的方法access_flag有final.</span><br><span class="line">  动态连接: 在(运行期间)将符号引用转为直接引用.</span><br></pre></td></tr></table></figure>
<h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.方法退出的二种方式:</span><br><span class="line">  1.正常完成出口(Normal Method Invocation Completion):执行引擎执行任意一个方法的返回的字节码指令,将返回值传递给上层的方法调用者.</span><br><span class="line">  2.异常完成出口(Abrupt Method Invocation Completion):方法遇到异常,且异常未被catch,不会给上层调用者产生任何返回值.</span><br><span class="line">2.方法正常退出时候,调用者的PC计数器的值可以作为返回地址.</span><br><span class="line">  方法异常退出时候,返回地址通过异常处理器表来确定的,栈帧中一般不会保存这部分信息.</span><br><span class="line">3.方法退出过程:</span><br><span class="line">   1.将当前栈帧出栈.</span><br><span class="line">   2.恢复上层方法的局部变量表和操作数栈.</span><br><span class="line">   3.将返回值压入调用者栈帧的操作数栈中.</span><br><span class="line">   4.调整调用者栈帧的PC计数器指向下一条指令.</span><br></pre></td></tr></table></figure>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.调用目标在程序代码写好,编译器进行编译时就必须确定下来,这类方法的调用称为解析(Resolution).</span><br><span class="line">2.静态解析的方法:</span><br><span class="line">   invokestatic      静态方法.</span><br><span class="line">   invokespecial     init,private,父类未重写方法.</span><br><span class="line">   final修饰的方法    方法不能被重写.</span><br></pre></td></tr></table></figure>
<h4 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.静态多分派.</span><br><span class="line">  方法重载(Method Overload).</span><br><span class="line">  重载方法匹配优先级: char -&gt; int -&gt; long -&gt; float -&gt; double -&gt;Object -&gt; ... (可变参数,匹配数组).</span><br><span class="line">  多分派: 方法的参数和方法的接收者.两个宗量.</span><br><span class="line">2.动态单分派.</span><br><span class="line">  方法重写(Method Override).</span><br><span class="line">  invokevirtual指令第一步在运行期确定接收者的实际类型(根据操作数栈顶元素的实际类型去找方法).</span><br><span class="line">  会在运行期根据类的实际类型将类符号引用解析到对应的类实现.</span><br><span class="line">  单分派: 方法的接收者.一个宗量.</span><br><span class="line">3.虚拟机动态分派的实现.</span><br><span class="line">  动态分派是运行时在类的方法元数据中搜索合适的目标方法,</span><br><span class="line">  Java虚拟机基于性能的考虑,</span><br><span class="line">  1.会为类在方法区建立一个虚方法表(Vritual Method Table,vtable).</span><br><span class="line">  2.同时也会为invokeinterface建立接口方法表(Interface method table,itable).</span><br><span class="line">  ps:vtable和itable是在类加载后就初始化完毕.</span><br></pre></td></tr></table></figure>
<h4 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.Jdk1.7 字节码指令集添加了一名新成员-invokedynamic.</span><br><span class="line">  Jdk1.7实现动态类型语言(Dynamically Typed Language).</span><br><span class="line">  为Jdk1.8顺利实现Lambda表达式技术做准备.</span><br><span class="line">2.动态类型语言.</span><br><span class="line">  动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期.</span><br><span class="line">  常见的动态类型语言: python,ruby,JavaScript.</span><br><span class="line">  静态类型语言: C++,Java.</span><br><span class="line">3.静态类型语言与动态类型语言.</span><br><span class="line">  静态类型语言:对象在编译时候确定其类型(符号引用),编译器可以提供严格的类型检查.</span><br><span class="line">  动态类型语言:对象在运行时候确定其类型,为开发人员提供更大的灵活性.</span><br></pre></td></tr></table></figure>
<h4 id="JDK1-7与动态类型"><a href="#JDK1-7与动态类型" class="headerlink" title="JDK1.7与动态类型"></a>JDK1.7与动态类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.JDK1.7提供了 java.lang.invoke(与java.lang.reflect不同),</span><br><span class="line">  这个包在之前单纯的依靠符号引用确定调用的目标方法之外,</span><br><span class="line">  提供了一种新的动态的确定目标的机制,称为MethodHandle.</span><br><span class="line">2.MethodHandle与C++的Function Pointer和C#的Delegate很像.</span><br><span class="line">  C++:</span><br><span class="line">    动态类型:void sort(int list[],const int size,int(*compare)(int,int));</span><br><span class="line">  Java: </span><br><span class="line">    静态类型: void sort(List list,Comparator c);</span><br><span class="line">    动态类型: void sort(List list,MethodHandle mh);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MethodHandler基础用法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHanleTest</span></span>&#123;</span><br><span class="line">             <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span></span>&#123;</span><br><span class="line">                         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">                                     System.out.println(s);</span><br><span class="line">                         &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                         Object obj=System.currentTimeMillis()%<span class="number">2</span>==<span class="number">0</span>?System.out:<span class="keyword">new</span> ClassA();</span><br><span class="line">                         getPrintInMH(obj).invokeExact(<span class="string">"vicyor"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintInMH</span><span class="params">(Object receiver)</span>throw Throwable</span>&#123;</span><br><span class="line">                         MethodType mt=MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">                         <span class="keyword">return</span> MethodHandles.lookup().findVirtual(receiver.getClass(),<span class="string">"println"</span>,mt).bingTo(receiver);</span><br><span class="line">             &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3.MethodHandle与Reflection机制</span><br><span class="line">  1.Reflection是java代码层次的方法调用,MethodHanle是字节码层次的方法调用.</span><br><span class="line">  2.Reflection的java.lang.reflect.Method对象远比MethodHanle机制的java.lang.invoke.MethodHandle对象所包含的信息多.</span><br><span class="line">    Method ---&gt;方法签名(描述符+泛型),方法描述符,方法属性表.</span><br><span class="line">    MethodHandle ---&gt;指向该方法相关的信息.</span><br><span class="line">  3.MethodHanle是对字节码的方法指令调用的模拟,虚拟机会在这方面做各种优化(如方法内联).</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MethodHandle 调用父类的父类的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span></span>&#123;</span><br><span class="line">                         <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span></span>&#123;</span><br><span class="line">                                     System.out.println(<span class="string">"I am grandfather!"</span>)</span><br><span class="line">                         &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span></span>&#123;</span><br><span class="line">                                    System.out.println(<span class="string">"I am father!"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">Son</span></span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span></span>&#123;</span><br><span class="line">                                    MethodType mt=MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                                    MethodHandle mh=lookup().findSpecial(refc:GrandFather.class,"thinking",mt,specialCaller:getClass());</span><br><span class="line">                                    mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">                        GrandFather gf=<span class="keyword">new</span> Test().<span class="keyword">new</span> Son();</span><br><span class="line">                        gf.thinking(); <span class="comment">//输出 I am grandfather.</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.每一处含有invokedynamic指令的位置称作&quot;动态调用点(Dynamic Call Site)&quot;.</span><br><span class="line">2.invokespecial,invokestatic,invokevirtual,invokeinterface指令的第一个参数是CONSTANT_Methodref_info</span><br><span class="line">  invokedynamic的第一个参数是CONSTANT_InvokeDynamic_info.</span><br><span class="line">  CONSTANT_InvokeDynamic_info ---&gt;</span><br><span class="line">                                 Bootstrap Method (存在BootstrapMethods属性中)</span><br><span class="line">                                 MethodType(方法类型)</span><br><span class="line">                                 名称</span><br><span class="line">3.BootstrapMethod有固定的参数,返回值是java.lang.invoke.CallSite对象.代表真正的目标方法调用.</span><br><span class="line">4.invokedynamic分派逻辑不是由虚拟机决定的,而是由程序员决定的.</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟invokedynamic指令调用</span></span><br><span class="line"><span class="comment"> * invokedynamic 先执行bootstrapmethod获取callsite.</span></span><br><span class="line"><span class="comment"> * 用callsite调用目标方法.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokeDynamicTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"hello string:"</span>+s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *    &lt;1&gt;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CallSite <span class="title">BootstrapMethod</span><span class="params">(MethodHanles.Lookup lookup,String name,MethodType mt)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                        <span class="comment">//会传入类的.  </span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> ConstantCallSite(lookup.findStatic(InvokeDynamicTest<span class="class">.<span class="keyword">class</span>,<span class="title">name</span>,<span class="title">mt</span>))</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * MethodType ----&gt;  上一个方法&lt;1&gt;BootstrapMethod的MethodType.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodType <span class="title">MT_BootstrapMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> MethodType.fromMethodDescriptorString(</span><br><span class="line">                                    <span class="string">"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite"</span>,</span><br><span class="line">                                    <span class="keyword">null</span></span><br><span class="line">                        );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * MethodHandle ----&gt;&lt;1&gt;BootstrapMethod的MethodHandle</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">MH_BootstrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                         return MethodHandles.lookup().findStatic(InvokeDynamicTest.class,"bootstrapMethod",MT_BootstrapMethod()); v   </span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">/**</span></span><br><span class="line"><span class="comment">              * 通过BootstrapMethod的MethodHandle执行BootstrapMethod方法创建allsite.</span></span><br><span class="line"><span class="comment">              * 通过callsite调用testMethod方法</span></span><br><span class="line"><span class="comment">              */</span></span><br><span class="line">             <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">INDY_BootStrapMethod</span><span class="params">()</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                                    CallSite cs=(CallSite)MH_BootstrapMethod().invokeWithArguments(lookup(),<span class="string">"testMethod"</span>,</span><br><span class="line">                                                MethodType.fromMethodDescriptorString(<span class="string">"(Ljava/lang/String;)V"</span>,<span class="keyword">null</span>));</span><br><span class="line">                                    <span class="keyword">return</span> cs.dynamicInvoker();            </span><br><span class="line">             &#125;</span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">                        INDY_BootStrapMethod().invokeExact(<span class="string">"vicyor"</span>);</span><br><span class="line">             &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><h4 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 程序源码  ---&gt; 词法分析 ---&gt; 单词流 ---&gt;语法分析</span><br><span class="line">                                                                                                                          |</span><br><span class="line"> 解释执行 &lt;---  解释器  &lt;--- 指令流 &lt;--- 抽象语法树         java</span><br><span class="line">                                                                                                                          |</span><br><span class="line">目标代码  &lt;--- 生成器 &lt;--- 中间代码            &lt;--- 优化器                      C++</span><br></pre></td></tr></table></figure>
<h4 id="基于栈的指令集和基于寄存器的指令集"><a href="#基于栈的指令集和基于寄存器的指令集" class="headerlink" title="基于栈的指令集和基于寄存器的指令集"></a>基于栈的指令集和基于寄存器的指令集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.Java编译器输出的指令集,基本上是一种基于栈的指令集架构(Instruction Set Architecture ISA).</span><br><span class="line">  指令流中的指令大部分是零地址指令.</span><br><span class="line">  零地址指令: 不存在显示参数的指令.</span><br><span class="line">2.基于寄存器的指令集依赖于寄存器,最典型的就是x86的二进制指令集.</span><br><span class="line">3.举个简单的例子.</span><br><span class="line">  1+1</span><br><span class="line">  基于栈的指令集:</span><br><span class="line">     iconst_1</span><br><span class="line">     iconst_1</span><br><span class="line">     iadd</span><br><span class="line">     istore_0</span><br><span class="line">  基于寄存器的指令集:</span><br><span class="line">     mov eax 1;</span><br><span class="line">     add eax 1;</span><br><span class="line">4.由于程序寄存器不可避免的会受到硬件的约束,基于栈的指令集优点是可移植性.</span><br><span class="line">5.栈架构的指令集的主要缺点是执行速度相对来说会稍微慢一些.</span><br><span class="line">  1.出栈入栈本身产生了相当多的指令数量.</span><br><span class="line">  2.栈是在内存之中,对于处理器而言,访问内存比较慢.</span><br></pre></td></tr></table></figure>
<h2 id="第九章-类加载及执行子系统的案例与实战"><a href="#第九章-类加载及执行子系统的案例与实战" class="headerlink" title="第九章 类加载及执行子系统的案例与实战"></a>第九章 类加载及执行子系统的案例与实战</h2><h3 id="Tomcat-正统的类加载器架构"><a href="#Tomcat-正统的类加载器架构" class="headerlink" title="Tomcat: 正统的类加载器架构"></a>Tomcat: 正统的类加载器架构</h3><h4 id="WEb服务器需要解决的问题"><a href="#WEb服务器需要解决的问题" class="headerlink" title="WEb服务器需要解决的问题"></a>WEb服务器需要解决的问题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.出现问题.</span><br><span class="line">   1.部署在同一台服务器的两个Web应用程序所使用的Java类库可以实现相互隔离(部分).</span><br><span class="line">   2.部署在同一台服务器的两个Web应用程序所使用的Java类库可以实现互相共享(部分).</span><br><span class="line">   3.支持JSP应用的Web服务器,大多数都需要支持HotSwap功能(HotSwap---&gt;热部署).</span><br><span class="line">2.Tomcat解决方式.</span><br><span class="line">   CommonClassLoader    ---&gt;  &#x2F;common</span><br><span class="line">   CatalinaClassLoader  ---&gt;  &#x2F;server</span><br><span class="line">   SharedClassLoader             ---&gt;  &#x2F;shared</span><br><span class="line">   WebAppClassLoader    ---&gt;  &#x2F;WebApp&#x2F;WEB-INF</span><br><span class="line">   JasperLoader                         ---&gt;  jsp文件</span><br><span class="line">HotSwap: 当服务器检测到JSP文件被修改后,会替换掉目前的JasperLoader实例,并通过新建一个Jsp类加载器实现JSP文件的HotSwap功能.</span><br><span class="line">3.Tomcat 6.x 将 &#x2F;common,&#x2F;server,&#x2F;shared三个目录合并成一个&#x2F;lib目录.</span><br><span class="line">4.小问题.</span><br><span class="line">  &#x2F;common目录的接口如何访问&#x2F;WEB-INF&#x2F;lib下的实现?</span><br><span class="line">  ThreadContextClassLoader.</span><br></pre></td></tr></table></figure>
<h3 id="OSGI-灵活的类加载器结构"><a href="#OSGI-灵活的类加载器结构" class="headerlink" title="OSGI:灵活的类加载器结构"></a>OSGI:灵活的类加载器结构</h3><h4 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.Java程序社区流传的一句话: 学习JEE规范,去看JBoss源码.学习类加载器规范,去看OSGi(Open service gateway initiative)源码.</span><br><span class="line">2.OSGI的每个模块(Bundle)与普通的Java类库区别不大.</span><br><span class="line">  内部存储的都是JavaPackage和Class.</span><br><span class="line">3.一个Bundle可以声明它所依赖的Java Package(Import-Package).</span><br><span class="line">   亦可以声明它允许导出发布的JavaPackage(Export-Package).</span><br><span class="line">4.在OSGI,模块之间的依赖由传统的上级模块依赖下级模块的关系转化为平级模块之间的依赖.</span><br><span class="line">5.OSGI可以实现模块的热插拔功能.</span><br><span class="line">6.OSGI的类加载时的查找规则.</span><br><span class="line">  1.以java.*开头的类,由父类加载器加载(ParentClassLoader).</span><br><span class="line">  2.委托列表名单的类,由父类加载器加载.</span><br><span class="line">  3.Import列表的类,由Export这个类的类加载器加载.</span><br><span class="line">  4.其他类由自己的类加载器加载.</span><br></pre></td></tr></table></figure>
<h3 id="字节码生成技术与动态代理的实现"><a href="#字节码生成技术与动态代理的实现" class="headerlink" title="字节码生成技术与动态代理的实现"></a>字节码生成技术与动态代理的实现</h3><h4 id="字节码生成技术"><a href="#字节码生成技术" class="headerlink" title="字节码生成技术"></a>字节码生成技术</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.Javaassit,CGLib,ASM,javac</span><br></pre></td></tr></table></figure>
<h4 id="java-Proxy-生成的代理对象源码"><a href="#java-Proxy-生成的代理对象源码" class="headerlink" title="java Proxy 生成的代理对象源码"></a>java Proxy 生成的代理对象源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHello</span></span>&#123;</span><br><span class="line">             <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * target类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">implements</span> <span class="title">IHello</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"hello,world!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成的动态代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">DynamicProxyTest</span>.<span class="title">IHello</span></span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">            <span class="keyword">public</span> $Proxy0(InvocationHandler paramInvocationHandler) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">                        <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                                    <span class="keyword">this</span>.h.invoke(<span class="keyword">this</span>,m3,<span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(RuntimeException localRuntimeException)&#123;</span><br><span class="line">                                    <span class="keyword">throw</span> localRuntimeException;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span>(Throwable localRuntimeException)&#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(localThrowable);</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 由于版本原因,省略equals,hashCode,toString三个方法的代码</span></span><br><span class="line"><span class="comment">             * 这三个方法的内容和sayHello非常相似</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">static</span>&#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                                    m3=Class.forName(<span class="string">"org.fenixsoft.bytecode.DynamicProxyTest$IHello"</span>).getMethod(<span class="string">"sayHello"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">                                    m1=Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">                                    m0=Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashcode"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">                                    m2=Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>,<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(NoSuchMehtodException localNoSuchMethodException)&#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(ClassNotFountException localClassNotFoundException)&#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第十章-早期-编译器-优化"><a href="#第十章-早期-编译器-优化" class="headerlink" title="第十章 早期(编译器)优化"></a>第十章 早期(编译器)优化</h2><h3 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h3><h4 id="javac编译器的整体过程"><a href="#javac编译器的整体过程" class="headerlink" title="javac编译器的整体过程"></a>javac编译器的整体过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.javac前端编译器的三个过程.</span><br><span class="line">  1.解析(语法树)和填充符号表.</span><br><span class="line">  2.插入式注解处理器(pluggable annotation processor)的注解处理过程.</span><br><span class="line">  3.分析和字节码生成过程.</span><br><span class="line">2.JavaCompiler的compile方法.</span><br><span class="line">  com.sun.tools.javac.main.JavaCompiler#compile</span><br><span class="line">        initProcessAnnotations(processors);  &#x2F;&#x2F;初始化插入式注解处理器</span><br><span class="line">        delegateCompiler&#x3D;</span><br><span class="line">                processAnnotations(          &#x2F;&#x2F;执行注解处理</span><br><span class="line">                        enterTrees(          &#x2F;&#x2F;输入到符号表</span><br><span class="line">                                         stopIfError(CompileState.PARSE,</span><br><span class="line">                                     parseFiles(sourceFileObjects) &#x2F;&#x2F;词法解析,语法分析</span><br><span class="line">                                  )</span><br><span class="line">                        ),classnames</span><br><span class="line">        );</span><br><span class="line">        delegateCompiler.compile2();</span><br><span class="line">            -&gt;   </span><br><span class="line">                case BY_TODO:</span><br><span class="line">                     while(!todo.isEmpty())&#123;</span><br><span class="line">                        generate(                                                                                    &#x2F;&#x2F;生成字节码</span><br><span class="line">                            desugar(                                                                        &#x2F;&#x2F;解析语法糖</span><br><span class="line">                                flow(                                                                                    &#x2F;&#x2F;数据流分析</span><br><span class="line">                                    attribute(                          &#x2F;&#x2F;标注</span><br><span class="line">                                        todo.remove();</span><br><span class="line">                                    )</span><br><span class="line">                                )</span><br><span class="line">                            )</span><br><span class="line">                        )</span><br><span class="line">                     &#125;</span><br><span class="line">                break;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/11/jvm/javac-compiler-process.jpg" alt></p>
<h4 id="词法-语法分析"><a href="#词法-语法分析" class="headerlink" title="词法,语法分析"></a>词法,语法分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">com.sun.tools.javac.main.JavaCompiler#parseFiles(files)</span><br><span class="line">1.词法与语法分析.</span><br><span class="line">      词法分析是将源代码的字符流(character stream)转变为标记(token)集合.</span><br><span class="line">         com.sun.tools.javac.parser.Scanner            </span><br><span class="line">      例如: int a&#x3D;b+2(字符流) ---&gt;int,a,&#x3D;,b,+,2(token集合).</span><br><span class="line">      语法分析是根据token序列构造抽象语法树的过            程,抽象语法树(Abstract Syntax Tree).</span><br><span class="line">         1.抽象语法树(AST)是一种用来描述程序代码语法结构的树形表示方式.</span><br><span class="line">         2.语法树的每一个节点都代表着程序代码的一个语法结构(Construct).</span><br><span class="line">         3.语法结构:</span><br><span class="line">      包,类型,修饰符,运算符,接口,返回值,代码注释.....</span><br></pre></td></tr></table></figure>
<h4 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.符号表(Symbol Table)是由一组&lt;符号地址&gt;和&lt;符号信息&gt;构成的表格.</span><br><span class="line">  在语义分析中,符号表登记的内容将用于语义检查.</span><br><span class="line">2.JavaC源代码中,填充符号表由com.sun.tools.javac.comp.Enter类实现的,</span><br><span class="line">  该过程的出口是一个待处理列表(To Do list),包含了每一个编译单元的抽象语法树的顶级节点.</span><br><span class="line">  com.sun.tools.javac.comp.Enter</span><br></pre></td></tr></table></figure>
<h4 id="注解处理器-不是只用于处理注解的-它可以改变语法树节点-包括注解"><a href="#注解处理器-不是只用于处理注解的-它可以改变语法树节点-包括注解" class="headerlink" title="注解处理器(不是只用于处理注解的,它可以改变语法树节点(包括注解))"></a>注解处理器(不是只用于处理注解的,它可以改变语法树节点(包括注解))</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.java的注解有编译时注解和运行时注解.</span><br><span class="line">  编译时注解由JavaC编译器的注解处理器处理的.</span><br><span class="line">  运行时注解是由反射机制和java应用程序一起处理的.</span><br><span class="line"><span class="number">2</span>.编译时注解.</span><br><span class="line">  举个例子: lombok框架</span><br><span class="line">  <span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line">  <span class="meta">@Retention</span>(RetentionPolicy.SOURCE)    <span class="comment">//只在源文件出现</span></span><br><span class="line">  <span class="keyword">public</span> <span class="meta">@interface</span> Data &#123;</span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               *如果指定静态构造函数名称</span></span><br><span class="line"><span class="comment">               * 1.无参构造函数将是私有的</span></span><br><span class="line"><span class="comment">               * 2.创建了一个静态工厂方法，返回这个类的实例。 </span></span><br><span class="line"><span class="comment">               * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">               *     public <span class="doctag">@Data</span>(staticConstructor = "of") class Point &#123; final int x, y; &#125;</span></span><br><span class="line"><span class="comment">               * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              <span class="function">String <span class="title">staticConstructor</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">3</span>.Jdk <span class="number">1.6</span> 实现了 JSR-<span class="number">269</span>规范,</span><br><span class="line">  提供了一组插入式注解处理器的标准API,在编译期间对注解进行处理.(ps:插入式,可能就能够自定义注解处理器)</span><br><span class="line">     注解处理器可以读取,修改和添加语法树中的任意元素.</span><br><span class="line">     ps: 若修改了语法树的结构,修改后,将会重新解析和填充符号表,知道注解处理器没有修改语法树的结构.</span><br><span class="line">     initProcessAnnotations            --&gt; 初始化插入式注解处理器.</span><br><span class="line">     processAnnoations                                                --&gt;处理注解.</span><br></pre></td></tr></table></figure>
<h4 id="语义分析-类似类加载连接的验证阶段-和字节码生成"><a href="#语义分析-类似类加载连接的验证阶段-和字节码生成" class="headerlink" title="语义分析(类似类加载连接的验证阶段)和字节码生成"></a>语义分析(类似类加载连接的验证阶段)和字节码生成</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1.语言分析过程包括标注检查(attribute方法)以及数据及控制流(flow方法)分析.</span><br><span class="line">  1.标注检查.</span><br><span class="line">     1.标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与賦值之间的数据类型是否能够匹配等。</span><br><span class="line">     2.标注检查的常量折叠.</span><br><span class="line">               例子:</span><br><span class="line">                   int a&#x3D;1+2;</span><br><span class="line">                   经过常量折叠后,(1+2)会被折叠成字面量3.</span><br><span class="line">                   String str&#x3D;&quot;hello&quot;+&quot;world&quot;;</span><br><span class="line">                   经过常量折叠后,(hello+world)会被折叠成&quot;helloworld&quot;</span><br><span class="line">                   语法树会标注:ConstantExpressionValue:3.</span><br><span class="line">     com.sun.tools.javac.comp.Attr类和com.sun.tools.javac.comp.Check类.</span><br><span class="line">  2.数据及控制流分析.</span><br><span class="line">        1.局部变量是否有赋值.</span><br><span class="line">        2.方法的每条路径是否有返回值.</span><br><span class="line">        3.受检查异常是否被正确处理.</span><br><span class="line">        例子:</span><br><span class="line">        final修饰局部变量的不可变性是在前端编译器时分析的,并不是在类加载或者动态链接时分析的.</span><br><span class="line">        原因:final修饰的局部变量不存在constrant_fieldref_info,所以没有access_flags,所以final修饰的局部变量是简单编译器分析的.</span><br><span class="line">        public void foo(final int arg)&#123;</span><br><span class="line">                    final int var&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;反编译后的代码</span><br><span class="line">        public void foo(int arg)&#123;</span><br><span class="line">           var&#x3D;0;</span><br><span class="line">        &#125;</span><br><span class="line">        com.sum.tools.javac.comp.Flow</span><br><span class="line">  3.解语法糖.</span><br><span class="line">    语法糖(Syntactic Sugar): 对语言功能没有影响,更方便程序员使用.</span><br><span class="line">    desugar()</span><br><span class="line">    --&gt; </span><br><span class="line">    com.sun.tools.javac.comp.TransTypes和com.sum.tools.javac.comp.Lower类</span><br><span class="line">  4.字节码生成.</span><br><span class="line">    1.com.sun.tools.javac.jvm.Gen类.</span><br><span class="line">      字节码生成将语法树,符号表转换成字节码写到磁盘上,编译器还进行了不少的代码添加和转换工作.</span><br><span class="line">      init和clinit此时被添加到语法树.</span><br><span class="line">      字符串的相加操作替换成StringBuffer和StringBuilder.</span><br><span class="line">    2.com.sun.tools.javac.jvm.ClassWriter类.</span><br><span class="line">      writeClass输出字节码,生成最终的class文件.</span><br></pre></td></tr></table></figure>
<h3 id="Java语法糖"><a href="#Java语法糖" class="headerlink" title="Java语法糖"></a>Java语法糖</h3><h4 id="语法糖概述"><a href="#语法糖概述" class="headerlink" title="语法糖概述"></a>语法糖概述</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.语法糖: 不改变原有程序功能情况下,简化程序开发.</span><br><span class="line">2.Java提供的语法糖</span><br><span class="line">  1.泛型.</span><br><span class="line">  2.枚举.</span><br><span class="line">  3.foreach.</span><br><span class="line">  4.varargs.</span><br><span class="line">  5.InnerClasses.</span><br><span class="line">  6.Lambda表达式.</span><br><span class="line">  7.自动拆箱与装箱.</span><br><span class="line">  8.集合赋值.</span><br><span class="line">    int []arr&#x3D;&#123;&#125;;</span><br><span class="line">    Map map&#x3D;&#123;&quot;name&quot;:&quot;vicyor&quot;,&quot;age&quot;:18&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="泛型与泛型擦除"><a href="#泛型与泛型擦除" class="headerlink" title="泛型与泛型擦除"></a>泛型与泛型擦除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.泛型擦除与类型强制转换.</span><br><span class="line">  Java泛型并不是真实泛型,它只是在程序源码中存在,在字节码中已经替换为原生类型(Raw Type).</span><br><span class="line">  并在相应的地方插入了强制转换代码.</span><br><span class="line">2.Jdk1.5为泛型添加了2个属性.</span><br><span class="line">  Signature替换 Descriptor.在Descriptor的基础上增加了泛型信息</span><br><span class="line">  LocalVariableTypeTable.</span><br></pre></td></tr></table></figure>
<h4 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱的陷阱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">            Integer a=<span class="number">1</span>;</span><br><span class="line">            Integer b=<span class="number">2</span>;</span><br><span class="line">            Integer c=<span class="number">3</span>;</span><br><span class="line">            Integer d=<span class="number">3</span>;</span><br><span class="line">            Integer e=<span class="number">321</span>;</span><br><span class="line">            Integer f=<span class="number">321</span>;</span><br><span class="line">            Long g=<span class="number">3L</span>;</span><br><span class="line">            System.out.println(c==d); <span class="comment">//Integer.valueOf(3).</span></span><br><span class="line">            System.out.println(e==f); <span class="comment">// Integer.valueOf --&gt; -128~127.</span></span><br><span class="line">            System.out.println(c==(a+b)); <span class="comment">//算术运算拆箱. a+b ---&gt;int,int与Integer比较拆箱.</span></span><br><span class="line">            System.out.println(c.equals(a+b)); <span class="comment">//a+b ---&gt; int , equals(Object obj) 会将a+b装箱成Integer.</span></span><br><span class="line">            System.out.println(g==(a+b));  <span class="comment">// a+b ---&gt;int, int和Long比较会拆箱.</span></span><br><span class="line">            System.out.println(g.equals(a+b)); <span class="comment">//Long与Integer不一致.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.条件为常量会去除条件.</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 源码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                        System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"block 2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译后字节码反编译</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"block 1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实战-自定义插入式注解处理器"><a href="#实战-自定义插入式注解处理器" class="headerlink" title="实战 自定义插入式注解处理器"></a>实战 自定义插入式注解处理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line">目标:</span><br><span class="line">  检查Java程序命名规范.</span><br><span class="line">    <span class="number">1</span>.类: 驼峰命名法.</span><br><span class="line">    <span class="number">2</span>.方法: 驼峰命名法.</span><br><span class="line">    <span class="number">3</span>.字段:</span><br><span class="line">    普通变量: 驼峰命名法.</span><br><span class="line">    常量:            由大写字母和_组成,且第一个字符不能是_.</span><br><span class="line"><span class="number">1</span>.基础知识.</span><br><span class="line">   Construct(语法结构):在javax.lang.model包中定义了<span class="number">16</span>中Element.</span><br><span class="line"><span class="number">2</span>.自定义插入式注解处理器.</span><br><span class="line"><span class="comment">// 可以用"*"表示支持所有Annotations</span></span><br><span class="line"><span class="meta">@SupportedAnnotationTypes</span>(<span class="string">"*"</span>)</span><br><span class="line"><span class="comment">// 只支持JDK 1.6的Java代码</span></span><br><span class="line"><span class="meta">@SupportedSourceVersion</span>(SourceVersion.RELEASE_6)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NameChecker nameChecker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化名称检查插件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line">        nameChecker = <span class="keyword">new</span> NameChecker(processingEnv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对输入的语法树的各个节点进行进行名称检查</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!roundEnv.processingOver()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Element element : roundEnv.getRootElements())</span><br><span class="line">                nameChecker.checkNames(element);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>.NameChecker</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序名称规范的编译器插件：&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 如果程序命名不合规范，将会输出一个编译器的WARNING信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NameChecker</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//Messager会在控制台实时输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Messager messager;</span><br><span class="line"></span><br><span class="line">    NameCheckScanner nameCheckScanner = <span class="keyword">new</span> NameCheckScanner();</span><br><span class="line"></span><br><span class="line">    NameChecker(ProcessingEnvironment processsingEnv) &#123;</span><br><span class="line">        <span class="keyword">this</span>.messager = processsingEnv.getMessager();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对Java程序命名进行检查，根据《Java语言规范》第三版第6.8节的要求，Java程序命名应当符合下列格式：</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类或接口：符合驼式命名法，首字母大写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;方法：符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;字段：</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;类、实例变量: 符合驼式命名法，首字母小写。</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;常量: 要求全部大写。</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkNames</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        nameCheckScanner.scan(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称检查器实现类，继承了JDK 1.6中新提供的ElementScanner6&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 将会以Visitor模式访问抽象语法树中的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">NameCheckScanner</span> <span class="keyword">extends</span> <span class="title">ElementScanner6</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 此方法用于检查Java类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitType</span><span class="params">(TypeElement e, Void p)</span> </span>&#123;</span><br><span class="line">            scan(e.getTypeParameters(), p);</span><br><span class="line">            checkCamelCase(e, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">super</span>.visitType(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查方法命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitExecutable</span><span class="params">(ExecutableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == METHOD) &#123;</span><br><span class="line">                Name name = e.getSimpleName();</span><br><span class="line">                <span class="keyword">if</span> (name.contentEquals(e.getEnclosingElement().getSimpleName()))</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"一个普通方法 “"</span> + name + <span class="string">"”不应当与类名重复，避免与构造函数产生混淆"</span>, e);</span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.visitExecutable(e, p);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查变量命名是否合法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">visitVariable</span><span class="params">(VariableElement e, Void p)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果这个Variable是枚举或常量，则按大写命名检查，否则按照驼式命名法规则检查</span></span><br><span class="line">            <span class="keyword">if</span> (e.getKind() == ENUM_CONSTANT || e.getConstantValue() != <span class="keyword">null</span> || heuristicallyConstant(e))</span><br><span class="line">                checkAllCaps(e);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                checkCamelCase(e, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 判断一个变量是否是常量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">heuristicallyConstant</span><span class="params">(VariableElement e)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getEnclosingElement().getKind() == INTERFACE)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (e.getKind() == FIELD &amp;&amp; e.getModifiers().containsAll(EnumSet.of(PUBLIC, STATIC, FINAL)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 检查传入的Element是否符合驼式命名法，如果不符合，则输出警告信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCamelCase</span><span class="params">(Element e, <span class="keyword">boolean</span> initialCaps)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line">            <span class="keyword">boolean</span> previousUpper = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Character.isUpperCase(firstCodePoint)) &#123;</span><br><span class="line">                previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以小写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLowerCase(firstCodePoint)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initialCaps) &#123;</span><br><span class="line">                    messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当以大写字母开头"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (conventional) &#123;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (Character.isUpperCase(cp)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUpper) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUpper = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        previousUpper = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"名称“"</span> + name + <span class="string">"”应当符合驼式命名法（Camel Case Names）"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 大写命名检查，要求第一个字母必须是大写的英文字母，其余部分可以是下划线或大写字母</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkAllCaps</span><span class="params">(Element e)</span> </span>&#123;</span><br><span class="line">            String name = e.getSimpleName().toString();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> conventional = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> firstCodePoint = name.codePointAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!Character.isUpperCase(firstCodePoint))</span><br><span class="line">                conventional = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> cp = firstCodePoint;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; name.length(); i += Character.charCount(cp)) &#123;</span><br><span class="line">                    cp = name.codePointAt(i);</span><br><span class="line">                    <span class="keyword">if</span> (cp == (<span class="keyword">int</span>) <span class="string">'_'</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (previousUnderscore) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        previousUnderscore = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        previousUnderscore = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (!Character.isUpperCase(cp) &amp;&amp; !Character.isDigit(cp)) &#123;</span><br><span class="line">                            conventional = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!conventional)</span><br><span class="line">                messager.printMessage(WARNING, <span class="string">"常量“"</span> + name + <span class="string">"”应当全部以大写字母或下划线命名，并且以字母开头"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span>.测试样例.</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BADLY_NAMED_CODE</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> colors &#123;</span><br><span class="line">        red, blue, green;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _FORTY_TWO = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> NOT_A_CONSTANT = _FORTY_TWO;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">BADLY_NAMED_CODE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NOTcamelCASEmethodNAME</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">5</span>.运行和测试.</span><br><span class="line">javac org/fenixsoft/compile/NameChecker.java</span><br><span class="line">javac org/fenixsoft/compile/NameCheckProcessor.java</span><br><span class="line">javac-processor org.fenixsoft.compile.NameCheckProcessor org/fenixsoft/compile/BADLY_NAMED_CODE.java</span><br></pre></td></tr></table></figure>
<h2 id="第十一章-晚期-运行期-优化"><a href="#第十一章-晚期-运行期-优化" class="headerlink" title="第十一章 晚期(运行期)优化"></a>第十一章 晚期(运行期)优化</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在Sun HotSpot,IBM J9中,Java程序最初是通过解释器(interpreter)进行解释的.</span><br><span class="line">2.热点代码(Hot Spot Code): </span><br><span class="line">  某个方法或代码块运行特别频繁.</span><br></pre></td></tr></table></figure>
<h3 id="HotSpot虚拟机的JIT即使编译器"><a href="#HotSpot虚拟机的JIT即使编译器" class="headerlink" title="HotSpot虚拟机的JIT即使编译器"></a>HotSpot虚拟机的JIT即使编译器</h3><h4 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.程序需要快速启动和节约内存时候,解释器会省去编译的时间,立刻执行.</span><br><span class="line">2.程序需要更高的执行效率时候,编译器会将越来越多的代码编译成本地运行代码.</span><br><span class="line">3.解释器可以作为编译器优化的一个逃生门(回退),</span><br><span class="line">  编译器会根据概率选择一些大多数时候提升运行速度的优化手段,</span><br><span class="line">  当激进优化的假设不成立,可以通过逆优化退回到解释状态继续执行.</span><br><span class="line">                ---(即时编译)---&gt;</span><br><span class="line">  解释器                          编译器</span><br><span class="line">               &lt;---(逆优化)---</span><br><span class="line">4.HotSpot虚拟机内置了两个即使编译器.</span><br><span class="line">  分别为Client Compiler和 Server Compiler.</span><br><span class="line">5.jvm 参数</span><br><span class="line">  -server</span><br><span class="line">  -client</span><br><span class="line">  -Xint  纯解释模式(Interpreted Mode).</span><br><span class="line">  -Xcmp  优先编译模式(Compiled Mode).</span><br><span class="line">6.JIT分层编译.</span><br><span class="line">  第0层: 解释执行(无JIT编译器编译),可触发第1层编译.</span><br><span class="line">  第1层: C1编译器编译,解释器开启性能监控(Profiling).</span><br><span class="line">  第2层: C2编译器编译,解释器开启性能监控(Profiling).启用一些编译耗时较长的优化,甚至根据性能进行不可靠的激进优化.</span><br><span class="line">  C1编译器具有更高的编译速度,C2编译器具有更好的编译质量.</span><br><span class="line">  即使编译需要解释器做性能收集监控的任务.</span><br></pre></td></tr></table></figure>
<h4 id="编译对象和触发条件"><a href="#编译对象和触发条件" class="headerlink" title="编译对象和触发条件"></a>编译对象和触发条件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1.运行过程会被即时编译的热点代码(hot spot code).</span><br><span class="line">  热点代码: 多次调用的方法,多次执行的循环体.</span><br><span class="line">2.标准的JIT编译方式.</span><br><span class="line">  方法调用触发的编译,会将整个方法作为编译对象.</span><br><span class="line">  循环体触发的编译,依然是以循环体所在的方法作为编译对象.</span><br><span class="line">3.OSR (On Stack Replacement).</span><br><span class="line">  OSR编译,编译放生在方法执行过程中,方法栈帧还在栈上,方法就被替换了.</span><br><span class="line">4.即时编译触发的条件.</span><br><span class="line">  1.基于采样的热点探测(Sample Based Hot Spot Detection).</span><br><span class="line">    经常出现在栈顶的方法.</span><br><span class="line">  2.基于计数器的热点探测(Counter Based Hot Spot Detection).</span><br><span class="line">    为每个方法建立计数器.统计方法的执行次数.</span><br><span class="line">    -XX:OnStackReplacePercentage</span><br><span class="line">5.HotSpot虚拟机是采用了第二种:基于计数器的热点探测方法.</span><br><span class="line">  方法调用计数器(Invocation Counter).   方法</span><br><span class="line">  回边计数器(Back Edge Counter).                  语句块</span><br><span class="line">  -XX:CompileThreshold&#x3D;1500  计数阈值</span><br><span class="line">6.方法计数是在一定时间范围内的计数.若时间内计数未达到阈值,计数器值会减少一半(Counter Decay).</span><br><span class="line">  1.时间称为方法统计的半衰周期.</span><br><span class="line">  2.热度衰减是在 SafePoint停顿时进行的.</span><br><span class="line">7.回边计数</span><br><span class="line">  1.虚拟机在client模式下,回边计数的阈值为:</span><br><span class="line">    方法调用计数器阈值(Compile Threshold)* OSR比率(OnStackReplacePercentage)&#x2F;100.</span><br><span class="line">                     1500  * 933 &#x2F;100 &#x3D;13995</span><br><span class="line">  2.虚拟机在Server模式下,回边计数器阈值为:</span><br><span class="line">    方法调用计数器阈值(CompileThreshold)*(OSR比率(On Stack Replace Percentage)-解释器监控比率(InterpreterProfilePercentage))&#x2F;100.</span><br><span class="line">                     10000 * (140-33)&#x2F;100&#x3D;10700</span><br><span class="line">  3.回边计数没有热度衰减的过程.                                                </span><br><span class="line">8.引入JIT编译器后方法的执行过程.</span><br><span class="line">                                        -------&gt;   是   ------&gt;执行编译后的本地代码版本</span><br><span class="line">  Java方法入口  ----&gt; 是否存在编译版本</span><br><span class="line">                                        -------&gt;   否            </span><br><span class="line">                                           -------&gt; 方法调用计数器值+1</span><br><span class="line">                                                -------&gt;c1和c2计数器和大于CompileThreshold</span><br><span class="line">                                                        ---&gt;向编译器提出编译请求</span><br><span class="line">                                                -------&gt;c1和c2计数器和小于CompileThreshold</span><br><span class="line">                                                                                 -----&gt;以解释方法执行</span><br><span class="line">9.引入JIT编译器后语句块执行过程.</span><br><span class="line">                                         -------&gt;   是   ------&gt;执行编译后的本地代码版本</span><br><span class="line">   回边指令----&gt; 是否存在编译版本</span><br><span class="line">                                         -------&gt;   否            </span><br><span class="line">                                            -------&gt; 回边计数器值+1</span><br><span class="line">                                            -------&gt; c1和c2计数器和大于CompileThreshold</span><br><span class="line">                                                      ---&gt;向编译器提出OSR编译请求</span><br><span class="line">                                             -------&gt;c1和c2计数器和小于CompileThreshold</span><br><span class="line">                                                                                -----&gt;以解释方法执行</span><br></pre></td></tr></table></figure>
<h4 id="查看及分析编译结果"><a href="#查看及分析编译结果" class="headerlink" title="查看及分析编译结果"></a>查看及分析编译结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 源码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUM = <span class="number">15000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">doubleValue</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) ;</span><br><span class="line">            <span class="keyword">return</span> i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">calSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                        sum += doubleValue(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM; i++) &#123;</span><br><span class="line">                        calSum();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Param : -XX:+PrintCompilation</span></span><br><span class="line"><span class="comment"> * 查看OSR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="number">198</span>   <span class="number">39</span> %     <span class="number">3</span>       com.vicyor.blog.apps.OSRTest::doubleValue @ <span class="number">2</span> (<span class="number">19</span> bytes)</span><br><span class="line">            <span class="number">200</span>   <span class="number">42</span>       <span class="number">3</span>       com.vicyor.blog.apps.OSRTest::calSum (<span class="number">26</span> bytes)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Param: -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining </span></span><br><span class="line"><span class="comment"> * 查看内联方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">                    @ <span class="number">12</span>   com.vicyor.blog.apps.OSRTest::calSum (<span class="number">19</span> bytes)   inline (hot)</span><br><span class="line">                    @ <span class="number">12</span>   com.vicyor.blog.apps.OSRTest::doubleValue (<span class="number">19</span> bytes)   inline (hot)            </span><br><span class="line">可以看出doubleValue内联到calSum方法中了.</span><br></pre></td></tr></table></figure>
<h3 id="编译优化技术"><a href="#编译优化技术" class="headerlink" title="编译优化技术"></a>编译优化技术</h3><h4 id="优化技术概览"><a href="#优化技术概览" class="headerlink" title="优化技术概览"></a>优化技术概览</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.通过例子简单的介绍JIT编译器的几种优化技术(书上的很深).</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 优化前的原始代码</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">              <span class="keyword">int</span> value;</span><br><span class="line">              <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">                          <span class="keyword">return</span> value;</span><br><span class="line">              &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">              y=b.get();</span><br><span class="line">              z=b.get();</span><br><span class="line">              sum=y+z;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">2</span>.方法内联(Method Inlining)优化.</span><br><span class="line">  <span class="number">1</span>.去掉方法调用成本(栈帧).</span><br><span class="line">  <span class="number">2</span>.为其它优化建立良好基础</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">               y=b.value;</span><br><span class="line">               z=b.value;</span><br><span class="line">               sum=y+z;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="number">3</span>.冗余访问消除(Redundant Loads Elimination).</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">              y=b.value;</span><br><span class="line">              z=y;</span><br><span class="line">              sum=y+z;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">4</span>.复写传播(Copy Propagation).</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">              y=b.value;</span><br><span class="line">              y=y;</span><br><span class="line">              sum=y+y;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="number">5</span>.无用代码消除(Dead Code Elimination).</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">              y=b.value;</span><br><span class="line">              sum=y+y;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.公共子表达式.</span><br><span class="line">  如果一个表达式已经计算过了,并且它的因子都没有变化,那么E的这次出现成为了公共子表达式.</span><br><span class="line">2.公共子表达式消除.</span><br><span class="line">   如果E成为公共子表达式,对于这种表达式就不用再次花时间计算,直接使用计算过的表达式结果替换E就可以了.</span><br></pre></td></tr></table></figure>
<h4 id="数组边界检查消除-Array-Bounds-Checking-Elimination"><a href="#数组边界检查消除-Array-Bounds-Checking-Elimination" class="headerlink" title="数组边界检查消除(Array Bounds Checking Elimination)"></a>数组边界检查消除(Array Bounds Checking Elimination)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.编译时通过数据流分析确定数组的length,那么执行时候判断下标是否越界的判断语句就可以消除了.</span><br></pre></td></tr></table></figure>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.方法内联: 将目标方法嵌入到发起调用的方法之中.</span><br><span class="line">2.方法内联的优点:</span><br><span class="line">            1.减少目标方法调用成本.</span><br><span class="line">            2.为其它优化提供基础.</span><br><span class="line">3.方法内联是针对非虚方法而言的,因为非虚方法,静态分派,编译时确定. </span><br><span class="line">4.为了解决虚方法的问题,Java虚拟机团队引入了一种为&quot;类型继承关系分析&quot;(Class Hierarchy Analysis)技术.</span><br><span class="line">  CHA技术会查询方法在当前程序下是否有多个版本实现.</span><br><span class="line">    若方法有一个版本,直接内联,不过这种内联需要预留一个逃生门(为了防止动态出现新版本,可以回退).</span><br><span class="line">    若方法有多个版本,使用内联缓存(Inline Cache).</span><br><span class="line">       记录第一次调用的方法版本,并内联.</span><br><span class="line">    若新调用的版本不同,则查vtable,并记录版本,写InlineCache.</span><br></pre></td></tr></table></figure>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.逃逸分析(Escape Analysis)是Java虚拟机中比较前沿的技术.</span><br><span class="line">  逃逸分析是分析不逃逸的对象,并对其优化.</span><br><span class="line">2.逃逸是指一个对象在方法中定义,但是它可能作为参数或字段存到其它方法,类中,这就做逃逸.</span><br><span class="line">  线程逃逸: 局部变量赋予其它线程了.</span><br><span class="line">3.基于逃逸分析的优化。</span><br><span class="line">  1.栈上分配(ON Stack Allocation).</span><br><span class="line">    对象在栈上分配内存.对象随栈帧出栈自动销毁.</span><br><span class="line">  2.同步清除(Synchronization Elimination).</span><br><span class="line">    对方法局部变量加锁,可以去除锁.</span><br><span class="line">  3.标量替换(Scalar Replacement).</span><br><span class="line">    并不会创建对象,而是将一个对象拆分成它的多个字段.</span><br></pre></td></tr></table></figure>
<h2 id="第十二章-Java内存模型与线程"><a href="#第十二章-Java内存模型与线程" class="headerlink" title="第十二章 Java内存模型与线程"></a>第十二章 Java内存模型与线程</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">衡量一个服务性能高低好坏,每秒事务处理数(Transactions Per Second)是最重要的指标.</span><br></pre></td></tr></table></figure>
<h3 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.Cache 作为 内存 和 CPU 之间的缓存.</span><br><span class="line">  CPU运算时将参数从内存移动缓存快速计算.</span><br><span class="line">  运算结束将结果写回内存.</span><br><span class="line">2.内存模型:在某种特定的操作协议下,对特定的内存和高速缓存进行读写的过程抽象.</span><br><span class="line">    处理器,高速缓存,主内存间的交互关系.</span><br><span class="line">    处理器  &lt;--&gt; 高速缓存 &lt;--&gt;   缓</span><br><span class="line">                                存                  主</span><br><span class="line">                                一</span><br><span class="line">    处理器  &lt;--&gt; 高速缓存            &lt;--&gt;致   &lt;------&gt;       内</span><br><span class="line">                                性</span><br><span class="line">                                协                  存</span><br><span class="line">            处理器  &lt;--&gt; 高速缓存            &lt;--&gt;            仪</span><br></pre></td></tr></table></figure>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><h4 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.Java内存模型的主要目标是定义程序中各个变量的访问规则,即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节.</span><br><span class="line">2.线程对变量的所有操作(读取,赋值)必须在工作内存(Working Memory)中进行,不能直接读写主内存(Main Memory)中的变量.</span><br><span class="line">3.线程,主内存,工作内存三者之间的交互关系.</span><br><span class="line">   Java线程            &lt;-&gt;            工作内存                        </span><br><span class="line">   </span><br><span class="line">                                Save,</span><br><span class="line">   Java线程            &lt;-&gt;            工作内存             &lt;-&gt;            Load           主内存</span><br><span class="line">                                                                                    </span><br><span class="line">                                                                                    </span><br><span class="line">   Java线程            &lt;-&gt;            工作内存</span><br></pre></td></tr></table></figure>
<h4 id="内存间的交互操作"><a href="#内存间的交互操作" class="headerlink" title="内存间的交互操作"></a>内存间的交互操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.主内存与工作内存的交互操作.</span><br><span class="line">     1.lock      锁定.</span><br><span class="line">     2.unlock    解锁.</span><br><span class="line">     3.read      主内存 ---&gt;工作内存.</span><br><span class="line">     4.load      将read操作的变量赋值给工作内存的变量.</span><br><span class="line">     5.use       使用.</span><br><span class="line">     6.assign    赋值(赋新值).</span><br><span class="line">     7.store     将工作内存的变量写道主内存中.</span><br><span class="line">     8.write     将store操作的变量值放入到主内存的变量中.</span><br><span class="line">2.JMM对8项操作的规则.</span><br><span class="line">   1.不允许read和load,store和write操作之一单独出现.</span><br><span class="line">   2.不允许一个线程丢弃它最近的assign操作.</span><br><span class="line">   3.不允许一个线程无原因的(未发生assign操作)将数据的工作内存同步到主内存中.</span><br><span class="line">   4.一个变量只能在主内存中诞生,不允许在工作内存中直接使用一个未被初始化(assing或load)的变量.</span><br><span class="line">   5.一个变量在同一个时刻只允许一条线程对其进行lock操作,lock操作可以被同一个线程执行多次.</span><br><span class="line">   6.对一个变量执行lock操作后,会清空工作内存中变量的值.</span><br><span class="line">   7.unlock不能单独出现.</span><br><span class="line">   8.unlock操作之前,会将变量同步会主存中(store,write).</span><br></pre></td></tr></table></figure>
<h4 id="volatile变量的特殊规则"><a href="#volatile变量的特殊规则" class="headerlink" title="volatile变量的特殊规则"></a>volatile变量的特殊规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.volatile变量的两种特性.</span><br><span class="line">  1.可见性. 对一个变量的修改,结果对于其它线程是立即得知的.</span><br><span class="line">  2.禁止指令重排序优化.</span><br><span class="line">2.volatile变量不能确保原子性的原因.</span><br><span class="line">  1.Java的运算并非原子性操作.</span><br><span class="line">  例如 i++</span><br><span class="line">  iload_1    &#x2F;&#x2F;i入操作数栈</span><br><span class="line">  iconst_1   &#x2F;&#x2F;字面量1入操作数栈</span><br><span class="line">  iadd       &#x2F;&#x2F; i+1</span><br><span class="line">  istore_1   &#x2F;&#x2F;赋予结果给i</span><br><span class="line">3.volatile禁止指令重排序.</span><br><span class="line">  内存屏障(Memory Barrier或Memory Fence):指令重排序时候不能将后面的指令重排序到内存屏障之前的位置.</span><br><span class="line">  volatile变量的写操作会产生内存屏障.</span><br><span class="line">4.volatile的运用场景.</span><br><span class="line">  1.多线程环境下的条件判断(非复合判断).</span><br><span class="line">    volatile boolean flag&#x3D;false;</span><br><span class="line">    if(flag)&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="对于long和double变量的特殊规则"><a href="#对于long和double变量的特殊规则" class="headerlink" title="对于long和double变量的特殊规则"></a>对于long和double变量的特殊规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目前各种平台下的商用虚拟机几乎选择64位数据的读写操作作为原子操作对待,所以不需要将long和double专门声明为volatile.</span><br></pre></td></tr></table></figure>
<h4 id="原子性-可见性-有序性"><a href="#原子性-可见性-有序性" class="headerlink" title="原子性,可见性,有序性"></a>原子性,可见性,有序性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.原子性(Atomicity): Java内存模型保证变量的读写具有原子性(运算没有).</span><br><span class="line">  synchronized--&gt;monitorenter,monitorexit.</span><br><span class="line">2.可见性(Visibility): 当一个线程修改了共享变量的值,其它线程是立刻得知这个修改.</span><br><span class="line">   volatile,final,synchronize都可以保证可见性.</span><br><span class="line">3.有序性(Ordering): 如果在本线程观察,所有的操作都是有序的,如果观察其它的线程,所有的操作都是无序的.</span><br></pre></td></tr></table></figure>
<h4 id="先行先发送原则-happens-before"><a href="#先行先发送原则-happens-before" class="headerlink" title="先行先发送原则(happens-before)"></a>先行先发送原则(happens-before)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.程序次序原则(Program Order Rule).</span><br><span class="line">2.管程锁定规则(Monitor Lock Rule).</span><br><span class="line">3.volatile变量规则(Volatile Variable Rule).</span><br><span class="line">4.线程启动规则(Thread Start Rule).</span><br><span class="line">5.线程终止规则(Thread Termination Rule).</span><br><span class="line">6.线程中断规则(Thread Interruption Rule).</span><br><span class="line">7.对象终结规则(Finalizer RUle).</span><br><span class="line">8.传递性(Transitivity).</span><br></pre></td></tr></table></figure>
<h3 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.线程是比进程更轻量级的调度执行单位,线程的引入,可以把一个进程的资源分配和执行调度分开.</span><br><span class="line">  各个线程可以共享进程资源(内存地址,文件I&#x2F;O),又可以独立调度(线程是CPU调度的基本单位).</span><br><span class="line">2.内核线程.</span><br><span class="line">  1.内核线程(Kernel-Level Thread)就是直接由内核支持的线程.</span><br><span class="line">  2.内核通过调度器(Scheduler)对线程进行调度,将线程映射到各个处理器上.</span><br><span class="line">  3.支持多线程的内核叫做多线程内核(Multi-Threads Kernel).</span><br><span class="line">  4.程序不会直接使用KLT,而是通过内核线程的高级接口-轻量级进程(Light Weight Process,LWP).</span><br><span class="line">  5.Thread是基于内核线程实现的,线程的创建,析构,同步都需要进行系统调用.</span><br><span class="line">    系统调用需要从用户态(User Mode)和内核态(Kernel Mode)中来回切换,代价相当高.</span><br><span class="line">3.用户线程.</span><br><span class="line">  1.用户线程是完全建立在用户空间的线程库上,系统内核不能感知线程存在的实现.</span><br><span class="line">4.Java线程的实现.</span><br><span class="line">  1.在目前的JDK版本中,线程模型替换为基于操作系统原生线程模型来实现.</span><br><span class="line">  2.Sun JDK,Java线程映射到一条轻量级进程(LWP)中.</span><br></pre></td></tr></table></figure>
<h4 id="Java线程调度"><a href="#Java线程调度" class="headerlink" title="Java线程调度"></a>Java线程调度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.线程调度:</span><br><span class="line">   系统为线程分配处理器使用权的过程.</span><br><span class="line">2.协同式调度(Cooperative Threads-Scheduling).</span><br><span class="line">  线程执行完后通知系统切换到另一个线程.</span><br><span class="line">3.抢占式线程调度(Preemptive Threads-Scheduling).</span><br><span class="line">  每个线程由系统分配执行时间片.</span><br><span class="line">4.Java线程使用的是抢占式线程调度.</span><br><span class="line">5.Java线程有优先级,一共有10个线程优先级(Thread.MIN_PRIORITY~Thread.MAX_PRIORITY).</span><br><span class="line">6.状态转换.</span><br><span class="line">   Runnable   ---线程获取时间片---&gt;   Running</span><br><span class="line">   Running    ---时间片执行结束---&gt;   Runnable </span><br><span class="line">   Runnable    ---synchronized ---&gt;   Blocked</span><br><span class="line">   Blocked    ---获取锁        ---&gt;  Runnable</span><br><span class="line">   Running              ---wait,join,LockSupport#park() ---&gt;  Waiting</span><br><span class="line">   Waiting    ---notify       ---&gt;  Runnable</span><br><span class="line">   Runnable    ---sleep(time)  ---&gt; Timed_Waiting     -----&gt;Runnable</span><br><span class="line">   Running    ---yield        ---&gt; Runnable</span><br></pre></td></tr></table></figure>
<h2 id="第十三章-线程安全和锁优化"><a href="#第十三章-线程安全和锁优化" class="headerlink" title="第十三章 线程安全和锁优化"></a>第十三章 线程安全和锁优化</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="安全性与活跃性"><a href="#安全性与活跃性" class="headerlink" title="安全性与活跃性"></a>安全性与活跃性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安全性: 不好的事情不会发送.</span><br><span class="line">活跃性: 正确的事情一定发送.</span><br><span class="line">线程安全:</span><br><span class="line">    当多个线程访问一个对象时候,如果不考虑线程运行环境的调度和交替运行,也不需要额外的同步,或者在调用方法进行任何的协调操作,</span><br><span class="line">    调用这个对象的行为都可以获取正确的结果,这个对象是线程安全的.</span><br></pre></td></tr></table></figure>
<h4 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.不可变 </span><br><span class="line">  final ---&gt;可见性.</span><br><span class="line">  String是fianl的,subString,replace,concat都会返回新的字符串对象.</span><br><span class="line">  枚举也是不可变的.</span><br><span class="line">  java.lang.Number的部分子类. Long,Double,BigInteger,BigDicimal.</span><br><span class="line">2.绝对线程安全.</span><br><span class="line">  不管运行环境如何,调用者都不需要额外的同步措施.</span><br><span class="line">  ps:比如AtomicInteger,看似每个操作都是原子的,但是将多个原子操作组合就不是原子了.</span><br><span class="line">3.相对线程安全.</span><br><span class="line">  在某种条件下是线程安全的(需要额外的同步措施).</span><br><span class="line">  Vector,HashTable,Collections.synchronizedCollection().</span><br><span class="line">4.线程兼容.</span><br><span class="line">  对象本身不是线程安全的,可以加额外的同步措施使其线程安全.</span><br><span class="line">5.线程对立.</span><br><span class="line">  无论调用方如何使用同步措施,在多线程环境下使用的代码.</span><br><span class="line">  例如Thread.suspend和Thread.resume.</span><br></pre></td></tr></table></figure>
<h4 id="线程安全的实现方式"><a href="#线程安全的实现方式" class="headerlink" title="线程安全的实现方式"></a>线程安全的实现方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.互斥同步(mutual Exclusion &amp; Synchronization).</span><br><span class="line">  临界区(Critical Section): 共享资源,一次只能一个线程访问.</span><br><span class="line">  互斥量(Mutex).</span><br><span class="line">  信号量(Semaphore).</span><br><span class="line">  互斥是因,同步是果.互斥是方法,同步是目的.</span><br><span class="line">2.Java的Synchronized关键字.</span><br><span class="line">  1.synchronized关键字编译后会在语句块前后生成monitorenter,monitorexit指令.</span><br><span class="line">  2.monitorenter,monitorexit指令需要reference(对象引用)作为参数指明锁定和解锁的对象.</span><br><span class="line">  3.synchronized指明对象或synchronized修饰非类方法,那么reference指向this的对象.</span><br><span class="line">    若synchronized修饰类方法,那么reference指向this.getClass()的类对象.</span><br><span class="line">  4.synchronize修饰方法不会产生monitorenter和monitorexit,其的同步由方法的访问标志ACC_SYNCHRONIZED绝对.</span><br><span class="line">3.java.util.concurrent包的ReentrantLock.</span><br><span class="line">  ReentrantLock是CLH队列锁.</span><br><span class="line">  主要原理: </span><br><span class="line">     1.查看head node是不是自己(偏向).</span><br><span class="line">     2.自旋cas获取锁(for(;;)&#123;if(state&#x3D;&#x3D;0&amp;&amp;cas(head,null,me))&#123;break;&#125;&#125;).</span><br><span class="line">     3.阻塞(LockSupport.park()).</span><br><span class="line">4.无同步方案.</span><br><span class="line">  ThreadLocal.</span><br><span class="line"> 1.线程本地存储.</span><br><span class="line">  主要原理:</span><br><span class="line">    Thread ---&gt; ThreadLocalMap----&gt;Entry&#123;referent&#x3D;threadlocal;value&#x3D;v&#125;</span><br></pre></td></tr></table></figure>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.JTI逃逸分析出对象是局部变量,那么就不需要加锁了.</span><br><span class="line">2.举个例子.</span><br><span class="line">  jdk1.5前,字符串相加会转StringBuffer.append(); 同步</span><br><span class="line">  jdk1.5后,字符串相加会转StringBuilder.append();</span><br><span class="line">  public String concatString(String s1,String s2,String s3)&#123;</span><br><span class="line">      return s1+s2+s3;</span><br><span class="line">  &#125;</span><br><span class="line">  javac编译后反编译</span><br><span class="line">   public String concatString(String s1,String s2,String se)&#123;</span><br><span class="line">     StringBuffer sb&#x3D;new StringBuffer();</span><br><span class="line">     sb.append(s1);</span><br><span class="line">     sb.append(s2);</span><br><span class="line">     sb.append(s3);</span><br><span class="line">     return sb.toString();</span><br><span class="line">   &#125;</span><br><span class="line">  JIT Compiler会经过逃逸分析分析出sb不会逃逸,所以对sb的所有同步操作都会消除.</span><br></pre></td></tr></table></figure>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.锁粗化:增大锁的粒度减少加锁的数量.</span><br><span class="line">2.举个例子</span><br><span class="line">  for(int i&#x3D;0;i&lt;1000;i++)&#123;</span><br><span class="line">      synchronized(obj)&#123;</span><br><span class="line">        ....</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  锁粗化后</span><br><span class="line">   synchronized(obj)&#123;</span><br><span class="line">       for(int i&#x3D;0;i&lt;1000;i++)&#123;</span><br><span class="line">       ....</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="锁转化关系"><a href="#锁转化关系" class="headerlink" title="锁转化关系"></a>锁转化关系</h4><p><img src="/2020/07/11/jvm/markword.png" alt><br><img src="/2020/07/11/jvm/biasable.jpg" alt><br><img src="/2020/07/11/jvm/lock.png" alt></p>
<pre><code>1.Mark Word存储内容.
  无锁态:  obj hashcode  + obj age + 0(不可偏向) + 01(无锁/偏向锁).
  轻量级锁:  LockRecord-Address + 00(轻量级锁).
  重量级锁:  Mutex_Address + 10(重量级锁).
  GC标记:   null                        +                        11(GC标记).
  偏向锁:   偏向线程Id + Epoch + obj age + 1(可偏向) +01(无锁/偏向锁).
2.锁升级逻辑.
        线程来临:                                                            
                if(markword.lockFlag==01&amp;&amp;markword.biasFlag==1){
                      //偏向锁标志
                      if(threadId==currentThreadId){
                            //重入
                             doReentrantLock(){
                                putLockRecordInStack(currentThread,null,obj);
                                return;
                            };
                        }else{
                            //如果是第一个线程访问.重偏向 rebias
                             if(cas(threadid_address,0,currentThreadId)){
                                putLockRecordInStackFirst(currentThread,currentThreadId,obj);
                                return;
                             }else{
                             //等到全局SafePoint
                             waitUntilSafePoint();
                             //偏向线程死亡或者偏向线程已经不会再执行临界区了
                             if(isDeadOrNotInCriticalArea(biasThread)){//通过判处biasThread栈中是否有LockRecord判断是否在临界区
                                         //epoch过期了,说明偏向线程不在临界区,可以重偏向了.
                                         if(obj.epoch!=obj.getClass().epoch){
                                                     //尝试重偏向
                                                     if(cas(threadid_address,0,currentThreadId)){
                                                                 putLockRecordInStackFirst(currentThread,currentThreadId,obj);
                                                                 return;
                                                     }else{
                                                                 //多个同类线程访问临界区
                                                                 RevokeBiasAndlockUpgrade(obj);
                                                                 return;
                                                     }
                                         }else{
                                                     //禁止重偏向
                                                     RevokeBiasAndlockUpgrade(obj);
                                                     return;
                                         }
                             }else{
                                    //偏向线程还在临界区,此时多个线程(偏向线程+当前线程),撤销偏向锁,升级为轻量级锁.
                                    RevokeBiasAndlockUpgrade(obj);
                                    return;
                               }
                              }
                            }
                }
                else{                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                    for(int i=0;i&lt;轻量级锁自旋阈值,i++){
                       //获取轻量级锁成功
                       if(cas(markword的LockRecord-Address,null,this-stack)){
                          flag=true;
                          break;
                        }
                     }
                    if(flag){
                       线程获取轻量级锁.
                    }else{
                      锁膨胀成重量级锁.
                   }
                }                                                                                                            
3.批量重偏向(bulk rebias)与批量撤销(bulk revoke).
  以Class对象为单位.
    批量重偏向: 
         A Class 创建了 300个obj,初始时候epoch=1(加设),有一个X线程对300个obj同时加锁和释放锁并且tenimated.
         只有2个线程串行访问.
         X线程成为了300个Obj的bias线程.
         Y线程又对300个obj同时加锁,当对第20个对象加锁时,发生重偏向次数为20.每次重偏向epoch+1.
         此时重偏向次数大于bulk rebias阈值,会直接对剩下的280个对象直接重偏向.
   批量撤销:
         A Class 创建了 300个obj,
         每个obj多有100个线程并发访问,
         每个obj的锁都会由偏向锁--&gt;撤销--&gt;升级--&gt;轻量级锁.
         当撤销次数大于 bulk revoke阈值时候,就会直接将剩下的obj的偏向锁直接撤销,走轻量级锁.</code></pre>
    </div>

    
    
    
		<div>
			
				<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

			
		</div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/jvm/" rel="tag"># jvm</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/02/wx-mini-program/" rel="prev" title="wx-mini-program">
      <i class="fa fa-chevron-left"></i> wx-mini-program
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/11/hello-world/" rel="next" title="Hello World">
      Hello World <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="comments"></div>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-走进JAVA"><span class="nav-number">1.</span> <span class="nav-text">第一章 走进JAVA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK"><span class="nav-number">1.1.</span> <span class="nav-text">JDK</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK各个版本新特性"><span class="nav-number">1.1.1.</span> <span class="nav-text">JDK各个版本新特性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-Java-内存区域与内存溢出异常"><span class="nav-number">2.</span> <span class="nav-text">第二章 Java 内存区域与内存溢出异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时数据区域"><span class="nav-number">2.1.</span> <span class="nav-text">运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序计数器"><span class="nav-number">2.1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java虚拟机栈"><span class="nav-number">2.1.2.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JAVA堆"><span class="nav-number">2.1.3.</span> <span class="nav-text">JAVA堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法区"><span class="nav-number">2.1.4.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直接内存"><span class="nav-number">2.1.5.</span> <span class="nav-text">直接内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象的创建"><span class="nav-number">2.2.</span> <span class="nav-text">对象的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java对象的几种创建方式"><span class="nav-number">2.2.1.</span> <span class="nav-text">Java对象的几种创建方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的创建过程"><span class="nav-number">2.2.2.</span> <span class="nav-text">对象的创建过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的内存布局"><span class="nav-number">2.2.3.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象的访问方式"><span class="nav-number">2.2.4.</span> <span class="nav-text">对象的访问方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OutOfMemeoryError-异常"><span class="nav-number">2.3.</span> <span class="nav-text">OutOfMemeoryError 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存泄露和内存溢出"><span class="nav-number">2.3.1.</span> <span class="nav-text">内存泄露和内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java堆溢出"><span class="nav-number">2.3.2.</span> <span class="nav-text">Java堆溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟机栈和本地方法栈溢出"><span class="nav-number">2.3.3.</span> <span class="nav-text">虚拟机栈和本地方法栈溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法区和运行时常量池的溢出"><span class="nav-number">2.3.4.</span> <span class="nav-text">方法区和运行时常量池的溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本机直接内存溢出"><span class="nav-number">2.3.5.</span> <span class="nav-text">本机直接内存溢出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-垃圾回收器与内存分配策略"><span class="nav-number">3.</span> <span class="nav-text">第三章 垃圾回收器与内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#GC需要完成的3件事情"><span class="nav-number">3.1.1.</span> <span class="nav-text">GC需要完成的3件事情</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么时候回收"><span class="nav-number">3.1.2.</span> <span class="nav-text">什么时候回收</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象已死吗"><span class="nav-number">3.2.</span> <span class="nav-text">对象已死吗</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#引用计数法"><span class="nav-number">3.2.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可达性分析算法"><span class="nav-number">3.2.2.</span> <span class="nav-text">可达性分析算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GC-ROOTS-两次标记"><span class="nav-number">3.2.3.</span> <span class="nav-text">GC ROOTS 两次标记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#再谈引用"><span class="nav-number">3.2.4.</span> <span class="nav-text">再谈引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#回收方法区"><span class="nav-number">3.2.5.</span> <span class="nav-text">回收方法区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收算法"><span class="nav-number">3.3.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#标记-清除算法"><span class="nav-number">3.3.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制算法"><span class="nav-number">3.3.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标记-整理算法"><span class="nav-number">3.3.3.</span> <span class="nav-text">标记-整理算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分代收集算法"><span class="nav-number">3.3.4.</span> <span class="nav-text">分代收集算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot算法实现"><span class="nav-number">3.4.</span> <span class="nav-text">HotSpot算法实现.</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举根节点"><span class="nav-number">3.4.1.</span> <span class="nav-text">枚举根节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全点"><span class="nav-number">3.4.2.</span> <span class="nav-text">安全点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STW实现方式"><span class="nav-number">3.4.3.</span> <span class="nav-text">STW实现方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#安全区域"><span class="nav-number">3.4.4.</span> <span class="nav-text">安全区域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾收集器"><span class="nav-number">3.5.</span> <span class="nav-text">垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial收集器"><span class="nav-number">3.5.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParNew收集器"><span class="nav-number">3.5.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#并发与并行"><span class="nav-number">3.5.3.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Scavenge收集器"><span class="nav-number">3.5.4.</span> <span class="nav-text">Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial-Old-收集器"><span class="nav-number">3.5.5.</span> <span class="nav-text">Serial Old 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Parallel-Old-收集器"><span class="nav-number">3.5.6.</span> <span class="nav-text">Parallel Old 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CMS-收集器"><span class="nav-number">3.5.7.</span> <span class="nav-text">CMS 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G1-收集器"><span class="nav-number">3.5.8.</span> <span class="nav-text">G1 收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Full-GC触发时机"><span class="nav-number">3.5.9.</span> <span class="nav-text">Full GC触发时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#垃圾回收器参数总结"><span class="nav-number">3.5.10.</span> <span class="nav-text">垃圾回收器参数总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存回收与回收策略"><span class="nav-number">3.6.</span> <span class="nav-text">内存回收与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#minor-gc-与-major-gc"><span class="nav-number">3.6.1.</span> <span class="nav-text">minor gc 与 major gc</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象优先在Eden分配"><span class="nav-number">3.6.2.</span> <span class="nav-text">对象优先在Eden分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#大对象直接进入老年代"><span class="nav-number">3.6.3.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#长期存活的对象将进入老年代"><span class="nav-number">3.6.4.</span> <span class="nav-text">长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象动态年龄判定"><span class="nav-number">3.6.5.</span> <span class="nav-text">对象动态年龄判定.</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间分配担保"><span class="nav-number">3.6.6.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-虚拟机性能监控与故障处理工具"><span class="nav-number">4.</span> <span class="nav-text">第四章 虚拟机性能监控与故障处理工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-调优案例分析与实战"><span class="nav-number">5.</span> <span class="nav-text">第五章 调优案例分析与实战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章-类文件结构"><span class="nav-number">6.</span> <span class="nav-text">第六章 类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Class类文件的结构"><span class="nav-number">6.1.</span> <span class="nav-text">Class类文件的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Class文件介绍"><span class="nav-number">6.1.1.</span> <span class="nav-text">Class文件介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class文件格式"><span class="nav-number">6.1.2.</span> <span class="nav-text">Class文件格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常量池"><span class="nav-number">6.1.3.</span> <span class="nav-text">常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#访问标志"><span class="nav-number">6.1.4.</span> <span class="nav-text">访问标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类索引-父类索引-接口索引集合"><span class="nav-number">6.1.5.</span> <span class="nav-text">类索引,父类索引,接口索引集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字段表集合"><span class="nav-number">6.1.6.</span> <span class="nav-text">字段表集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法表集合"><span class="nav-number">6.1.7.</span> <span class="nav-text">方法表集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法表与常量池的方法符号引用-字段表与常量池字段符号引用"><span class="nav-number">6.1.8.</span> <span class="nav-text">方法表与常量池的方法符号引用,字段表与常量池字段符号引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性表集合"><span class="nav-number">6.1.9.</span> <span class="nav-text">属性表集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#code属性"><span class="nav-number">6.1.10.</span> <span class="nav-text">code属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exceptions属性"><span class="nav-number">6.1.11.</span> <span class="nav-text">Exceptions属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LineNumberTable属性"><span class="nav-number">6.1.12.</span> <span class="nav-text">LineNumberTable属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LocalVariableTable属性与LocalVariableTypeTable属性"><span class="nav-number">6.1.13.</span> <span class="nav-text">LocalVariableTable属性与LocalVariableTypeTable属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConstantValue属性"><span class="nav-number">6.1.14.</span> <span class="nav-text">ConstantValue属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synthetic属性"><span class="nav-number">6.1.15.</span> <span class="nav-text">Synthetic属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Signature属性"><span class="nav-number">6.1.16.</span> <span class="nav-text">Signature属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BootStrapMethods属性"><span class="nav-number">6.1.17.</span> <span class="nav-text">BootStrapMethods属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节码指令简介"><span class="nav-number">6.2.</span> <span class="nav-text">字节码指令简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简介"><span class="nav-number">6.2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加载和存储指令"><span class="nav-number">6.2.2.</span> <span class="nav-text">加载和存储指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算指令"><span class="nav-number">6.2.3.</span> <span class="nav-text">运算指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型转换指令"><span class="nav-number">6.2.4.</span> <span class="nav-text">类型转换指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象创建与访问指令"><span class="nav-number">6.2.5.</span> <span class="nav-text">对象创建与访问指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作数栈管理指令"><span class="nav-number">6.2.6.</span> <span class="nav-text">操作数栈管理指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制转移指令"><span class="nav-number">6.2.7.</span> <span class="nav-text">控制转移指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法调用和返回指令"><span class="nav-number">6.2.8.</span> <span class="nav-text">方法调用和返回指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异常处理指令"><span class="nav-number">6.2.9.</span> <span class="nav-text">异常处理指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步指令"><span class="nav-number">6.2.10.</span> <span class="nav-text">同步指令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章-虚拟机类加载机制"><span class="nav-number">7.</span> <span class="nav-text">第七章 虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载的时机"><span class="nav-number">7.1.</span> <span class="nav-text">类加载的时机</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类的生命周期"><span class="nav-number">7.1.1.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#何时触发类的初始化-initialization-操作"><span class="nav-number">7.1.2.</span> <span class="nav-text">何时触发类的初始化(initialization)操作.</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载的过程"><span class="nav-number">7.2.</span> <span class="nav-text">类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#加载"><span class="nav-number">7.2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#验证"><span class="nav-number">7.2.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备"><span class="nav-number">7.2.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#解析"><span class="nav-number">7.2.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">7.2.5.</span> <span class="nav-text">初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类加载器"><span class="nav-number">7.3.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#概述-1"><span class="nav-number">7.3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类与类加载器"><span class="nav-number">7.3.2.</span> <span class="nav-text">类与类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派模型"><span class="nav-number">7.3.3.</span> <span class="nav-text">双亲委派模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ClassLoader-loadClass与Class-forName区别"><span class="nav-number">7.3.4.</span> <span class="nav-text">ClassLoader.loadClass与Class.forName区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第八章-虚拟机字节码执行引擎"><span class="nav-number">8.</span> <span class="nav-text">第八章 虚拟机字节码执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-2"><span class="nav-number">8.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行时栈帧结构"><span class="nav-number">8.2.</span> <span class="nav-text">运行时栈帧结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运行时栈帧结构-1"><span class="nav-number">8.2.1.</span> <span class="nav-text">运行时栈帧结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部变量表"><span class="nav-number">8.2.2.</span> <span class="nav-text">局部变量表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作数栈"><span class="nav-number">8.2.3.</span> <span class="nav-text">操作数栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态连接"><span class="nav-number">8.2.4.</span> <span class="nav-text">动态连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法返回地址"><span class="nav-number">8.2.5.</span> <span class="nav-text">方法返回地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法调用"><span class="nav-number">8.3.</span> <span class="nav-text">方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解析-1"><span class="nav-number">8.3.1.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分派"><span class="nav-number">8.3.2.</span> <span class="nav-text">分派</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态类型语言"><span class="nav-number">8.3.3.</span> <span class="nav-text">动态类型语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-7与动态类型"><span class="nav-number">8.3.4.</span> <span class="nav-text">JDK1.7与动态类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#invokedynamic指令"><span class="nav-number">8.3.5.</span> <span class="nav-text">invokedynamic指令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于栈的字节码解释执行引擎"><span class="nav-number">8.4.</span> <span class="nav-text">基于栈的字节码解释执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解释执行"><span class="nav-number">8.4.1.</span> <span class="nav-text">解释执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于栈的指令集和基于寄存器的指令集"><span class="nav-number">8.4.2.</span> <span class="nav-text">基于栈的指令集和基于寄存器的指令集</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第九章-类加载及执行子系统的案例与实战"><span class="nav-number">9.</span> <span class="nav-text">第九章 类加载及执行子系统的案例与实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tomcat-正统的类加载器架构"><span class="nav-number">9.1.</span> <span class="nav-text">Tomcat: 正统的类加载器架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WEb服务器需要解决的问题"><span class="nav-number">9.1.1.</span> <span class="nav-text">WEb服务器需要解决的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSGI-灵活的类加载器结构"><span class="nav-number">9.2.</span> <span class="nav-text">OSGI:灵活的类加载器结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSGI"><span class="nav-number">9.2.1.</span> <span class="nav-text">OSGI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节码生成技术与动态代理的实现"><span class="nav-number">9.3.</span> <span class="nav-text">字节码生成技术与动态代理的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字节码生成技术"><span class="nav-number">9.3.1.</span> <span class="nav-text">字节码生成技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-Proxy-生成的代理对象源码"><span class="nav-number">9.3.2.</span> <span class="nav-text">java Proxy 生成的代理对象源码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十章-早期-编译器-优化"><span class="nav-number">10.</span> <span class="nav-text">第十章 早期(编译器)优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Javac编译器"><span class="nav-number">10.1.</span> <span class="nav-text">Javac编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#javac编译器的整体过程"><span class="nav-number">10.1.1.</span> <span class="nav-text">javac编译器的整体过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#词法-语法分析"><span class="nav-number">10.1.2.</span> <span class="nav-text">词法,语法分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#填充符号表"><span class="nav-number">10.1.3.</span> <span class="nav-text">填充符号表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注解处理器-不是只用于处理注解的-它可以改变语法树节点-包括注解"><span class="nav-number">10.1.4.</span> <span class="nav-text">注解处理器(不是只用于处理注解的,它可以改变语法树节点(包括注解))</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语义分析-类似类加载连接的验证阶段-和字节码生成"><span class="nav-number">10.1.5.</span> <span class="nav-text">语义分析(类似类加载连接的验证阶段)和字节码生成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java语法糖"><span class="nav-number">10.2.</span> <span class="nav-text">Java语法糖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#语法糖概述"><span class="nav-number">10.2.1.</span> <span class="nav-text">语法糖概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#泛型与泛型擦除"><span class="nav-number">10.2.2.</span> <span class="nav-text">泛型与泛型擦除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动装箱与拆箱"><span class="nav-number">10.2.3.</span> <span class="nav-text">自动装箱与拆箱</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#条件编译"><span class="nav-number">10.3.</span> <span class="nav-text">条件编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实战-自定义插入式注解处理器"><span class="nav-number">10.4.</span> <span class="nav-text">实战 自定义插入式注解处理器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十一章-晚期-运行期-优化"><span class="nav-number">11.</span> <span class="nav-text">第十一章 晚期(运行期)优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-3"><span class="nav-number">11.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HotSpot虚拟机的JIT即使编译器"><span class="nav-number">11.2.</span> <span class="nav-text">HotSpot虚拟机的JIT即使编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解释器与编译器"><span class="nav-number">11.2.1.</span> <span class="nav-text">解释器与编译器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#编译对象和触发条件"><span class="nav-number">11.2.2.</span> <span class="nav-text">编译对象和触发条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看及分析编译结果"><span class="nav-number">11.2.3.</span> <span class="nav-text">查看及分析编译结果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译优化技术"><span class="nav-number">11.3.</span> <span class="nav-text">编译优化技术</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优化技术概览"><span class="nav-number">11.3.1.</span> <span class="nav-text">优化技术概览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#公共子表达式消除"><span class="nav-number">11.3.2.</span> <span class="nav-text">公共子表达式消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组边界检查消除-Array-Bounds-Checking-Elimination"><span class="nav-number">11.3.3.</span> <span class="nav-text">数组边界检查消除(Array Bounds Checking Elimination)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法内联"><span class="nav-number">11.3.4.</span> <span class="nav-text">方法内联</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逃逸分析"><span class="nav-number">11.3.5.</span> <span class="nav-text">逃逸分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十二章-Java内存模型与线程"><span class="nav-number">12.</span> <span class="nav-text">第十二章 Java内存模型与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概述-4"><span class="nav-number">12.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#硬件的效率与一致性"><span class="nav-number">12.2.</span> <span class="nav-text">硬件的效率与一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java内存模型"><span class="nav-number">12.3.</span> <span class="nav-text">Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主内存和工作内存"><span class="nav-number">12.3.1.</span> <span class="nav-text">主内存和工作内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存间的交互操作"><span class="nav-number">12.3.2.</span> <span class="nav-text">内存间的交互操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile变量的特殊规则"><span class="nav-number">12.3.3.</span> <span class="nav-text">volatile变量的特殊规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对于long和double变量的特殊规则"><span class="nav-number">12.3.4.</span> <span class="nav-text">对于long和double变量的特殊规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性-可见性-有序性"><span class="nav-number">12.3.5.</span> <span class="nav-text">原子性,可见性,有序性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先行先发送原则-happens-before"><span class="nav-number">12.3.6.</span> <span class="nav-text">先行先发送原则(happens-before)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java与线程"><span class="nav-number">12.4.</span> <span class="nav-text">Java与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的实现"><span class="nav-number">12.4.1.</span> <span class="nav-text">线程的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java线程调度"><span class="nav-number">12.4.2.</span> <span class="nav-text">Java线程调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第十三章-线程安全和锁优化"><span class="nav-number">13.</span> <span class="nav-text">第十三章 线程安全和锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全"><span class="nav-number">13.1.</span> <span class="nav-text">线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安全性与活跃性"><span class="nav-number">13.1.1.</span> <span class="nav-text">安全性与活跃性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java语言中的线程安全"><span class="nav-number">13.1.2.</span> <span class="nav-text">Java语言中的线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程安全的实现方式"><span class="nav-number">13.1.3.</span> <span class="nav-text">线程安全的实现方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁优化"><span class="nav-number">13.2.</span> <span class="nav-text">锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#锁消除"><span class="nav-number">13.2.1.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁粗化"><span class="nav-number">13.2.2.</span> <span class="nav-text">锁粗化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁转化关系"><span class="nav-number">13.2.3.</span> <span class="nav-text">锁转化关系</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vicyor"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">vicyor</p>
  <div class="site-description" itemprop="description">大路且慢慢,咱一步一步走完.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vicyor" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vicyor" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2457569580@qq.com" title="E-Mail → mailto:2457569580@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vicyor</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">822k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">12:27</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        






  <script>
  function leancloudSelector(url) {
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = visitors.getAttribute('id').trim();
      var title = visitors.getAttribute('data-flag-title').trim();

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.log('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.log('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return element.getAttribute('id').trim();
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.log('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=m9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id': 'm9GqFbk5NEr9mLiLAXCyheul-gzGzoHsz',
            'X-LC-Key': 'g7WSuE6aDmunoX4rgyBN7SJa',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'qQhr9rNGJh6YalJA0mfaaurx-gzGzoHsz',
    appKey: 'kJy8NJeOTMPnxQ3zLihOcnw3',
    placeholder: "请留下您的宝贵评论",
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: false,
    serverURLs: ''
  });
}, window.Valine);
</script>

	
		 <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
		 <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
		 <script type="text/javascript" src="/js/src/fireworks.js"></script>
	
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body>
</html>
